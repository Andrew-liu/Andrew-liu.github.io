<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> IOS之控制器数据传递和代理总结 · Snow Memory | Andrew Liu</title><meta name="description" content="IOS之控制器数据传递和代理总结 - Andrew Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">IOS之控制器数据传递和代理总结</h1><div class="post-info">Dec 6, 2014</div><div class="post-content"><hr>
<blockquote>
<p> copy: NSString/NSMutableArray<br> weak:代理/UI控件<br> strong: 其他OC对象</p>
</blockquote>
<p>#1. Segue</p>
<p>storyboard上每根界面跳转的线, 都是<code>UIStoryboardSegue</code>对象</p>
<p>每个Segue对象都有三个属性:</p>
<ul>
<li>唯一标识(<code>@property (nonatomic, readonly) NSString *identifier;</code>), </li>
<li>来源控制器(<code>@property (nonatomic, readonly) id sourceViewController;</code>)</li>
<li>目标控制器(<code>@property (nonatomic, readonly) id destinationViewController;</code>)</li>
</ul>
<p>##1.1. Segue的类型</p>
<ul>
<li>自动型: 点击<code>某控件</code>后, 自动执行Segue,自动完成界面跳转(由控制拖出, 用于不需要做任何判断直接跳转界面的情景)</li>
<li>手动型: 需要手写代码才能完成界面的跳转(按住control, 由来源<code>控制器(不是按钮)</code>拖线到目标控制器, 需要<code>设置标识</code>)</li>
</ul>
<a id="more"></a>
<p>##1.2. performSegueWithIdentifier:sender:方法的完整执行过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Segue必须由来源控制器来执行，也就是说，这个perform方法必须由来源控制器来调用</span></div><div class="line">self为源控制器</div><div class="line">第一个参数为Segue的表示, 第二个参数为要传递的数据*/</div><div class="line">[self performSegueWithIdentifier:@<span class="string">"login2contacts"</span> sender:nil];</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//登陆过程</span></div><div class="line">- (IBAction)login &#123;</div><div class="line">    <span class="comment">//账号验证</span></div><div class="line">    <span class="keyword">if</span> ([self.accountField.text isEqualToString:@<span class="string">"mj"</span>] &amp;&amp; [self.pwdField.text isEqualToString:@<span class="string">"123"</span>]) &#123;</div><div class="line">        <span class="comment">//显示一个遮盖, 下面为一个延迟执行函数</span></div><div class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(<span class="number">2.0</span> * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="comment">//移除遮盖</span></div><div class="line">            <span class="comment">//登陆</span></div><div class="line">            [self performSegueWithIdentifier:@<span class="string">"login2contact"</span> sender:nil];</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//执行login2contact这个Segue</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">//账户或者密码错误, 弹窗提示</span></div><div class="line">        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@<span class="string">"警告"</span> message:@<span class="string">"账号或者密码错误"</span> delegate:nil cancelButtonTitle:@<span class="string">"好的"</span> otherButtonTitles:nil, nil];</div><div class="line">        [alert show];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//执行Segue后, 跳转前会调用这个方法, 这个方法用来自己实现</span></div><div class="line"><span class="comment">//一般在这里给下一个控制器传递数据</span></div><div class="line">- (<span class="keyword">void</span>)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender</div><div class="line">&#123;</div><div class="line">    <span class="comment">//数据传递工作</span></div><div class="line">    <span class="comment">//1. 取得目标控制器</span></div><div class="line">    UIViewController *contactVc = segue.destinationViewController;</div><div class="line">    <span class="comment">//2. 设置标题</span></div><div class="line">    contactVc.title = [NSString stringWithFormat:@<span class="string">"%@的联系人列表"</span>, self.accountField.text];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>根据identifier去storyboard中找到对应的线</li>
<li>新建UIStoryboardSegue对象</li>
<li>设置Segue对象的sourceViewController（来源控制器）</li>
<li>新建并且设置Segue对象的destinationViewController（目标控制器）</li>
<li>调用sourceViewController的方法，做一些跳转前的准备工作并且传入创建好的Segue对象</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender;</div><div class="line"><span class="comment">// 这个sender是当初performSegueWithIdentifier:sender:中传入的sender</span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//执行跳转前调用这个方法做一些跳转准备</span></div><div class="line"><span class="comment">//在这个方法中目标控制器的 view 还没有被创建</span></div><div class="line">- (<span class="keyword">void</span>)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender</div><div class="line">&#123;</div><div class="line">    <span class="comment">//####每次跳转都会进入这个函数, 所以需要对跳转对象判断####</span></div><div class="line">    <span class="comment">//1. 获取目标控制器</span></div><div class="line">    id vc = segue.destinationViewController;</div><div class="line">    </div><div class="line">    <span class="comment">//判断其类型, 对不同类型的目标控制器执行不同的准备</span></div><div class="line">    <span class="keyword">if</span>([vc isKindOfClass:[AddViewController class]])</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//如果跳转到添加联系人的控制器, 进行跳转, 获取添加控制器</span></div><div class="line">        AddViewController *addVc = segue.destinationViewController;</div><div class="line">        <span class="comment">//设置代理, 拿到下一次控制器, 设置下一个控制器的代理为源控制器, 代理会在被触发时执行函数</span></div><div class="line">        addVc.delegate = self;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([vc isKindOfClass:[EditViewController class]])</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//如果是编辑控制器, 进行跳转, 获得编辑控制器</span></div><div class="line">        EditViewController *editVc = vc;</div><div class="line">        <span class="comment">//取得UITableView被点击选择的行号</span></div><div class="line">        NSIndexPath *path = [self.tableView indexPathForSelectedRow];</div><div class="line">        <span class="comment">//把模型数据传过去, 在目标控制器已经定义了contact模型对象</span></div><div class="line">        editVc.contact = self.contacts[path.row];</div><div class="line">        <span class="comment">//跳转之前给下一个控制器设置一个代理</span></div><div class="line">        editVc.delegate = self;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>调用Segue对象的- (void)perform;方法开始执行界面跳转操作<ul>
<li>取得sourceViewController所在的UINavigationController</li>
<li>调用UINavigationController的push方法将destinationViewController压入栈中，完成跳转</li>
</ul>
</li>
</ol>
<p>##1.3. 数据后传</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (IBAction)login &#123;</div><div class="line">    <span class="comment">//账号验证</span></div><div class="line">    <span class="keyword">if</span> ([self.accountField.text isEqualToString:@<span class="string">"mj"</span>] &amp;&amp; [self.pwdField.text isEqualToString:@<span class="string">"123"</span>]) &#123;</div><div class="line">        <span class="comment">//显示一个遮盖, 下面为一个延迟执行函数</span></div><div class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(<span class="number">2.0</span> * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="comment">//移除遮盖</span></div><div class="line">            <span class="comment">//登陆</span></div><div class="line">            [self performSegueWithIdentifier:@<span class="string">"login2contact"</span> sender:nil];</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//执行login2contact这个Segue</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">//账户或者密码错误, 弹窗提示</span></div><div class="line">        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@<span class="string">"警告"</span> message:@<span class="string">"账号或者密码错误"</span> delegate:nil cancelButtonTitle:@<span class="string">"好的"</span> otherButtonTitles:nil, nil];</div><div class="line">        [alert show];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//执行Segue后, 跳转前会调用这个方法, 这个方法用来自己实现</span></div><div class="line"><span class="comment">//一般在这里给下一个控制器传递数据</span></div><div class="line">- (<span class="keyword">void</span>)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender</div><div class="line">&#123;</div><div class="line">    <span class="comment">//数据传递工作</span></div><div class="line">    <span class="comment">//1. 取得目标控制器</span></div><div class="line">    UIViewController *contactVc = segue.destinationViewController;</div><div class="line">    <span class="comment">//2. 设置标题</span></div><div class="line">    contactVc.title = [NSString stringWithFormat:@<span class="string">"%@的联系人列表"</span>, self.accountField.text];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##1.4. 数据回传(重要)</p>
<blockquote>
<p>使用<code>代理</code></p>
</blockquote>
<p><strong>代理的实现过程</strong></p>
<ol>
<li>在目标控制器的头文件定义代理和代理对应的方法, 并定义代理属性</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"><span class="comment">//分别为联系人控制器, 联系人信息模型, 添加联系人控制器</span></div><div class="line">@<span class="class"><span class="keyword">class</span> <span class="title">ContactViewController</span>, <span class="title">Contact</span>, <span class="title">AddViewController</span>;</span></div><div class="line"><span class="comment">//设置代理</span></div><div class="line">@protocol AddViewControllerDelegate &lt;NSObject&gt;</div><div class="line">@optional</div><div class="line"><span class="comment">//声明代理的方法, 定义这个方法在源控制器(也是就代理使用者)</span></div><div class="line">- (<span class="keyword">void</span>)addViewController:(AddViewController *)addVc DidAddContact: (Contact *)contact;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface AddViewController : UIViewController</div><div class="line">@property (nonatomic, strong) ContactViewController *contacts;<span class="comment">//模型</span></div><div class="line">@property (nonatomic, weak) id&lt;AddViewControllerDelegate&gt; delegate; <span class="comment">//定义代理属性</span></div><div class="line">@end</div></pre></td></tr></table></figure>
<ol>
<li>当某个事件(<code>比如点击事件后需要传递数据给代理</code>)引发代理事件时, 通知代理, 如果代理有某个方法, 就调用这个方法通知道理</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//最好将所有参数封装成模型, 直接给代理传递模型</span></div><div class="line">- (IBAction)add &#123;</div><div class="line">    <span class="comment">//1. 关闭当前控制器(出栈)</span></div><div class="line">    [self.navigationController popViewControllerAnimated:YES];</div><div class="line">    <span class="comment">//2. 传递数据给上一级控制器(contactViewController)</span></div><div class="line">    <span class="comment">//2.1. 通知代理 (调用代理方法)</span></div><div class="line">    <span class="keyword">if</span> ([self.delegate respondsToSelector:@selector(addViewController:DidAddContact:)]) &#123;</div><div class="line">        <span class="comment">//初始化模型并复制</span></div><div class="line">        Contact *contact = [[Contact alloc] init];</div><div class="line">        contact.name = self.nameField.text;</div><div class="line">        contact.phone = self.phoneField.text;</div><div class="line">        <span class="comment">//给代理传入模型</span></div><div class="line">        [self.delegate addViewController:self DidAddContact:contact];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>代理遵守协议, 代理接到消息后, 执行代理方法</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@interface ContactViewController () &lt;AddViewControllerDelegate&gt;</div><div class="line">- (IBAction)logout:(id)sender;</div><div class="line">@property (nonatomic, strong) NSMutableArray *contacts;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">//add控制器的代理方法</div><div class="line">- (void)addViewController:(AddViewController *)addVc DidAddContact:(Contact *)contact</div><div class="line">&#123;</div><div class="line">    //1. 添加模型数据</div><div class="line">    [self.contacts addObject:contact];</div><div class="line">    //2. 刷新tableView表格</div><div class="line">    [self.tableView reloadData];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>联系人列表界面点击加号添加联系人(即将进行控制器的跳转), 调用<code>- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender</code>方法(拿到目标控制器,设置添加控制器的代理为self(也就是源控制器)</li>
<li>进行控制器跳转</li>
<li>add方法(目标控制器触发代理事件)关闭当前控制器,判断代理联系人控制器有没有实现某个方法, 调用联系人列表的代理</li>
<li>代理执行这个代理方法</li>
</ol>
<p>#2. 两种弹窗</p>
<p>##2.1. 底部弹窗</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//遵守协议</div><div class="line">@interface ContactViewController () &lt;UIActionSheetDelegate&gt;</div><div class="line"></div><div class="line">//设置底部弹窗需要遵守UIActionSheetDelegate协议</div><div class="line">- (IBAction)logout:(id)sender &#123;</div><div class="line">    UIActionSheet *sheet = [[UIActionSheet alloc] initWithTitle:@"确定要注销吗?" delegate:self cancelButtonTitle:@"取消" destructiveButtonTitle:@"确定" otherButtonTitles:nil, nil];</div><div class="line">    [sheet showInView:self.view];//显示弹窗</div><div class="line">&#125;</div><div class="line"></div><div class="line">//buttonIndex为被点击的按钮的索引, 由上到下从零编号</div><div class="line">- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex</div><div class="line">&#123;</div><div class="line">    if (buttonIndex != 0) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (buttonIndex == 0) &#123;</div><div class="line">        //点击了确定</div><div class="line">        [self.navigationController popViewControllerAnimated:YES];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##2.2. 直接弹窗</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (IBAction)login &#123;</div><div class="line">    <span class="comment">//账号:mj mima:123</span></div><div class="line">    <span class="keyword">if</span> ([self.accountField.text isEqualToString:@<span class="string">"mj"</span>] &amp;&amp; [self.pwdField.text isEqualToString:@<span class="string">"123"</span>]) &#123;</div><div class="line">        <span class="comment">//显示一个遮盖</span></div><div class="line">        <span class="comment">//模拟延迟</span></div><div class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(<span class="number">2.0</span> * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="comment">//移除遮盖</span></div><div class="line">            <span class="comment">//进行控制器的跳转</span></div><div class="line">            [self performSegueWithIdentifier:@<span class="string">"login2contact"</span> sender:nil];</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//执行login2contact这条线</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">//账户或者密码错误</span></div><div class="line">        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@<span class="string">"警告"</span> message:@<span class="string">"账号或者密码错误"</span> delegate:nil cancelButtonTitle:@<span class="string">"好的"</span> otherButtonTitles:nil, nil];</div><div class="line">        [alert show];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#3. 代理总结</p>
<blockquote>
<p>协议的定义并不实现任何方法(只做声明),当某个带向遵守协议, 这个对象必须实现协议中声明的方法</p>
</blockquote>
<p>A是B的代理, B将发送消息(数据)</p>
<ul>
<li>为B定义一个代理,并声明代理方法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@protocol 代理协议名称 &lt;NSObject&gt; </div><div class="line">@optional  </div><div class="line">声明代理方法  </div><div class="line">@end</div></pre></td></tr></table></figure>
<ul>
<li>B定义一个delegate变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface B : UIViewController</div><div class="line">@property (nonatomic, weak) id&lt;代理协议名称&gt; delegate; </div><div class="line">@end</div></pre></td></tr></table></figure>
<ul>
<li>当事件发生后, 判断协议, 然后通知代理</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([self.delegate respondsToSelector:@selector(声明的方法) &#123;</div><div class="line">        <span class="comment">//通知代理</span></div><div class="line">        [self.delegate 调用的声明的方法];</div></pre></td></tr></table></figure>
<ul>
<li>A遵守协议, 并B的代理为A</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface A () &lt;代理协议名称&gt;</div><div class="line">...</div><div class="line"></div><div class="line">B.delegate = self(A)</div></pre></td></tr></table></figure>
<ul>
<li>A中定义协议中的方法</li>
</ul>
<blockquote>
<p>受<a href="http://abbeychenxi.net/2014/12/05/IOS%E4%B9%8B%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%A7%94%E6%89%98/" target="_blank" rel="external">IOS之协议和委托</a>启发, 对代理理解更深入</p>
</blockquote>
<p>#4. 消息中心监听</p>
<blockquote>
<p><code>消息中心</code>就像一个广播基站，发送一条消息，在所有的添加监听的地方都能够收到此信息，并作出不同或者相同的动作</p>
</blockquote>
<p>在前4个页面中都创建一个消息中心用来监听 一个object <code>@&quot;change&quot;</code>,我们在第五个页面，通过消息中心，发送一个<code>@&quot;change&quot;</code> 消息，这样前四个页面就可以收到这个消息，然后做出相应的动作 </p>
<ul>
<li>一个文本输入框的文字发生改变时,文本输入框会发出一个<code>UITextFieldTextDidChangeNotification</code>通知</li>
<li>因此通过监听通知来监听文本输入框的文字改变</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textChange) name:UITextFieldTextDidChangeNotification object:textField];</div><div class="line"><span class="comment">// textField文本输入框的文字改变了,就会调用self的textChange方法</span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    <span class="comment">//文本框发生改变时会发生通知</span></div><div class="line">    <span class="comment">//监听者self控制器监 object要监听对象, selector为监听方法</span></div><div class="line">    <span class="comment">//添加消息中心监听(添加观察者，也能说成添加监听) [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(myNotification:)name:@“test1" object:nil]; </span></div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textChange) name:UITextFieldTextDidChangeNotification object:self.accountField];</div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textChange) name:UITextFieldTextDidChangeNotification object:self.pwdField];</div><div class="line">    </div><div class="line">    <span class="comment">//后发消息object:发送的参数 [[NSNotificationCenter defaultCenter]postNotificationName:@“test1" object:arra]; </span></div><div class="line">&#125;</div><div class="line"><span class="comment">//消息监听后必须移除监听</span></div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//文本框发生改变后调用(监听方法)</span></div><div class="line">- (<span class="keyword">void</span>)textChange</div><div class="line">&#123;</div><div class="line">    <span class="comment">//控制登陆按钮的状态</span></div><div class="line">    self.loginBtn.enabled = (self.accountField.text.length &amp;&amp; self.pwdField.text.length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://www.bkjia.com/IOSjc/910686.html" target="_blank" rel="external">iOS设计模式之NSNotificationCenter 消息中心</a></p>
<p>#5. UISwitch</p>
<ul>
<li>UISwitch继承自UIControl,因此也能像UIButton一样监听一些事件,比如状态改变事件</li>
<li>UISwitch可以通过拖线监听状态改变</li>
<li>UISwitch可以通过<code>addTarget:...</code>方法监听状态改变</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;</div><div class="line"><span class="comment">// 其中controlEvents参数传递的是:UIControlEventValueChanged(值改变事件)</span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//rmbPwd和autoLogin分别为UISwitch按钮</span></div><div class="line"><span class="comment">//记住密码开关状态改变</span></div><div class="line">- (IBAction)rmbPwdChange &#123;</div><div class="line">    <span class="keyword">if</span>(self.rmbPwd.isOn == NO)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//self.autoLogin.on = NO;</span></div><div class="line">        [self.autoLogin setOn:NO animated:YES];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (IBAction)autoLoginChange &#123;</div><div class="line">    <span class="keyword">if</span> (self.autoLogin.isOn) &#123;</div><div class="line">        <span class="comment">//self.rmbPwd.on = YES;</span></div><div class="line">        [self.rmbPwd setOn:YES animated:YES];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2014/12/08/Virtualenv简明教程/" class="prev">PREV</a><a href="/2014/12/05/Python网络爬虫-二-豆瓣抓站小计/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'snow-memory';
var disqus_identifier = '2014/12/06/IOS之控制器数据传递和代理总结/';
var disqus_title = 'IOS之控制器数据传递和代理总结';
var disqus_url = 'http://andrewliu.in/2014/12/06/IOS之控制器数据传递和代理总结/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//snow-memory.disqus.com/count.js" async></script><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>