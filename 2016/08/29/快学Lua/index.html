<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 快学Lua · Snow Memory | Andrew Liu</title><meta name="description" content="快学Lua - Andrew Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">快学Lua</h1><div class="post-info">Aug 29, 2016</div><div class="post-content"><p>本博客采用创作共用版权协议, 要求署名、非商业用途和保持一致. 转载本博客文章必须也遵循<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">署名-非商业用途-保持一致</a>的创作共用协议.</p>
<blockquote>
<p>工作需要用到Lua做一些脚本, 所以学习一下这个在游戏开发应用广泛的语言, 当然, 我更喜欢称之为撸啊撸语言…</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><code>Lua</code>是一种轻量语言，它的官方版本只包括一个精简的核心和最基本的库, </li>
<li>性能方面, Lua比Python快(这也是脚本语言选型中不用python的原因)</li>
<li>Lua与C/C++交互方便, 易于扩展</li>
<li><code>Lua</code>是一个动态弱类型语言, 支持增量式垃圾收集策略, 支持<code>协程</code></li>
<li>支持REPL(Read-Eval-Print Loop, 交互式解释器)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-- 命令行中输入lua, 使用REPL</div><div class="line">andrew_liu:Lua/ $ lua  </div><div class="line">Lua <span class="number">5.2</span><span class="number">.4</span>  Copyright (C) <span class="number">1994</span><span class="number">-2015</span> Lua.org, PUC-Rio</div><div class="line">&gt; <span class="keyword">print</span> <span class="string">"hello world"</span>  -- 国际编程学习惯例</div><div class="line">hello world</div><div class="line">&gt; print(<span class="string">"hello world"</span>)</div><div class="line">hello world</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>已经懒得再安利<code>brew</code>了(不好用你干我), 一行命令完成安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 安装路径为/usr/local/Cellar/lua</div><div class="line">$ brew install lua</div></pre></td></tr></table></figure>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote>
<p>单行注释使用<code>--</code>, 多行注释使用<code>--[[</code>和<code>--]]</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-- 这种为单行注释</div><div class="line">-- Date: 16/8/27</div><div class="line">-- Time: 22:33</div><div class="line"></div><div class="line">--[[</div><div class="line">    这里是多行注释</div><div class="line">--]]</div></pre></td></tr></table></figure>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><ul>
<li>lua中的所有变量默认为全局变量, 定义局部变量需要使用<code>local关键字</code>(是不是很变态)</li>
<li><strong>所有的数字</strong>都是双精度浮点型(double)</li>
<li>字符串可以使用单引号和双引号, 类似于<code>python</code>中的字符串表示形式</li>
<li>使用一个<code>未定义的变量</code>不会报错, 而是返回nil(类似于C/C++中的NULL)</li>
<li>一行语句可以同时定义多个变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-- variable</div><div class="line">age = 0 -- 全局变量</div><div class="line">sum = 2  -- 所有数字都是double型</div><div class="line">str = &apos;蛤丝&apos;  -- 字符串可以是单引号和双引号</div><div class="line">str1 = &quot;还是蛤丝&quot;</div><div class="line">-- 使用`[[]]`定义多行字符串时, 其空格都会被保留</div><div class="line">str2 = [[多行的字符串</div><div class="line">    以两个方括号</div><div class="line">    开始和结尾。]]</div><div class="line">sum = nil  -- 撤销sum的定义</div><div class="line"></div><div class="line">test = not_define</div><div class="line">print(test)</div><div class="line">name, age, sex = &quot;andrew&quot;, 18, &quot;male&quot;, &quot;蛤丝&quot;  -- 最后一个变量会被丢弃, 而不会报错(闷死发大财才是最吼得)</div></pre></td></tr></table></figure>
<h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><blockquote>
<p>if-else与python有些像, 不过需要注意if和elseif最后的<code>then</code>和末尾的<code>end</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-- if-else</div><div class="line">age = 100</div><div class="line">if age &lt;= 40 and  age &gt;= 20 then</div><div class="line">    print(&quot;young man!&quot;)</div><div class="line">elseif age &gt; 40 and age &lt; 100 then</div><div class="line">    print(&quot;old man&quot;)</div><div class="line">elseif age &lt; 20 then</div><div class="line">    print(&quot;too young&quot;)</div><div class="line">else</div><div class="line">    print(&quot;monster&quot;)</div><div class="line">end</div></pre></td></tr></table></figure>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li><code>Lua</code>同样支持三种循环, while循环, for循环, until循环(可以理解为C/C++中的do-while循环)</li>
</ul>
<p><strong>while循环</strong></p>
<p>当条件满足, 会一直执行循环体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-- while</div><div class="line">num = 0</div><div class="line">while num &lt; 10 do</div><div class="line">    print(num)</div><div class="line">    num = num + 1</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p><strong>for循环</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-- for</div><div class="line">sum = 0</div><div class="line">--  1表示从1开始, 10表示最大为10(包含10)</div><div class="line">-- C++: for (int i = 1, i &lt;= 10; ++i)</div><div class="line">for i = 1, 100 do  -- 包含1和100</div><div class="line">    sum = sum + i</div><div class="line">end</div><div class="line">-- 类似于Python中的range操作, 2表示, 每次循环后i执行+2操作</div><div class="line">-- C++: for (int i = 1, i &lt;= 10; i = i + 2)</div><div class="line">for i = 1, 10, 2 do  -- 1,3,5,7,9</div><div class="line">    print(i)</div><div class="line">    sum = sum + i</div><div class="line">end</div><div class="line">-- ..操作符用于连接字符串, 可以理解为python中字符串的+</div><div class="line">操作</div><div class="line">print(&quot;sum = &quot; .. sum)</div></pre></td></tr></table></figure>
<p><strong>until循环</strong>, 类似于C/C++中的do-while语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-- until(do-while)</div><div class="line">sum = 2</div><div class="line">-- 中文: 直到sum的值大于1000时, 才终止循环</div><div class="line">repeat</div><div class="line">    sum = sum ^ 2  -- 幂操作</div><div class="line">until sum &gt; 1000  </div><div class="line">print(&quot;do-while, sum = &quot;..sum)</div></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>函数在Lua中是一等公民</li>
<li>支持有名和匿名函数</li>
<li>函数最后有个end, 写C/C++/Python的可能不太适应</li>
<li>函数支持一次`返回多个变量</li>
<li>局部函数的定义只需要在函数前加个<code>local</code>, 和局部变量类似</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-- function(return支持返回多个值), 函数是一等公民</div><div class="line">function add(a, b)</div><div class="line">    return a + b</div><div class="line">end</div><div class="line">print(&quot;1 + 2 = &quot;..add(1, 2))</div><div class="line">-- 匿名函数</div><div class="line">f = function (a, b)</div><div class="line">    return a * b</div><div class="line">end</div><div class="line">print (&quot;匿名函数: &quot; .. f(2, 3))</div></pre></td></tr></table></figure>
<p><strong>递归(经典: 斐波那契)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function fib(n)</div><div class="line">  if n &lt; 2 then return n end</div><div class="line">  return fib(n - 2) + fib(n - 1)</div><div class="line">end</div></pre></td></tr></table></figure>
<h2 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h2><p><code>Table</code>是Lua中核心数据结构, 我理解为其他语言中的<code>Dict/Map</code>数据结构(key-value的数据结构), 而数组等在Lua中都是通过<code>Table</code>来表示的</p>
<blockquote>
<p>Table可以使用任何非nil的值作为key</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-- Lua唯一的组合数据结构</div><div class="line">-- 可以使用任何非nil值作为key</div><div class="line">-- Table(key-value数据结构)</div><div class="line">map = &#123;</div><div class="line">    name = &quot;andrew&quot;,  -- 此处name默认使用字符串作为key</div><div class="line">    age = 18,</div><div class="line">    sex = &quot;male&quot;</div><div class="line">&#125;</div><div class="line">-- 上下两种写法等价</div><div class="line">--map = &#123;[&apos;name&apos;] = &apos;andrew&apos;, [&apos;age&apos;] = 18, [&apos;sex&apos;] = &apos;male&apos;&#125;</div></pre></td></tr></table></figure>
<p>对Table创建, 读取, 更新和删除操作, key-value的读取可以通过<code>.</code>符号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-- Table的CRUD</div><div class="line">map[&apos;hobby&apos;] = &quot;膜蛤&quot;  -- map.hobby = &quot;膜蛤&quot;</div><div class="line">print(map.name)</div><div class="line">map.age = 19</div><div class="line">map.sex = nil  -- 删除key</div></pre></td></tr></table></figure>
<p>遍历一个Table</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-- 遍历一个Table</div><div class="line">for k, v in pairs(map) do</div><div class="line">    print(k, v)</div><div class="line">end</div></pre></td></tr></table></figure>
<h3 id="数组-列表"><a href="#数组-列表" class="headerlink" title="数组/列表"></a>数组/列表</h3><ul>
<li>数组是通过Table来实现的</li>
</ul>
<blockquote>
<p><code>Lua</code>中数组的下标是从1开始, 从1开始, 从1开始. 重要的事情说三遍.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-- array, 数组下标从1开始</div><div class="line">-- 数组中可以是不同类型的数据</div><div class="line">arr = &#123;&quot;string&quot;, 100, &quot;andrew&quot;, function() print(&quot;hello world&quot;) end &#125;</div><div class="line">-- 等价于</div><div class="line">-- arr = &#123;[1]=&quot;string&quot;, [2]=100, [3]=&quot;andrew&quot;, [4]=40, [5]=function() print(&quot;hello world&quot;) end&#125;</div><div class="line"></div><div class="line">for i = 1, #arr do  -- #arr表示数组的长度</div><div class="line">    print(arr[i])</div><div class="line">end</div></pre></td></tr></table></figure>
<h3 id="元表-metatable"><a href="#元表-metatable" class="headerlink" title="元表(metatable)"></a>元表(metatable)</h3><p>Table的<code>metatable</code>提供一种类似于操作符重载的机制, 写个python的可能重写个<code>__add__</code>方法, 感觉有点类似</p>
<ul>
<li>通过<code>setmetatable</code>将自己实现的metamethod绑定到对应的Table对象中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">-- table的元表提供一种机制,支持操作符重载</div><div class="line">data_one = &#123;a = 1, b = 2&#125;  -- data_one和data_two 可以看做表示1/2和3/4</div><div class="line">data_two = &#123;a = 3, b = 4 &#125;</div><div class="line">meta_fraction = &#123;&#125;  -- 新定义一个元表</div><div class="line">function meta_fraction.__add(f1, f2) -- __add是build-in的原方法</div><div class="line">    local sum = &#123;&#125;</div><div class="line">    sum.b = f1.b * f2.b</div><div class="line">    sum.a = f1.a * f2.b + f2.a * f1.b</div><div class="line">    return sum</div><div class="line">end</div><div class="line">setmetatable(data_one, meta_fraction)  -- 为之前定义的两个table设置metatable</div><div class="line">setmetatable(data_two, meta_fraction)</div><div class="line">s = data_one + data_two  -- 执行 + 操作</div></pre></td></tr></table></figure>
<ul>
<li>元表的<code>__index</code> 可以重载用于查找的点操作符, 我理解有点类似于python中的<code>__getattr__</code>, 对类中的属性做查找</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-- 当表要索引一个值时如table[key], Lua会首先在table本身中查找key的值,</div><div class="line">-- 如果没有并且这个table存在一个带有__index属性的Metatable, 则Lua会按照__index所定义的函数逻辑查找</div><div class="line">default_map = &#123;name = &apos;andrew&apos;, sex = &apos;male&apos; &#125;</div><div class="line">new_map = &#123;age = 18 &#125;</div><div class="line">setmetatable(default_map, &#123;__index = new_map&#125;)</div><div class="line">print(default_map.name, default_map.age)  -- 继承了new_map的属性</div></pre></td></tr></table></figure>
<h3 id="元方法-metamethod"><a href="#元方法-metamethod" class="headerlink" title="元方法(metamethod)"></a>元方法(metamethod)</h3><p><code>__add</code>这种方法在Lua中被称为元方法, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-- __add(a, b)                     for a + b </div><div class="line">-- __sub(a, b)                     for a - b </div><div class="line">-- __mul(a, b)                     for a * b </div><div class="line">-- __div(a, b)                     for a / b </div><div class="line">-- __mod(a, b)                     for a % b </div><div class="line">-- __pow(a, b)                     for a ^ b </div><div class="line">-- __unm(a)                        for -a </div><div class="line">-- __concat(a, b)                  for a .. b </div><div class="line">-- __len(a)                        for #a </div><div class="line">-- __eq(a, b)                      for a == b </div><div class="line">-- __lt(a, b)                      for a &lt; b </div><div class="line">-- __le(a, b)                      for a &lt;= b </div><div class="line">-- __index(a, b)  &lt;fn or a table&gt;  for a.b </div><div class="line">-- __newindex(a, b, c)             for a.b = c </div><div class="line">-- __call(a, ...)                  for a(...)</div></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><code>继承</code>同样是通过元表和元方法来实现的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-- table实现继承</div><div class="line">Dog = &#123;&#125;</div><div class="line">-- 这个new函数我理解为继承类的构造函数, 冒号(:)函数会使参数默认增加一个self作为参数</div><div class="line">function Dog:new()</div><div class="line">    -- 下面这句相当于继承的类增加的新的成员变量</div><div class="line">    local new_obj = &#123;sound = &apos;woof&apos;&#125;</div><div class="line">    self.__index = self</div><div class="line">    return setmetatable(new_obj, self)</div><div class="line">end</div><div class="line">function Dog:make_sound()  -- 等价于Dog.make_sound(Dog)</div><div class="line">    print(&quot;say &quot; .. self.sound)</div><div class="line">end</div><div class="line">-- 使用</div><div class="line">new_dog = Dog:new()  -- new_dog获得Dog的方法和变量列表</div><div class="line">new_dog:make_sound()</div></pre></td></tr></table></figure>
<ol>
<li><code>self.__index = self</code>是防止self被扩展后改写，所以，让其保持原样</li>
<li><code>setmetatable(new_obj, self)</code>会返回第一个参数, new_obj会得到self的函数</li>
<li><code>Dog:new()</code>调用方式会增加一个隐式参数<code>self</code></li>
</ol>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ol>
<li>require函数, 第一次执行后有缓存, 所以载入同样的lua文件时, 只有第一次的时候会去执行, 多次执行同一句require, 只有第一次生效</li>
<li>dofile函数, 类似于require, 但无缓存, 每次语句都会重新执行一次</li>
<li>loadfile加载一个lua文件, 但是并不运行它, 只要在需要的时候再像函数一样执行它</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-- module</div><div class="line">-- 1. require</div><div class="line">local test = require(&apos;module&apos;)  -- require文件会被缓存</div><div class="line">-- test.say_my_name()  -- 不能调用local</div><div class="line">test.say_hello()</div><div class="line">-- 2. dofile 类似require 但不缓存</div><div class="line">-- 3. loadfile加载一个lua文件, 但是并不运行它</div></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://book.luaer.cn/" target="_blank" rel="external">lua程序设计</a></li>
<li><a href="http://www.codingnow.com/2000/download/lua_manual.html" target="_blank" rel="external">Lua 5.1 参考手册(云风译)</a></li>
<li><a href="https://learnxinyminutes.com/docs/zh-cn/lua-cn/" target="_blank" rel="external">Learn Lua in Y Minutes</a></li>
<li><a href="http://coolshell.cn/articles/10739.html" target="_blank" rel="external">Lua简明教程</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2016/09/04/Lua编码规范/" class="prev">PREV</a><a href="/2016/08/14/Kqueue学习笔记/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>