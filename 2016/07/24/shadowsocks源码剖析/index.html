<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> shadowsocks源码剖析 · Snow Memory | Andrew Liu</title><meta name="description" content="shadowsocks源码剖析 - Andrew Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">shadowsocks源码剖析</h1><div class="post-info">Jul 24, 2016</div><div class="post-content"><blockquote>
<p>VPS上嗨皮的跑了那么久shadowsock的server了, 但一直比较想搞明白具体是怎么实现的. 前段时间比较忙, 最近总算有点私人时间了, 速度的强读一发shadowsocks源码</p>
</blockquote>
<h2 id="什么是shadowsocks"><a href="#什么是shadowsocks" class="headerlink" title="什么是shadowsocks?"></a>什么是shadowsocks?</h2><ul>
<li>不想再强行安利一发了, 毕竟开发者都被请去喝茶了</li>
<li>只需要知道和<code>G * F * W</code>有关就好了</li>
<li>如果上面你都不知道, 说明这篇文章与你无缘, 叉掉吧</li>
</ul>
<p>所读源码基于<a href="https://github.com/shadowsocks/shadowsocks-go" target="_blank" rel="external">shadowsocks-go 1.1.5</a>, 为什么选择golang实现版本? 我难道会告诉你, Golang的吉祥物太萌了, 我已经决定好好安利golang了. 正经点的回复, golang的语法灵活不失简洁, 棒棒哒.</p>
<a id="more"></a>
<h2 id="终入正题"><a href="#终入正题" class="headerlink" title="终入正题"></a>终入正题</h2><p>先来张图, 假装自己很专业…</p>
<p><img src="http://ww2.sinaimg.cn/large/ab508d3djw1f64vgco021j215m082jtz.jpg" alt=""></p>
<p><strong>流程概述:</strong></p>
<ol>
<li>shadowsocks包含local和server两个程序, local运行在当前登录想要翻墙的机器上, server运行在墙外的服务器上(比如我的server运行在<a href="http://www.vultr.com/?ref=6844015" target="_blank" rel="external">vultr家的VPS</a>上)</li>
<li>local监控本地1080端口, 提供socks v5协议接口, 浏览器请求和local的1080端口建立TCP连接, 首先进行local端对本机进程进行心跳检测, 然后与server端建立请求发出实际请求包(<code>目标的地址和端口</code>)</li>
<li>连接传输的数据通过加密,一般使用<code>aes-256-cfb</code></li>
<li>server端解密收到的数据, 然后与实际请求的目标ip和端口建立TCP连接, 将获取的数据写回到local端, local端最终写回到浏览器进程完成一次翻越长城.</li>
</ol>
<h2 id="show-me-your-code"><a href="#show-me-your-code" class="headerlink" title="show me your code"></a>show me your code</h2><blockquote>
<p>口说无凭, 也让人觉得云里雾里, 所以来是直接上代码吧</p>
</blockquote>
<p><strong>PS: 代码均进行了精简, 只保持核心逻辑</strong></p>
<ul>
<li>首先来看shadowsocks-local文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">// local的入口</div><div class="line">func main() &#123;</div><div class="line">    /*</div><div class="line">     * 1. 设置日志配置和命令行参数解析</div><div class="line">     * 2. 从文件中读取相关配置, 如server ip, port, 用户设置的密码, 本地监控端口等</div><div class="line">     */</div><div class="line">    run(cmdLocal + &quot;:&quot; + strconv.Itoa(config.LocalPort))</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 实际监控函数</div><div class="line">func run(listenAddr string) &#123;</div><div class="line">    /*</div><div class="line">     * 1. 设置要监控的端口</div><div class="line">     * 2. 在一个死循环中, 不断接收请求, 然后在goroutine中调用handleConnection(conn)处理请求</div><div class="line">     */</div><div class="line">    ln, err := net.Listen(&quot;tcp&quot;, listenAddr)</div><div class="line">    for &#123;  // 运行与一个死循环</div><div class="line">        conn, err := ln.Accept()</div><div class="line">        go handleConnection(conn)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 运行在goroutine中请求处理函数</div><div class="line">func handleConnection(conn net.Conn) &#123;</div><div class="line">    /*</div><div class="line">     * 1. 与请求进程进行心跳检测</div><div class="line">     * 2. 解析请求获取原始数据, 用于获取实际请求ip和port</div><div class="line">     * 3. 与墙外的server请求建立TCP连接, 并发送数据</div><div class="line">     * 4. 等待墙外server写入数据, 然后将数据写回给请求进程</div><div class="line">     */</div><div class="line">    handShake(conn)</div><div class="line">    rawaddr, addr, err := getRequest(conn)</div><div class="line"></div><div class="line">    _, err = conn.Write([]byte&#123;0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x43&#125;)</div><div class="line">    remote, err := createServerConn(rawaddr, addr)</div><div class="line"></div><div class="line">    go ss.PipeThenClose(conn, remote)</div><div class="line">    ss.PipeThenClose(remote, conn)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们来看一下 <code>PipeThenClose</code>这个函数的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// PipeThenClose copies data from src to dst, closes dst when done.</div><div class="line">func PipeThenClose(src, dst net.Conn) &#123;</div><div class="line">    // closes dst when done.</div><div class="line">    defer dst.Close()</div><div class="line">    /*</div><div class="line">     * 1. 从leaky buffer中获取空闲buffer</div><div class="line">     * 2. 从source net.Conn中读取数据, 然后转发给dst net.Conn</div><div class="line">     */</div><div class="line">    buf := leakyBuf.Get()</div><div class="line">    defer leakyBuf.Put(buf)</div><div class="line">    for &#123;</div><div class="line">        SetReadTimeout(src)</div><div class="line">        n, err := src.Read(buf)</div><div class="line">        // read may return EOF with n &gt; 0</div><div class="line">        // should always process n &gt; 0 bytes before handling error</div><div class="line">        if n &gt; 0 &#123;</div><div class="line">            // Note: avoid overwrite err returned by Read.</div><div class="line">            if _, err := dst.Write(buf[0:n]); err != nil &#123;</div><div class="line">                Debug.Println(&quot;write:&quot;, err)</div><div class="line">                break</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if err != nil &#123;</div><div class="line">            break</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>再来看shadowsocks-server代码, 你会发现两者惊人的相似</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 主要来handleConnection</div><div class="line">// goroutine, 内部需要自行保证线程安全</div><div class="line">func handleConnection(conn *ss.Conn, auth bool) &#123;</div><div class="line">    /* </div><div class="line">     * 1. 解析请求的ip:port</div><div class="line">     * 2. 建立TCP连接</div><div class="line">     * 3. 向目标站点发起请求, 响应数据写会到local</div><div class="line">     */</div><div class="line">    host, ota, err := getRequest(conn, auth)</div><div class="line"></div><div class="line">    //对应ip:port建立TCP连接</div><div class="line">    remote, err := net.Dial(&quot;tcp&quot;, host)</div><div class="line"></div><div class="line">    if ota &#123;</div><div class="line">        go ss.PipeThenCloseOta(conn, remote)</div><div class="line">    &#125; else &#123;</div><div class="line">        go ss.PipeThenClose(conn, remote)</div><div class="line">    &#125;</div><div class="line">    // 从remote读取数据</div><div class="line">    ss.PipeThenClose(remote, conn)</div><div class="line">    closed = true</div><div class="line">    return</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由local和server端总共四个<code>PipeThenClose</code>函数完成了由local到server, 再由server到local的数据传输. 但是要注意的是在<code>server端是没有与local进行心跳检测的阶段</code></p>
<h2 id="socks-v5"><a href="#socks-v5" class="headerlink" title="socks v5"></a>socks v5</h2><p>socks v5代码TCP协议的流程:</p>
<ol>
<li>用户进程与监听1080端口的进程建立TCP连接</li>
<li>心跳检测, 用户进程向监听进程发送<code>VER, NMETHODS, METHODS</code>, 监听进程向请求进程响应<code>VER, METHOD</code></li>
<li>用户进程结束心跳检测, 向监听进程发起请求, 格式如下</li>
<li>监听进程对用户进程响应, 表示成功, 则表示用户进程可以进行发送数据.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">向监听进程的请求:</div><div class="line">　  +----+-----+-------+------+----------+----------+</div><div class="line">　　|VER | CMD |　RSV　| ATYP | DST.ADDR | DST.PORT |</div><div class="line">　　+----+-----+-------+------+----------+----------+</div><div class="line">　　| 1　| 　1 | X&apos;00&apos; | 　1　| Variable |　　 2　　|</div><div class="line">　　+----+-----+-------+------+----------+----------+</div><div class="line">监听进程的响应: </div><div class="line">　　+----+-----+-------+------+----------+----------+</div><div class="line">　　|VER | REP |　RSV　| ATYP | BND.ADDR | BND.PORT |</div><div class="line">　　+----+-----+-------+------+----------+----------+</div><div class="line">　　| 1　|　1　| X&apos;00&apos; |　1 　| Variable | 　　2　　|</div><div class="line">　　+----+-----+-------+------+----------+----------+</div><div class="line"></div><div class="line">// 对应shadowsocks-local中的:</div><div class="line">_, err = conn.Write([]byte&#123;0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x43&#125;)</div></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/shadowsocks/shadowsocks-go" target="_blank" rel="external">shadowsocks-go 1.1.5</a></li>
<li><a href="https://www.ietf.org/rfc/rfc1928.txt" target="_blank" rel="external">socks v5 协议的 RFC</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2016/08/06/浅谈Raft/" class="prev">PREV</a><a href="/2016/07/02/Golang-RPC/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>