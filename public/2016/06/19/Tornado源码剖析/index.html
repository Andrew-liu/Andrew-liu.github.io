<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Tornado源码剖析 · Snow Memory | Andrew Liu</title><meta name="description" content="Tornado源码剖析 - Andrew Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Tornado源码剖析</h1><div class="post-info">Jun 19, 2016</div><div class="post-content"><h2 id="pdb调试"><a href="#pdb调试" class="headerlink" title="pdb调试"></a>pdb调试</h2><blockquote>
<p>简单的介绍一下pdb的调试, 更详细的命令查看<a href="https://docs.python.org/2/library/pdb.html" target="_blank" rel="external">python pdbf官方文档</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import pdb</div><div class="line">// 使用以下语句希望debug的地方打断点</div><div class="line">pdb.set_trace()</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">n</td>
<td style="text-align:center">运行下一行代码</td>
</tr>
<tr>
<td style="text-align:center">p</td>
<td style="text-align:center">计算p后面的表达式(当前上下文中), 并打印表达式的值</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">进入函数</td>
</tr>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">从函数中返回</td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:center">动态设置断点</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">打印当前栈信息</td>
</tr>
<tr>
<td style="text-align:center">q</td>
<td style="text-align:center">退出pdb</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="Tornado剖析"><a href="#Tornado剖析" class="headerlink" title="Tornado剖析"></a>Tornado剖析</h2><blockquote>
<p><code>Tornado</code> is a Python web framework and asynchronous networking library, originally developed at FriendFeed. By using <code>non-blocking network I/O</code>, Tornado can scale to tens of thousands of open connections, making it ideal for long polling, WebSockets, and other applications that require a long-lived connection to each user.</p>
</blockquote>
<p><strong>源码剖析基于Tornado 2.0.0及以下测试源码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># -*- coding: utf-8 -*-</div><div class="line">import tornado.web</div><div class="line">import tornado.httpserver</div><div class="line">import tornado.ioloop</div><div class="line">import tornado.options</div><div class="line">import os.path</div><div class="line"></div><div class="line">from tornado.options import define, options</div><div class="line">define(&quot;port&quot;, default=8000, help=&quot;run on the given port&quot;, type=int)</div><div class="line"></div><div class="line"></div><div class="line"># 继承Application</div><div class="line">class Application(tornado.web.Application):</div><div class="line"></div><div class="line">    def __init__(self):</div><div class="line">        handlers = [</div><div class="line">            (r&quot;/&quot;, MainHandler),</div><div class="line">        ]</div><div class="line">        settings = dict(</div><div class="line">            template_path=os.path.join(os.path.dirname(__file__), &quot;templates&quot;),</div><div class="line">            static_path=os.path.join(os.path.dirname(__file__), &quot;static&quot;),</div><div class="line">            debug=True,</div><div class="line">        )</div><div class="line">        tornado.web.Application.__init__(self, handlers, **settings)</div><div class="line"></div><div class="line"></div><div class="line"># URI Hanlder逻辑</div><div class="line">class MainHandler(tornado.web.RequestHandler):</div><div class="line">    def get(self):</div><div class="line">        import pdb</div><div class="line">        pdb.set_trace()</div><div class="line">        self.write(&quot;Hello, World&quot;)</div><div class="line"></div><div class="line"></div><div class="line">def run():</div><div class="line">    tornado.options.parse_command_line()</div><div class="line">    http_server = tornado.httpserver.HTTPServer(Application())</div><div class="line">    http_server.listen(options.port)</div><div class="line">    print &quot;Start server, http://localhost:%s&quot; % options.port</div><div class="line">    tornado.ioloop.IOLoop.instance().start()</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    run()</div></pre></td></tr></table></figure>
<p>首先运行一上源码(服务器端), 另外开启一个<code>Terminal</code>来发出请求(也可以使用浏览器来访问). 服务端收到请求后, 会在我们<code>pdb.set_trace()</code>停下等待调试.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 新的Terminal命令行执行以下命令</div><div class="line">$ curl http://localhost:8000</div><div class="line"></div><div class="line">// 此时服务器端会进入`pdb`调试状态. 输入w以获得当前调用栈信息如下:</div><div class="line">(Pdb) w</div><div class="line">  /Users/andrew_liu/Development/BackEnd/Python3/TornadoToturial/src/bin/run(13)&lt;module&gt;()</div><div class="line">-&gt; sys.exit(learn.learn_source.run())</div><div class="line">  /Users/andrew_liu/Development/BackEnd/Python3/TornadoToturial/src/learn/learn_source.py(41)run()</div><div class="line">-&gt; tornado.ioloop.IOLoop.instance().start()</div><div class="line">  /Users/andrew_liu/Development/BackEnd/Python3/TornadoToturial/src/.buildout/eggs/tornado-2.0-py2.7.egg/tornado/ioloop.py(233)start()</div><div class="line">-&gt; self._run_callback(callback)</div><div class="line">  /Users/andrew_liu/Development/BackEnd/Python3/TornadoToturial/src/.buildout/eggs/tornado-2.0-py2.7.egg/tornado/ioloop.py(370)_run_callback()</div><div class="line">-&gt; callback()</div><div class="line">  /Users/andrew_liu/Development/BackEnd/Python3/TornadoToturial/src/.buildout/eggs/tornado-2.0-py2.7.egg/tornado/stack_context.py(159)wrapped()</div><div class="line">-&gt; callback(*args, **kwargs)</div><div class="line">  /Users/andrew_liu/Development/BackEnd/Python3/TornadoToturial/src/.buildout/eggs/tornado-2.0-py2.7.egg/tornado/iostream.py(235)wrapper()</div><div class="line">-&gt; callback(*args)</div><div class="line">  /Users/andrew_liu/Development/BackEnd/Python3/TornadoToturial/src/.buildout/eggs/tornado-2.0-py2.7.egg/tornado/stack_context.py(159)wrapped()</div><div class="line">-&gt; callback(*args, **kwargs)</div><div class="line">  /Users/andrew_liu/Development/BackEnd/Python3/TornadoToturial/src/.buildout/eggs/tornado-2.0-py2.7.egg/tornado/httpserver.py(400)_on_headers()</div><div class="line">-&gt; self.request_callback(self._request)</div><div class="line">  /Users/andrew_liu/Development/BackEnd/Python3/TornadoToturial/src/.buildout/eggs/tornado-2.0-py2.7.egg/tornado/web.py(1282)__call__()</div><div class="line">-&gt; handler._execute(transforms, *args, **kwargs)</div><div class="line">  /Users/andrew_liu/Development/BackEnd/Python3/TornadoToturial/src/.buildout/eggs/tornado-2.0-py2.7.egg/tornado/web.py(927)_execute()</div><div class="line">-&gt; getattr(self, self.request.method.lower())(*args, **kwargs)</div><div class="line">&gt; /Users/andrew_liu/Development/BackEnd/Python3/TornadoToturial/src/learn/learn_source.py(33)get()</div><div class="line">-&gt; self.write(&quot;Hello, World&quot;)</div></pre></td></tr></table></figure>
<p>一. 首先<code>Application</code>调用<code>__init__</code>, 通过<code>self.add_handlers(&quot;.*$&quot;, handlers)</code>配置路由, 配置静态资源资源路径.<br>二. <code>tornado.httpserver.HTTPServer</code>接收一个<code>Application</code>参数并命名为<code>request_callback</code>, <strong>注意此处Application实例被命名为request_callback</strong> 留意<code>HTTPServer</code>中有一个属性<code>self._sockets</code>保存<code>fd</code>到<code>socket object</code>的映射.<br>三. 调用<code>HTTPServer</code>的<code>listen(options.port)</code>方法开始做socket监听. listen中做了两件事. 一: bind创建socket对象设置并设置非阻塞, 并进行<code>socket.bind()</code>和<code>socket.listen()</code>监听. 并在<code>self._sockets</code>保存socket描述符和socket对象的映射. 二: <code>start</code>函数初始化一个<code>IOLoop</code>对象(单例对象), 并遍历<code>self._sockets</code>socket描述符, 将其添加到<code>IOLoop</code>并绑定读事件</p>
<blockquote>
<p>为了方便查看, 本来去掉源码中的异常捕获和一些干扰阅读的细节</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># 步骤三中的核心代码</div><div class="line"></div><div class="line"># 步骤三第一部分</div><div class="line">class HTTPServer(object):</div><div class="line"></div><div class="line">    def bind(self, port, address=None, family=socket.AF_UNSPEC)</div><div class="line">        # 网编编程的一套, socket =&gt; bind =&gt; listen</div><div class="line">        sock = socket.socket(af, socktype, proto)</div><div class="line">        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div class="line">        sock.setblocking(0)</div><div class="line">        sock.bind(sockaddr)</div><div class="line">        sock.listen(128)</div><div class="line">        self._sockets[sock.fileno()] = sock</div><div class="line"></div><div class="line"></div><div class="line">    # 步骤三第二部分</div><div class="line">    def start(self, num_processes=1)</div><div class="line">        if not self.io_loop:</div><div class="line">            self.io_loop = ioloop.IOLoop.instance()  # 返回一个全局的IOLoop对象</div><div class="line">        for fd in self._sockets.keys():  # 对整个fd和socket对象的映射集合, 都加入到epoll, 并注册回调</div><div class="line">            self.io_loop.add_handler(fd, self._handle_events, ioloop.IOLoop.READ)  # 给每个fd绑定读事件, self._handle_events为回调事件(当fd可读的时候, 则调用此函数)</div></pre></td></tr></table></figure>
<p>四. <code>tornado.ioloop.IOLoop.instance().start()</code>中通过步骤三中全局的IOLoop对象执行<code>start</code>. 此处核心代码为<code>event_pairs = self._impl.poll(0.2)</code>. 其中<code>self._impl</code>根据不同平台来选择<code>select/poll/epoll/kqueue</code>, 每当有事件可读时, 则执行其回调函数<code>self._handle_events</code>. <strong>整个回调函数为HTTPServer中的handler_events函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 步骤四start中的核心代码</div><div class="line">class IOLoop(object):</div><div class="line">    def start(self)</div><div class="line">        while True:</div><div class="line">            event_pairs = self._impl.poll(poll_timeout)  # epoll对触发读事件的描述符返回, 此处说明有客户端访问服务器</div><div class="line">            self._events.update(event_pairs)  # 将要处理的事件更新到self._events这个dict中</div><div class="line">            while self._events:</div><div class="line">                fd, events = self._events.popitem()  # 随机取出一个事件(key-value)</div><div class="line">                self._handlers[fd](fd, events)  # self._handlers是在第三步中add_handler中添加的, self._handlers是fd描述符和self._handle_events形成的映射(dcit). 此处从self._handlers中取出fd描述符对应的self._handle_events执行.</div></pre></td></tr></table></figure>
<p>五. 最后我们发现, 让了一圈又回到<code>HTTPServer._handle_events</code>函数上. 函数中创建了IOStream对象和HTTPConnection对象.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 步骤五的核心代码</div><div class="line"></div><div class="line"># 当我们访问http://localhost:8000, epoll返回事件</div><div class="line">class HTTPServer(object):</div><div class="line">    def _handle_events(fd, event):</div><div class="line">        while True:</div><div class="line">            connection, address = self._sockets[fd].accept()  # 此处connection为客户端连接</div><div class="line">            stream = iostream.IOStream(connection, io_loop=self.io_loop)</div><div class="line">            HTTPConnection(stream, address, self.request_callback, self.no_keep_alive, self.xheaders)</div></pre></td></tr></table></figure>
<p>其中<code>iostream.IOstream</code>回通过client socket(<code>connection</code>)来初始化,  并且完成将fd注册到<code>IOLoop的epoll</code>中. 当fd可读时, 会调用<code>IOStream._handle_events</code>函数做回调, 描述符可读, 即客户端发送了HTTP, 读取客户端发送的数据写入IOStream中的<code>self._read_buffer</code>读缓冲区中.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class IOStream(object):</div><div class="line">    def __init__(self, socket, io_loop=None, max_buffer_size=104857600, read_chunk_size=4096):</div><div class="line">        self.socket = socket</div><div class="line">        self.socket.setblocking(False)</div><div class="line">        self.io_loop = io_loop or ioloop.IOLoop.instance()</div><div class="line">        self.max_buffer_size = max_buffer_size</div><div class="line">        self.read_chunk_size = read_chunk_size</div><div class="line">        self._state = self.io_loop.ERROR</div><div class="line">        with stack_context.NullContext():</div><div class="line">            self.io_loop.add_handler(</div><div class="line">                self.socket.fileno(), self._handle_events, self._state)  # 将client socket注册到io_loop中, 并绑定回调事件self.handle_events(IOStream)</div><div class="line">                </div><div class="line">    def _handle_events(self, fd, events):</div><div class="line">        if events &amp; self.io_loop.READ:  # 当客户端有链接时, 则event可读</div><div class="line">            self._handle_read()</div><div class="line">    </div><div class="line">    def _handle_read(self):</div><div class="line">        while True:</div><div class="line">            result = self._read_to_buffer()  # 将数据接入读缓冲区self._read_buffer中</div></pre></td></tr></table></figure>
<p>然后通过iostream来初始化<code>HTTPConnection</code>, 注意HTTPConnection中的<code>self.request_callback</code>属性就是在HTTPServer初始化时的<code>Application</code>. 其中执行<code>self.stream.read_until</code>并读取缓冲区的数据, 然后回调<code>HTTPConnection._on_headers</code>解析HTTP请求的头部, 然后<strong>出现了最重要的一步!!!</strong>, <code>self.request_callback(self._request)</code>, 终于出现了, 这是最吼的! <code>self.request_callback</code>就是我们用来初始化<code>HTTPServer</code>的<code>Application</code>对象呀!!! 这货有个黑魔法函数<code>__call__</code>, 可以直接对Application对象进行传参调用!!! 传入客户端的request请求到Application中.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># 这个类执行真正的客户端请求处理</div><div class="line">class HTTPConnection(object):</div><div class="line">    &quot;&quot;&quot;Handles a connection to an HTTP client, executing HTTP requests.</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    def __init__(self, stream, address, request_callback, no_keep_alive=False, xheaders=False):</div><div class="line">        self.stream = stream  # IOStream包含数据缓冲区</div><div class="line">        self.address = address</div><div class="line">        self.request_callback = request_callback  # Application类</div><div class="line">        self.no_keep_alive = no_keep_alive</div><div class="line">        self.xheaders = xheaders</div><div class="line">        self._request = None </div><div class="line">        self._header_callback = stack_context.wrap(self._on_headers)</div><div class="line">        self.stream.read_until(b(&quot;\r\n\r\n&quot;), self._header_callback)  # 通过指定分隔符从self.stream中读取数据, 然后回调self._header_callback, 即self._on_headers</div><div class="line">        </div><div class="line">    def _on_headers(self, data):</div><div class="line">        self._request = HTTPRequest(connection=self, method=method, uri=uri, version=version,headers=headers, remote_ip=self.address[0])  # 对请求的头部进行解析, 然后生成HTTPRequest对象, 注意此处的connection(HTTPConnection), 向客户端发送数据会用到</div><div class="line">        self.request_callback(self._request)  # 最后终于出现self.request_callback了!!! 这就是Application呀!! 执行他的黑魔法__call__方法</div></pre></td></tr></table></figure>
<p>六. 重新看栈信息<code>self.request_callback(self._request) web.py(1282)__call__()</code>完全符合我们的分析. <code>__call__</code>接收<code>self._request</code>, 其中通过<code>_request</code>中host信息作路径匹配, 如果路径相匹配则返回我们创建的<code>Handler类</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Application(object):</div><div class="line">    def __call__(self, request):</div><div class="line">        handlers = self._get_host_handlers(request)  # 获取与host匹配的handler</div><div class="line">        for spec in handlers:</div><div class="line">            match = spec.regex.match(request.path)</div><div class="line">            if match:</div><div class="line">                handler = spec.handler_class(self, request, **spec.kwargs)  # 找到最初我们注册的MainHandler并创建实例.</div><div class="line">        handler._execute(transforms, *args, **kwargs)</div><div class="line">        </div><div class="line">    def _get_host_handlers(self, request):</div><div class="line">        host = request.host.lower().split(&apos;:&apos;)[0]</div><div class="line">        for pattern, handlers in self.handlers:</div><div class="line">            if pattern.match(host):</div><div class="line">                return handlers</div></pre></td></tr></table></figure>
<p>我们再次查看栈信息, 发现此时的handler即为<code>MainHandler</code>, 并执行对象的<code>_execute</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-&gt; handler._execute(transforms, *args, **kwargs)</div><div class="line">(Pdb) l</div><div class="line">1277                 if getattr(RequestHandler, &quot;_templates&quot;, None):</div><div class="line">1278                     for loader in RequestHandler._templates.values():</div><div class="line">1279                         loader.reset()</div><div class="line">1280                 RequestHandler._static_hashes = &#123;&#125;</div><div class="line">1281</div><div class="line">1282 -&gt;            handler._execute(transforms, *args, **kwargs)</div><div class="line">1283             return handler</div><div class="line">1284</div><div class="line">1285         def reverse_url(self, name, *args):</div><div class="line">1286             &quot;&quot;&quot;Returns a URL path for handler named `name`</div><div class="line">1287</div><div class="line">(Pdb) print handler</div><div class="line">&lt;learn.learn_source.MainHandler object at 0x1054c7210&gt;</div></pre></td></tr></table></figure>
<p>七. <code>handler._execute</code>找到<code>request</code>中的HTTP方法, 然后执行对应的函数. 我们在MainHandler中实现了get方法, 此处会调用对应的方法. 并将数据发送给客户端.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">class RequestHandler(object):</div><div class="line">    def _execute(self, transforms, *args, **kwargs):</div><div class="line">        self.prepare()   # 次数调用了prepre方法</div><div class="line">        if not self._finished:</div><div class="line">            args = [self.decode_argument(arg) for arg in args]</div><div class="line">            kwargs = dict((k, self.decode_argument(v, name=k)) for (k,v) in kwargs.iteritems())</div><div class="line">            getattr(self, self.request.method.lower())(*args, **kwargs)  # 获取对应的get/post等方法的具体实现并执行.</div><div class="line">            if self._auto_finish and not self._finished:</div><div class="line">                self.finish()  # 数据的返回由finish完成</div><div class="line">    </div><div class="line">    def finish(self, chunk=None):</div><div class="line">        # 中间执行一些构造响应头部的操作</div><div class="line">        if not self.application._wsgi:</div><div class="line">            self.flush(include_footers=True)  # 数据刷新操作.</div><div class="line">            self.request.finish()  # 移除客户端的相关操作</div><div class="line">            self._log()</div><div class="line">        self._finished = True</div><div class="line">    </div><div class="line">    def flush(self, include_footers=False):</div><div class="line">        # Ignore the chunk and only write the headers for HEAD requests</div><div class="line">        if self.request.method == &quot;HEAD&quot;:</div><div class="line">            if headers: self.request.write(headers)</div><div class="line">            return</div><div class="line">        if headers or chunk:</div><div class="line">            self.request.write(headers + chunk) # write执行写入操作</div><div class="line"></div><div class="line">class HTTPRequest(object):</div><div class="line">    def write(self, chunk):</div><div class="line">        &quot;&quot;&quot;Writes the given chunk to the response stream.&quot;&quot;&quot;</div><div class="line">        assert isinstance(chunk, bytes_type)</div><div class="line">        self.connection.write(chunk)  # 此处connection是一个HTTPConnection</div><div class="line"></div><div class="line">class HTTPConnection(object):</div><div class="line">    def write(self, chunk):</div><div class="line">        &quot;&quot;&quot;Writes a chunk of output to the stream.&quot;&quot;&quot;</div><div class="line">        assert self._request, &quot;Request closed&quot;</div><div class="line">        if not self.stream.closed():</div><div class="line">            self.stream.write(chunk, self._on_write_complete)  # 实现写入操作有IOStream完成.</div><div class="line"></div><div class="line"># IOStream是对客户端socket的封装</div><div class="line">class IOStream(object):</div><div class="line">    def write(self, data, callback=None):</div><div class="line">        &quot;&quot;&quot;Write the given data to this stream.</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        assert isinstance(data, bytes_type)</div><div class="line">        self._check_closed()</div><div class="line">        self._write_buffer.append(data)</div><div class="line">        self._add_io_state(self.io_loop.WRITE)  # 这里改变为WRITE, 则执行写操作</div><div class="line">        self._write_callback = stack_context.wrap(callback)</div><div class="line">    </div><div class="line">    def _handle_events(self, fd, events):</div><div class="line">        if events &amp; self.io_loop.WRITE:</div><div class="line">            if self._connecting:</div><div class="line">                self._handle_connect()</div><div class="line">            self._handle_write()</div><div class="line"></div><div class="line">    def _handle_write(self):</div><div class="line">        while self._write_buffer:</div><div class="line">            num_bytes = self.socket.send(self._write_buffer[0])  # 终于完成了数据发送</div></pre></td></tr></table></figure>
<p>八. 完成数据写入client socket后, <code>HTTPRequest.finish()</code>被调用执行移除时间和关闭客户端socket操作. 是不是已经晕了, 稍等我们来画个图来理一理整个流程.</p>
<p><img src="http://ww1.sinaimg.cn/large/ab508d3djw1f2yxuks8orj20im0mnaem.jpg" alt=""></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://blog.csdn.net/zhaoxia_guo/article/details/6921572" target="_blank" rel="external">Tornado: 1. 流程分析</a></li>
<li><a href="http://www.jianshu.com/p/6d8dfbf5dcf5" target="_blank" rel="external">Tornado 源码分析 - 基础篇</a></li>
<li><a href="http://www.yeolar.com/note/2013/02/09/tornado-core/" target="_blank" rel="external">Tornado核心框架</a></li>
<li><a href="https://github.com/jiajunhuang/blog/blob/master/tornado.rst?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">Tornado 源码阅读</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-pythondebugger/" target="_blank" rel="external">Python 代码调试技巧</a></li>
<li><a href="https://www.zhihu.com/question/37271342/answer/81607536" target="_blank" rel="external">为什么 IO 多路复用要搭配非阻塞 IO?
</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2016/07/02/Golang-RPC/" class="prev">PREV</a><a href="/2016/06/05/Google-protobuf-C-学习笔记/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>