<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 快学Go · Snow Memory | Andrew Liu</title><meta name="description" content="快学Go - Andrew Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">快学Go</h1><div class="post-info">Mar 27, 2016</div><div class="post-content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><code>Go</code>是Google开发的一种静态强类型、编译型，并发型，并具有垃圾回收功能的编程语言</li>
<li>面向对象三大特性(封装/继承/多态), Go语言仅仅支持封装</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用go run test.go, 运行下面源码</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(<span class="string">"Hello, World"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul>
<li><p>常用类型<code>bool byte(uint8) string int(类型多, 就不一一列出了) float(float32, float64) complex(complex64, complex128)</code></p>
</li>
<li><p>var 语句定义了一个变量的列表</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 变量定义语法: var var_name type</span></div><div class="line"><span class="keyword">var</span> andrew <span class="keyword">string</span></div><div class="line"><span class="keyword">var</span> liu <span class="keyword">string</span> = <span class="string">"andrewliu"</span></div><div class="line"></div><div class="line"><span class="comment">// 段声明语法只能用在函数内</span></div><div class="line">k := <span class="number">3</span></div><div class="line"><span class="comment">// 表达式 T(v) 将值 v 转换为类型 T, Go不支持隐式转换! 必须显示转换类型</span></div><div class="line"><span class="keyword">var</span> f <span class="keyword">float32</span> = <span class="number">3.2222</span></div><div class="line"><span class="keyword">var</span> z <span class="keyword">uint</span> = <span class="keyword">uint</span>(f)</div><div class="line"><span class="comment">// 定义一个常量</span></div><div class="line"><span class="keyword">const</span> World = <span class="string">"世界"</span></div></pre></td></tr></table></figure>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><ul>
<li>if语言的condition不需要小括号</li>
<li>if语句的左大括号不能另起一行</li>
<li>可以在if语句中定义局部变量, 生命周期在if-else内</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// if语句后没有小括号, 但是逻辑题要使用&#123;&#125;</span></div><div class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</div><div class="line">        <span class="keyword">return</span> v  <span class="comment">// v的生命周期在if-else语句内部</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        fmt.Printf(<span class="string">"%g &gt;= %g\n"</span>, v, lim)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><ul>
<li>switch语句不需要显式的使用<code>break</code>, 满足条件后会自动终止</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    t := time.Now()</div><div class="line">    <span class="keyword">switch</span> &#123;  <span class="comment">// switch后可以没有语句, 类似于if-else if- else</span></div><div class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</div><div class="line">        fmt.Println(<span class="string">"Good morning!"</span>)  <span class="comment">//满足条件后会自动退出</span></div><div class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</div><div class="line">        fmt.Println(<span class="string">"Good afternoon."</span>)</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        fmt.Println(<span class="string">"Good evening."</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 类似于c语言, 只是没有小括号, 循环体使用&#123;&#125;</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    sum := <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">        sum += i</div><div class="line">    &#125;</div><div class="line">    fmt.Println(sum)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// c语言中的while语句, 在Go依然为for关键字</span></div><div class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</div><div class="line">        sum += sum</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="comment">//  while(true)语句</span></div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">    fmt.Println(<span class="string">"andrewliu"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>值得一提的是<code>range</code>, 类似迭代器操作, 返回<code>(索引, 值)</code>或 <code>(键, 值)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// range操作类似于python中的enumerate</span></div><div class="line"><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</div><div class="line">        fmt.Printf(<span class="string">"2**%d = %d\n"</span>, i, v)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><blockquote>
<p>Go竟然有指针, 我简直惊呆了</p>
</blockquote>
<ul>
<li>不支持指针运算, 不支持 <code>-&gt;</code> 运算符, 直接<code>.</code>访问成员</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">i, j := <span class="number">42</span>, <span class="number">2701</span></div><div class="line">p := &amp;i         <span class="comment">// p指针指向变量i</span></div><div class="line">fmt.Println(*p) <span class="comment">// p解引用操作, 读取内存地址上的值</span></div><div class="line">*p = <span class="number">21</span>         <span class="comment">// 通过指针来设置i的值</span></div><div class="line">fmt.Println(i)</div></pre></td></tr></table></figure>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul>
<li>使用<code>type</code>定义新的结构体</li>
<li><code>值类型</code>, 赋值和传参会复制全部内容</li>
<li>Go语言中没有类和继承的概念, 类似于类的机制可以通过struct来实现</li>
<li>struct支持嵌套</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</div><div class="line">    X <span class="keyword">float64</span></div><div class="line">    Y <span class="keyword">float64</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>方法(可以理解为类的成员函数)</strong></p>
<ol>
<li>Go没有类, 但可以通过结构体定义方法, 方法接收者<code>receiver</code>是出现在<code>func</code>关键字和方法名之间的参数</li>
<li>方法不支持重载</li>
<li>receiver可以为<code>结构体或者结构体指针</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> math.Sqrt(v.X * v.X + v.Y * v.Y)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>数组是值类型, 赋值和传参会复制整个数组</li>
<li>支持多维数组</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义一个长度为10的定长数组</span></div><div class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></div><div class="line"><span class="comment">// 通过初始化的值来确定数组长度</span></div><div class="line"><span class="keyword">var</span> b [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>slice</code>是引用类型</li>
<li><code>slice</code>并不是数组或数组指针, slice通过<code>内部指针</code>和相关属性(如长度, 容量)引用数组片段, 从来实现变长数组</li>
<li>读写操作实际目标是<code>底层数组</code></li>
<li>当slice容量满后, append后会重新分配底层数组, 并复制数据(很想C++中<code>vector</code>), 通常以2被容量重新分配底层数组</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 直接创建一个slice, 支持切片操作</span></div><div class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</div><div class="line"><span class="comment">// 使用make函数构造一个slice</span></div><div class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="comment">// 第一个参数为slice, 其余的元素被添加到slice尾部, 最终返回新slice对象</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(s []T, vs ...T)</span> []<span class="title">T</span></span></div></pre></td></tr></table></figure>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul>
<li>引用类型, 底层数据结构为哈希表(O(1)查询时间复杂度)</li>
<li>键必须是支持相等运算符<code>(==、!=)</code>类型, 如 number、string、 pointer、array、struct,以及对应的 interface</li>
<li>不保证key的顺序性</li>
<li>从map中得到的value是value的复制(可以通过将value值设为指针来直接修改数据)</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</div><div class="line"><span class="comment">// map需要通过make创建, []中为key的类型, 后面为value的类型</span></div><div class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</div><div class="line"></div><div class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</div><div class="line">    <span class="string">"Bell Labs"</span>: Vertex&#123;</div><div class="line">        <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"Google"</span>: Vertex&#123;</div><div class="line">        <span class="number">37.42202</span>, <span class="number">-122.08408</span>,</div><div class="line">    &#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 判断是否key存在在map中</span></div><div class="line"><span class="keyword">if</span> v, ok := m[<span class="string">"Apple"</span>]; !ok &#123;</div><div class="line">    <span class="comment">// key不存在则进入此逻辑</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 遍历一个map</span></div><div class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</div><div class="line">    <span class="comment">// some process for key-value</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>支持不定长变参, <code>不支持默认参数</code></li>
<li>可以有多个返回值</li>
<li>函数可以作为参数传递</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//  函数定义</div><div class="line">func add(x int, y int) int &#123;</div><div class="line">    return x + y  // 可以有多个返回值</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">//  通过()一次导入多个包</div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;time&quot;</div><div class="line">)</div><div class="line">func compute(fn func(float64, float64) float64) float64 &#123;</div><div class="line">    return fn(3, 4)</div><div class="line">&#125;</div><div class="line">func main() &#123;</div><div class="line">    fmt.Println(&quot;The time is&quot;, time.Now())</div><div class="line">    fmt.Println(&quot; My name is Liubin&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>函数作为参数</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> FormatFunc <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>, x, y <span class="keyword">int</span>)</span> <span class="title">string</span> // 定义函数类型。</span></div><div class="line"><span class="title">func</span> <span class="title">format</span><span class="params">(fn FormatFunc, s <span class="keyword">string</span>, x, y <span class="keyword">int</span>)</span> <span class="title">string</span> &#123;</div><div class="line">    <span class="keyword">return</span> fn(s, x, y)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>可变参数</strong>, 只能有一个, 必须位于参数表最后.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 可变参数本质上是一个slice,</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(s <span class="keyword">string</span>, n ...<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></div><div class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> n &#123;</div><div class="line">        x += i</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fmt.Sprintf(s, x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>匿名函数</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数内设置一个匿名函数变量</span></div><div class="line">fn := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">"Hello, World!"</span>) &#125;</div><div class="line">fn()</div></pre></td></tr></table></figure>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>关键字<code>defer</code> 用于注册延迟调用, <strong>defer后跟的语句知道return前才被调用</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"os"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">    file, err := os.Create(<span class="string">"test.txt"</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        log.Fatal(<span class="string">"create file err: "</span>, err)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">defer</span> file.Close()</div><div class="line">    file.WriteString(<span class="string">"Hello, World"</span>)</div><div class="line">    <span class="keyword">return</span>  <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    test()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote>
<p>接口是一个或多个<code>方法签名</code>的集合, 任何类型的方法集中只要拥有对应的全部方法, 就表示<code>实现</code>了该接口, <code>无需显示添加接口声明</code> –摘自<go学习笔记></go学习笔记></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 接口没有数据字段, 没有方法实现</span></div><div class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</div><div class="line">    String() <span class="keyword">string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p><code>error</code>是一个<code>build-in</code>的接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</div><div class="line">    Error() <span class="keyword">string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如何使用错误处理呢?</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">learnErrorHandling</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// ", ok"用来判断有没有正常工作 </span></div><div class="line">    m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">3</span>: <span class="string">"three"</span>, <span class="number">4</span>: <span class="string">"four"</span>&#125;</div><div class="line">    <span class="keyword">if</span> x, ok := m[<span class="number">1</span>]; !ok &#123; <span class="comment">// ok 为false，因为m中没有1</span></div><div class="line">        fmt.Println(<span class="string">"no one there"</span>)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        fmt.Print(x) <span class="comment">// 如果x在map中的话，x就是那个值喽。</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 错误可不只是ok，它还可以给出关于问题的更多细节。</span></div><div class="line">    <span class="keyword">if</span> _, err := strconv.Atoi(<span class="string">"non-int"</span>); err != <span class="literal">nil</span> &#123; <span class="comment">// _ discards value</span></div><div class="line">        <span class="comment">// 输出"strconv.ParseInt: parsing "non-int": invalid syntax"</span></div><div class="line">        fmt.Println(err)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>Go 提供并发特性, 类似于协程的<code>goroutine机制</code>(语言层面特性)</p>
<blockquote>
<p>官方博客中对goroutinue的解释: A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space. <code>在同一块地址空间多个goroutinue并发执行函数.</code></p>
</blockquote>
<ul>
<li>在函数调用语句前加一个<code>go关键字</code>, 就可以实现goroutine并发</li>
<li>多个goroutinue执行次序无法保证</li>
<li>channel用于多个goroutinue通信, <code>内部实现了同步来确保并发安全</code>. <strong>默认为同步模式, 需要发送和接收配对. 否则被阻塞</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_goroutinue</span><span class="params">()</span></span> &#123;</div><div class="line">    data := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)  <span class="comment">// 数据交换队列</span></div><div class="line">    exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)  <span class="comment">//退出通知</span></div><div class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">for</span> d := <span class="keyword">range</span> data &#123;  <span class="comment">// 从队列迭代接收数据, 直到close</span></div><div class="line">            fmt.Println(d)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        fmt.Println(<span class="string">"recv over."</span>)</div><div class="line">        exit &lt;- <span class="literal">true</span>  <span class="comment">// 发送退出通知</span></div><div class="line">    &#125;()</div><div class="line"></div><div class="line">    data &lt;- <span class="number">1</span>  <span class="comment">// 发送数据</span></div><div class="line">    data &lt;- <span class="number">2</span></div><div class="line">    data &lt;- <span class="number">3</span></div><div class="line">    <span class="built_in">close</span>(data)</div><div class="line"></div><div class="line">    fmt.Println(<span class="string">"send over."</span>)</div><div class="line">    &lt;- exit  <span class="comment">// 等待退出通知</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/qyuhen/book" target="_blank" rel="external">Go学习笔记</a></li>
<li><a href="https://learnxinyminutes.com/docs/go/" target="_blank" rel="external">Learn Go in Y minutes</a></li>
<li><a href="https://tour.golang.org/welcome/1" target="_blank" rel="external">A tour of the Go</a></li>
<li><a href="https://www.zhihu.com/question/27158146" target="_blank" rel="external">Go 语言的错误处理机制是一个优秀的设计吗？</a></li>
<li><a href="http://blog.golang.org/errors-are-values" target="_blank" rel="external">Errors are values</a></li>
<li><a href="https://golang.org/doc/effective_go.html#concurrency" target="_blank" rel="external">Effective Go - Concurrent</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2016/04/02/Google-MapReduce/" class="prev">PREV</a><a href="/2016/03/19/快学Clojure/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>