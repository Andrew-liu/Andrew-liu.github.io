<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Go goroutine同步 · Snow Memory | Andrew Liu</title><meta name="description" content="Go goroutine同步 - Andrew Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Go goroutine同步</h1><div class="post-info">Apr 8, 2016</div><div class="post-content"><p>本博客采用创作共用版权协议, 要求署名、非商业用途和保持一致. 转载本博客文章必须也遵循<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">署名-非商业用途-保持一致</a>的创作共用协议.</p>
<p>出现问题场景: 一个函数run()中包含多个goroutine函数并发, 这些goroutine函数会生成中间文件, 被run()函数运行结束后的check()函数检查. 当goroutine并发时, 并不会阻塞run()的上下文, 可能导致的情况为run()函数执行完毕(<code>但其中的goroutine并发函数没有执行完毕</code>), 导致check()函数执行失败.</p>
<p><strong>所以我们需要一种操作, 直到当前所有goroutine没有执行完毕, 才进行下一步操作</strong></p>
<blockquote>
<p>所以需要<code>goroutine同步</code>, go提供了<code>sync包</code>和<code>channel机制</code>来解决goroutine之间的同步问题</p>
</blockquote>
<a id="more"></a>
<h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for. Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.  -- 出自官方文档</div></pre></td></tr></table></figure>
<p>大概意思是: <code>WaitGroup</code>等待一组goroutinue执行完毕. 主goroutinue调用<code>Add</code>设置等待的goroutinue数量. 每个goroutinue应该在执行结束时调用<code>Done</code>. <code>Wait</code>会阻塞知道所有goroutinue执行完毕.</p>
<blockquote>
<p><code>WaitGroup</code>的用于某个地方需要创建多个goroutine，并且一定要等它们都执行完毕后再继续执行接下来的操作.</p>
</blockquote>
<p>可以把<code>WaitGroup</code>看作一个类似任务队列的结构. Add想队列增加任务, Done完成任务, Wait在队列不空的时候阻塞在哪里.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 官方文档中的example</div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;sync&quot;</div><div class="line">    &quot;net/http&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var wg sync.WaitGroup  // 声明一个WaitGroup变量</div><div class="line">    var urls = []string&#123;</div><div class="line">            &quot;http://www.baidu.org/&quot;,</div><div class="line">            &quot;http://www.alibaba.com/&quot;,</div><div class="line">            &quot;http://www.qq.com/&quot;,</div><div class="line">    &#125;</div><div class="line">    for _, url := range urls &#123;</div><div class="line">            wg.Add(1)  // WaitGroup的计数加1</div><div class="line">            // Launch a goroutine to fetch the URL.</div><div class="line">            go func(url string) &#123;</div><div class="line">                    defer wg.Done() //  goroutinue完成后, WaitGroup的计数-1</div><div class="line">                    // Fetch the URL.</div><div class="line">                    http.Get(url)</div><div class="line">            fmt.Println(url);</div><div class="line">            &#125;(url)</div><div class="line">    &#125;</div><div class="line">    // Wait for all HTTP fetches to complete.</div><div class="line">    wg.Wait()  // 等待所有goroutinue完成</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><blockquote>
<p>channel同样可以用来同步goroutinue</p>
</blockquote>
<p><strong>channel四种操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// make创建chennel, 第一个参数为channel的类型, 第二个参数为channel缓冲区的大小, 为0或者不传入该参数则表示没有缓冲区</div><div class="line">exampleChannel := make(chan int, 100) </div><div class="line"></div><div class="line">// 放入数据到channel (channel &lt;- data) </div><div class="line">exampleChannel &lt;- 1</div><div class="line"></div><div class="line">// 取出数据 (&lt;-channel)</div><div class="line">number := &lt;-exampleChannel</div><div class="line"></div><div class="line">// 关闭channel (通过close()函数)</div><div class="line">close(exampleChannel)</div></pre></td></tr></table></figure>
<p>channel是一种<code>阻塞管道</code>, 是自动阻塞的. 如果<code>channel</code>满了, 对channel放入数据的操作就会阻塞, 直到有某个routine从channel中取出数据, 这个放入数据的操作才会执行. 相反同理, 如果管道是空的, 一个从channel取出数据的操作就会阻塞，直到某个routine向这个channel中放入数据, 这个取出数据的操作才会执行(原理非常类似阻塞型socket的读写缓冲区)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// 上面的样例代码使用chan同步的方式来重写</div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;net/http&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var urls = []string&#123;</div><div class="line">            &quot;http://www.baidu.org/&quot;,</div><div class="line">            &quot;http://www.alibaba.com/&quot;,</div><div class="line">            &quot;http://www.qq.com/&quot;,</div><div class="line">    &#125;</div><div class="line">    doneChannel := make(chan int, len(urls))  // 创建channel</div><div class="line">    for _, url := range urls &#123;</div><div class="line">            // Increment the WaitGroup counter.</div><div class="line">            // Launch a goroutine to fetch the URL.</div><div class="line">            go func(url string) &#123;</div><div class="line">                    // Decrement the counter when the goroutine completes.</div><div class="line">                    // Fetch the URL.</div><div class="line">                    http.Get(url)</div><div class="line">                    doneChannel &lt;- 1  // 向channel里放入数据表示完成操作</div><div class="line">            fmt.Println(url);</div><div class="line">            &#125;(url)</div><div class="line">    &#125;</div><div class="line">    // Wait for all HTTP fetches to complete.</div><div class="line">    for i := 0; i &lt; len(urls); i++&#123;</div><div class="line">        &lt;-doneChannel  // 当可以取出len(urls)个数据时, 表示所有goroutinue都完成</div><div class="line">    &#125;</div><div class="line">    fmt.Printf(&quot;Finish..\n&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>当任务的数量不固定</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line">func test_chan(groutineChan chan int, feedbackChan chan string) &#123;</div><div class="line">    defer func() &#123;</div><div class="line">        &lt;-groutineChan</div><div class="line">        feedbackChan &lt;- &quot;finish&quot;</div><div class="line">    &#125;()</div><div class="line"></div><div class="line">    // do some process</div><div class="line">    // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    var (</div><div class="line">        goroutineChan chan int    = make(chan int, 20)</div><div class="line">        feedbackChan chan string = make(chan string, 10000)</div><div class="line">        counter int</div><div class="line">        finish int</div><div class="line">    )</div><div class="line">    for i := 0; i &lt; 1000; i++ &#123;</div><div class="line">        goroutineChan &lt;- 1</div><div class="line">        counter++</div><div class="line">        go test_chan(goroutineChan, feedbackChan)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for &#123;</div><div class="line">        msg := &lt;-feedbackChan  // 从channel取出字符串</div><div class="line">        if msg == &quot;finish&quot; &#123;</div><div class="line">            finish++  // 没完成一个完成计数器加一</div><div class="line">        &#125;</div><div class="line">        if finish == counter &#123; //当完全计数器等于计数器表示所有的goroutine完成</div><div class="line">            break</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    fmt.Printf(&quot;Finish..\n&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.baiyuxiong.com/?p=913" target="_blank" rel="external">go语言WaitGroup用法</a></li>
<li><a href="http://studygolang.com/articles/4992" target="_blank" rel="external">golang学习笔记之—WaitGroup</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2016/04/16/6-824-Lab-1-MapReduce-2016/" class="prev">PREV</a><a href="/2016/04/02/Google-MapReduce/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>