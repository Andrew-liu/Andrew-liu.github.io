<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Kqueue学习笔记 · Snow Memory | Andrew Liu</title><meta name="description" content="Kqueue学习笔记 - Andrew Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Kqueue学习笔记</h1><div class="post-info">Aug 14, 2016</div><div class="post-content"><p>本博客采用创作共用版权协议, 要求署名、非商业用途和保持一致. 转载本博客文章必须也遵循<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">署名-非商业用途-保持一致</a>的创作共用协议.</p>
<blockquote>
<p>想在Mac上造点小轮子, 然而epoll是在Linux平台独有的, 所以想到了用kqueue来替代. 记录一下自己的学习过程.</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li><code>kqueue</code>是在UNIX上高效的IO复用技术, 类比于linux平台中的<code>epoll</code>.</li>
<li>IO复用原理大概为: 网卡设备对应一个中断号, 当网卡收到网络端的消息的时候会向CPU发起中断请求, 然后CPU处理该请求. 通过驱动程序 进而操作系统得到通知, 系统然后通知epoll/kqueue, epoll/kqueue通知用户代码. </li>
</ul>
<a id="more"></a>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>kqueue使用的头文件和api可以通过<code>man kqueue</code>来看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/event.h&gt;</div><div class="line">#include &lt;sys/time.h&gt;</div></pre></td></tr></table></figure>
<ul>
<li><code>kqueue()</code>系统调用会创建一个新的内核消息队列并返回描述符.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 创建失败返回-1, 否则返回描述符</div><div class="line">int kqueue(void);</div></pre></td></tr></table></figure>
<ul>
<li>kqueue的数据结构</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct kevent &#123;</div><div class="line">    uintptr_t       ident;          /* identifier for this event, 该事件关联的文件描述符 */</div><div class="line">    int16_t         filter;         /* filter for event */</div><div class="line">    uint16_t        flags;          /* general flags, 用于指定事件操作类型, 比如EV_ADD, EV_ENABLE, EV_DELETE等, 通过|可以同时设置多个事件 */</div><div class="line">    uint32_t        fflags;         /* filter-specific flags */</div><div class="line">    intptr_t        data;           /* filter-specific data */</div><div class="line">    void            *udata;         /* opaque user data identifier */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><code>EV_SET()</code>在官方文档描述是一个宏,  用于初始化kevent数据结构</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EV_SET(&amp;kev, ident, filter, flags, fflags, data, udata);</div><div class="line">// 使用范例, 将监听stdin描述符的可读事件初始化到ev数据结构</div><div class="line">kevent ev;</div><div class="line">EV_SET(&amp;ev, STDIN_FILENO, EVFILT_READ, EV_ADD, 0, 0, 0);</div></pre></td></tr></table></figure>
<ul>
<li><code>kevent</code>为核心函数, 初始时<code>kqueue</code>内核消息队列为空, 使用kevent进行事件填充, 在不设置超时参数时, 只有当收到某监听事件才会返回. 该函数返回接收到事件个数, 并将事件写入eventlist</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># changelist为要注册的事件列表, eventlist用于返回已经就绪的事件列表</div><div class="line">int kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout);</div></pre></td></tr></table></figure>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;          // fprintf</div><div class="line">#include &lt;sys/event.h&gt;      // kqueue</div><div class="line">#include &lt;netdb.h&gt;          // addrinfo</div><div class="line">#include &lt;arpa/inet.h&gt;      // AF_INET</div><div class="line">#include &lt;sys/socket.h&gt;     // socket</div><div class="line">#include &lt;assert.h&gt;         // assert</div><div class="line">#include &lt;string.h&gt;         // bzero</div><div class="line">#include &lt;stdbool.h&gt;        // bool</div><div class="line">#include &lt;unistd.h&gt;         // close</div><div class="line"></div><div class="line">const size_t BUF_SIZE = 1024;</div><div class="line">static bool s_stop = true;</div><div class="line">// 信号处理函数</div><div class="line">static void handle_signal(int sig) &#123;</div><div class="line">    s_stop = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int learn_kqueue(const char* ip, int32_t port) &#123;</div><div class="line">    std::cout &lt;&lt; &quot;ip: &quot; &lt;&lt; ip &lt;&lt; &quot; port: &quot; &lt;&lt; port &lt;&lt; std::endl;</div><div class="line">    signal(SIGTERM, handle_signal);</div><div class="line">    int sock = socket(PF_INET, SOCK_STREAM, 0);</div><div class="line">    assert(sock &gt; 0);</div><div class="line"></div><div class="line">    // 强制使用TIME_WAIT状态的socket地址</div><div class="line">    int reuse = 1;</div><div class="line">    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeof(reuse));</div><div class="line"></div><div class="line">    struct sockaddr_in address;</div><div class="line">    bzero(&amp;address, sizeof(address));</div><div class="line">    address.sin_family = AF_INET;</div><div class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr); //主机序转网络序ip</div><div class="line">    address.sin_port = htons(port); //主机序转网络序</div><div class="line"></div><div class="line">    int ret = bind(sock, (struct sockaddr*)&amp;address, sizeof(address));</div><div class="line">    assert(ret != -1);</div><div class="line">    ret = listen(sock, BACK_LOG);</div><div class="line">    assert(ret != -1);</div><div class="line"></div><div class="line">    //创建一个消息队列并返回kqueue描述符</div><div class="line">    int kq =  kqueue();</div><div class="line">    assert(kq != -1);</div><div class="line"></div><div class="line">    struct kevent change_list[10];  //想要监控的事件</div><div class="line">    struct kevent event_list[10];  //用于kevent返回</div><div class="line">    char buf[BUF_SIZE];</div><div class="line">    // 监听sock的读事件</div><div class="line">    EV_SET(&amp;change_list[0], sock, EVFILT_READ, EV_ADD | EV_ENABLE, 0, 0, 0);</div><div class="line">    // 监听stdin的读事件</div><div class="line">    EV_SET(&amp;change_list[1], fileno(stdin), EVFILT_READ, EV_ADD | EV_ENABLE, 0, 0, 0);</div><div class="line">    int nevents;</div><div class="line">    while (s_stop) &#123;</div><div class="line">        printf(&quot;new loop...\n&quot;);</div><div class="line">        // 等待监听事件的发生</div><div class="line">        nevents = kevent(kq, change_list, 2, event_list, 2, NULL);</div><div class="line">        if (nevents &lt; 0) &#123;</div><div class="line">            printf(&quot;kevent error.\n&quot;);  // 监听出错</div><div class="line">        &#125; else if (nevents &gt; 0) &#123;</div><div class="line">            printf(&quot;get events number: %d\n&quot;, nevents);</div><div class="line">            for (int i = 0; i &lt; nevents; ++i) &#123;</div><div class="line">                printf(&quot;loop index: %d\n&quot;, i);</div><div class="line">                struct kevent event = event_list[i]; //监听事件的event数据结构</div><div class="line">                int clientfd = (int) event.ident;  // 监听描述符</div><div class="line">                // 表示该监听描述符出错</div><div class="line">                if (event.flags &amp; EV_ERROR) &#123;</div><div class="line">                    close(clientfd);</div><div class="line">                    printf(&quot;EV_ERROR: %s\n&quot;, strerror(event_list[i].data));</div><div class="line">                &#125;</div><div class="line">                // 表示sock有新的连接</div><div class="line">                if (clientfd == sock) &#123;</div><div class="line">                    printf(&quot;new connection\n&quot;);</div><div class="line">                    struct sockaddr_in client_addr;</div><div class="line">                    socklen_t client_addr_len = sizeof(client_addr);</div><div class="line">                    int new_fd = accept(sock, (struct sockaddr *) &amp;client_addr, &amp;client_addr_len);</div><div class="line">                    char remote[INET_ADDRSTRLEN];</div><div class="line">                    printf(&quot;connected with ip: %s, port: %d\n&quot;,</div><div class="line">                           inet_ntop(AF_INET, &amp;client_addr.sin_addr, remote, INET_ADDRSTRLEN),</div><div class="line">                           ntohs(client_addr.sin_port));</div><div class="line">                &#125;</div><div class="line">                if (clientfd == fileno(stdin)) &#123;</div><div class="line">                    memset(buf, 0, BUF_SIZE);</div><div class="line">                    fgets(buf, BUF_SIZE, stdin);</div><div class="line">                    printf(&quot;data from stdin: %s\n&quot;, buf);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    close(sock);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://wiki.netbsd.org/tutorials/kqueue_tutorial/" target="_blank" rel="external">kqueue tutorial</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2016/08/29/快学Lua/" class="prev">PREV</a><a href="/2016/08/06/浅谈Raft/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>