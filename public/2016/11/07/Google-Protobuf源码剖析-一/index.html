<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Google Protobuf源码剖析(一) · Snow Memory | Andrew Liu</title><meta name="description" content="protobuf c++ google"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Google Protobuf源码剖析(一)</h1><div class="post-info">Nov 7, 2016</div><div class="post-content"><p>本博客采用创作共用版权协议, 要求署名、非商业用途和保持一致. 转载本博客文章必须也遵循<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">署名-非商业用途-保持一致</a>的创作共用协议.</p>
<blockquote>
<p>很久之前写过一篇<a href="http://andrewliu.in/2016/06/05/Google-protobuf-C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Google protobuf(C++) 学习笔记</a>. <code>google protobuf</code>被大量用于公司的RPC通信中作为序列化和序列化工具, 高于JSON和XML的性能值得拥有. 刚好最近有时间, 准备强读一发<code>google protobuf源码</code></p>
</blockquote>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>本文所有所有示例均基于官方示例<code>addressbook.proto</code>:</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package tutorial;</div><div class="line"></div><div class="line">message Person &#123;</div><div class="line">  required <span class="built_in">string</span> name = <span class="number">1</span>;</div><div class="line">  required int32 id = <span class="number">2</span>;</div><div class="line">  optional <span class="built_in">string</span> email = <span class="number">3</span>;</div><div class="line"></div><div class="line">  <span class="keyword">enum</span> PhoneType &#123;</div><div class="line">    MOBILE = <span class="number">0</span>;</div><div class="line">    HOME = <span class="number">1</span>;</div><div class="line">    WORK = <span class="number">2</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  message PhoneNumber &#123;</div><div class="line">    required <span class="built_in">string</span> number = <span class="number">1</span>;</div><div class="line">    optional PhoneType type = <span class="number">2</span> [<span class="keyword">default</span> = HOME];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  repeated PhoneNumber phone = <span class="number">4</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">message AddressBook &#123;</div><div class="line">  repeated Person person = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>required</code>字段初值是必须要提供的, 否则字段的便是未初始化的, 序列化的时候必须对<code>required</code>初始化</li>
<li><code>optional</code>字段如果未进行初始化，那么一个默认值将赋予该字段</li>
<li><code>repeated</code>字段可以理解为<code>数组</code>, </li>
</ul>
<blockquote>
<p>每个变量后的数字为标签, 用于标示了字段在二进制流中存放的位置</p>
</blockquote>
<p>运行<code>protoc -I=./ --cpp_out=./ ./addressbook.proto</code>通过<code>protoc</code>来生成 <code>.h和.cpp</code>文件.</p>
<p>那么<code>.h文件</code>中到底生成了什么呢?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"># Person类的基类为::google::protobuf::Message类</div><div class="line"><span class="keyword">class</span> Person : <span class="keyword">public</span> ::google::protobuf::Message</div><div class="line"></div><div class="line"><span class="meta"># enum类型的数据, 可以通过Person::MOBILE来访问</span></div><div class="line"><span class="keyword">typedef</span> Person_PhoneType PhoneType;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> PhoneType MOBILE =</div><div class="line">    Person_PhoneType_MOBILE;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> PhoneType HOME =</div><div class="line">    Person_PhoneType_HOME;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> PhoneType WORK =</div><div class="line">    Person_PhoneType_WORK;</div><div class="line">    </div><div class="line"><span class="meta"># required和optional的普通类型, 产生的函数族都是差不多的. 对于每个字段会生成一个has函数、clear清除函数、set函数、get函数</span></div><div class="line"><span class="comment">// required string name = 1;</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">has_name</span><span class="params">()</span> <span class="keyword">const</span></span>;  # <span class="function">has_xxx</span></div><div class="line"><span class="keyword">void</span> <span class="title">clear_name</span><span class="params">()</span>;  # clear_xxx</div><div class="line"><span class="keyword">const</span> ::<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_name</span><span class="params">(<span class="keyword">const</span> ::<span class="built_in">std</span>::<span class="built_in">string</span>&amp; value)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_name</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* value)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_name</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* value, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line">::<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>* <span class="title">mutable_name</span><span class="params">()</span></span>;</div><div class="line">::<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>* <span class="title">release_name</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_allocated_name</span><span class="params">(::<span class="built_in">std</span>::<span class="built_in">string</span>* name)</span></span>;</div><div class="line"></div><div class="line"><span class="meta"># repeated类型有些不同, 没有has_xxx函数族</span></div><div class="line"><span class="comment">// repeated .tutorial.Person.PhoneNumber phone = 4;</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">phone_size</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_phone</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">const</span> ::tutorial::<span class="function">Person_PhoneNumber&amp; <span class="title">phone</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">const</span></span>;</div><div class="line">::tutorial::<span class="function">Person_PhoneNumber* <span class="title">mutable_phone</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</div><div class="line">::tutorial::<span class="function">Person_PhoneNumber* <span class="title">add_phone</span><span class="params">()</span></span>;</div><div class="line">::google::protobuf::RepeatedPtrField&lt;::tutorial::Person_PhoneNumber &gt;*</div><div class="line">      mutable_phone();</div><div class="line"><span class="keyword">const</span> ::google::protobuf::RepeatedPtrField&lt; ::tutorial::Person_PhoneNumber &gt;&amp;</div><div class="line">      phone() <span class="keyword">const</span>;</div></pre></td></tr></table></figure>
<h2 id="Protobuf主要类"><a href="#Protobuf主要类" class="headerlink" title="Protobuf主要类"></a>Protobuf主要类</h2><ul>
<li><code>Message</code>类, 是一个抽象层, 记录了一个proto文件里的所有内容. <code>Message</code>继承自<code>MessageLite</code></li>
<li><code>MessageLite</code>类, 是一个轻量级的接口协议, 这个接口由所有协议的消息对象来实现, 这个类中包含大量定义的虚函数和纯虚函数. 使用<code>MessageLite</code>来生成代码, 需要在.proto中加入下面这行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">option optimize_for = LITE_RUNTIME;</div></pre></td></tr></table></figure>
<ul>
<li><code>Arena</code>类主要用于协议消息的内存分配和释放, 并且分配内存是线程安全的.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 内存块的链表组织结构</span></div><div class="line">  <span class="comment">// Blocks are variable length malloc-ed objects.  The following structure</span></div><div class="line">  <span class="comment">// describes the common header for all blocks.</span></div><div class="line">  <span class="keyword">struct</span> Block &#123;</div><div class="line">    <span class="keyword">void</span>* owner;   <span class="comment">// &amp;ThreadCache of thread that owns this block, or</span></div><div class="line">                   <span class="comment">// &amp;this-&gt;owner if not yet owned by a thread.</span></div><div class="line">    Block* next;   <span class="comment">// Next block in arena (may have different owner)</span></div><div class="line">    <span class="comment">// ((char*) &amp;block) + pos is next available byte. It is always</span></div><div class="line">    <span class="comment">// aligned at a multiple of 8 bytes.</span></div><div class="line">    <span class="keyword">size_t</span> pos;</div><div class="line">    <span class="keyword">size_t</span> size;  <span class="comment">// total size of the block.</span></div><div class="line">    <span class="function">GOOGLE_ATTRIBUTE_ALWAYS_INLINE size_t <span class="title">avail</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size - pos; &#125;</div><div class="line">    <span class="comment">// data follows</span></div><div class="line">  &#125;;</div><div class="line"></div><div class="line"><span class="comment">// Arena核心的初始化函数</span></div><div class="line"><span class="keyword">void</span> Arena::Init() &#123;</div><div class="line">  lifecycle_id_ = lifecycle_id_generator_.GetNext();</div><div class="line">  blocks_ = <span class="number">0</span>;</div><div class="line">  hint_ = <span class="number">0</span>;</div><div class="line">  owns_first_block_ = <span class="literal">true</span>;</div><div class="line">  cleanup_list_ = <span class="number">0</span>;</div><div class="line">  <span class="comment">// options为构造函数的参数, 一个配置结构体ArenaOptions</span></div><div class="line">  <span class="keyword">if</span> (options_.initial_block != <span class="literal">NULL</span> &amp;&amp; options_.initial_block_size &gt; <span class="number">0</span>) &#123;</div><div class="line">    GOOGLE_CHECK_GE(options_.initial_block_size, <span class="keyword">sizeof</span>(Block))</div><div class="line">        &lt;&lt; <span class="string">": Initial block size too small for header."</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Add first unowned block to list.</span></div><div class="line">    Block* first_block = <span class="keyword">reinterpret_cast</span>&lt;Block*&gt;(options_.initial_block);</div><div class="line">    first_block-&gt;size = options_.initial_block_size;</div><div class="line">    first_block-&gt;pos = kHeaderSize;</div><div class="line">    first_block-&gt;next = <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">// Thread which calls Init() owns the first block. This allows the</span></div><div class="line">    <span class="comment">// single-threaded case to allocate on the first block without taking any</span></div><div class="line">    <span class="comment">// locks.</span></div><div class="line">    first_block-&gt;owner = &amp;thread_cache();</div><div class="line">    SetThreadCacheBlock(first_block);</div><div class="line">    AddBlockInternal(first_block);</div><div class="line">    owns_first_block_ = <span class="literal">false</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>Reflection</code>类, 是一个用于动态访问和修改协议消息各种变量域的类(也就是我们常说的反射机制), 该类只在Message中实现(<code>MessageLite中没有</code>)</li>
<li><code>Descriptor</code>类, 用于描述协议消息,通过<code>Message::GetDescriptor()</code>来获取Message对应的</li>
</ul>
<p>待续…</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/11/15/Linux内核设计与实现读书笔记/" class="prev">PREV</a><a href="/2016/10/29/某度实习总结/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>