<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 设计模式之策略模式与观察者模式 · Snow Memory | Andrew Liu</title><meta name="description" content="设计模式之策略模式与观察者模式 - Andrew Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">设计模式之策略模式与观察者模式</h1><div class="post-info">Jul 19, 2015</div><div class="post-content"><blockquote>
<p>在读设计模式, 做了简单的笔记, 并没有深入设计模式总结. </p>
</blockquote>
<p>#interface</p>
<p>首先, 温习一下Java中的接口技术(interface), 接口主要用于描述类具体有什么功能, 但并不给出每个功能的具体实现(<code>类似与iOS编程中的协议的概念</code>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>如果类遵从特定的接口, 那就必须实现具体的业务逻辑(<code>类似于iOS编程中, 作为delegate就必须具体实现协议定义</code>)</p>
</blockquote>
<ul>
<li>接口所有方法自动属于<code>public</code></li>
<li>接口不能含有实例域, 但可以包含<code>常量</code>,  不能在接口中实现方法(<code>可以看做没有实例域的抽象类</code>)</li>
<li>实现接口时需要声明为<code>public</code></li>
<li>不能用<code>new</code>实例化一个接口, 但能声明接口的变量</li>
<li>一个类只能使用一个抽象类(Java不支持多继承), 却可以使用<code>多个接口</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//某个类要实现一个接口</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CompareTo</span><span class="params">(Student s)</span> </span>&#123;</div><div class="line">    <span class="comment">//具体实现</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#设计原则</p>
<blockquote>
<p>设计告诉我们如何组织类和对象以解决某种问题</p>
</blockquote>
<ul>
<li>找出应用需要变化之处, 把它们独立出来, 不要和那些不需要变化的代码混在一起</li>
<li>针对接口编程 而不是针对实现编程</li>
<li>多用组合, 少用继承</li>
</ul>
<p>#策略模式(Strategy Pattern)</p>
<blockquote>
<p>策略模式定义了算法族, 分别封装起来, 让它们之间可以互相替换, 此模式让算法的变化独立于使用算法的客户</p>
</blockquote>
<ul>
<li>策略模式的核心是<code>动态绑定</code></li>
<li>策略模式将不断变化的部分封装为一个<code>接口</code>,  可以不同变化进行接口的具体实现</li>
<li>在使用到变化的类中增加一个声明一个接口的变量(注意是接口, 不是接口的一些具体实现, 这里用到动态绑定)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">//抽象类, 用于被其他子类继承, 重写其中的方法</div><div class="line">public abstract class Duck &#123;</div><div class="line">    //生成两个接口的实例变量</div><div class="line">    FlyBehavior flyBehavior;</div><div class="line">    QuackBehavior quackBehavior;</div><div class="line">    //初始化方法</div><div class="line">    public Duck() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    //接口变量的set方法</div><div class="line">    public void setFlyBehavior(FlyBehavior fb) &#123;</div><div class="line">        flyBehavior = fb;</div><div class="line">    &#125;</div><div class="line">    public void setQuackBehavior(QuackBehavior qb) &#123;</div><div class="line">        quackBehavior = qb;</div><div class="line">    &#125;</div><div class="line">    public abstract void display();</div><div class="line">    public void performFly() &#123;</div><div class="line">        flyBehavior.fly();  //执行动态绑定的地方</div><div class="line">    &#125;</div><div class="line">    public void performQuack() &#123;</div><div class="line">        quackBehavior.quack();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void swim() &#123;</div><div class="line">        System.out.println(&quot;All ducks float, even decoys!&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">//定义一个接口</div><div class="line">public interface FlyBehavior &#123;</div><div class="line">    public void fly(); //接口中的方法并不进行具体实现</div><div class="line">&#125;</div><div class="line">//类对接口的具体实现</div><div class="line">public class FlyNoWay implements FlyBehavior &#123;</div><div class="line">    public void fly() &#123;</div><div class="line">        System.out.println(&quot;I can&apos;t fly!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class FlyWithWings implements FlyBehavior &#123;</div><div class="line">    //实现接口的具体类</div><div class="line">    public void fly() &#123;</div><div class="line">        System.out.println(&quot;I&apos;m flying !&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//定义另一个接口</div><div class="line">public interface QuackBehavior &#123;</div><div class="line">    public void quack(); //接口中的方法并不具体实现</div><div class="line">&#125;</div><div class="line">//类实现具体的接口</div><div class="line">public class MuteQuack implements QuackBehavior &#123;</div><div class="line">    public void quack() &#123;</div><div class="line">        System.out.println(&quot;&lt;&lt;MuteQuack!&gt;&gt;&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class Quack implements QuackBehavior &#123;</div><div class="line">    public void quack() &#123;</div><div class="line">        System.out.println(&quot;Quack!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class Squeak implements QuackBehavior &#123;</div><div class="line">    public void quack() &#123;</div><div class="line">        System.out.println(&quot;Squeak!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过抽象类, 得到一个真正的子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class MallardDuck extends Duck &#123;</div><div class="line">    public MallardDuck() &#123;</div><div class="line">        //分别给两个接口变量, 赋值需要的类实例</div><div class="line">        quackBehavior = new Quack();</div><div class="line">        flyBehavior = new FlyWithWings();</div><div class="line">    &#125;</div><div class="line">    public void display() &#123;</div><div class="line">        System.out.println(&quot;I&apos;m a real Mallard duck!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//测试类</div><div class="line">public class MiniDuckSimulator &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        //调用MallardDuck类中的构造方法进行接口变量的初始化</div><div class="line">        Duck mallard = new MallardDuck();  //获得一个类实例</div><div class="line">        /*</div><div class="line">            此处类实例赋值给Duck变量, 直到运行时才知道Duck中</div><div class="line">            具体的对象类型, 得到MallarDuck类, 然后运行下面两个已</div><div class="line">            经在MallardDuck中赋值的两个接口类的实例</div><div class="line">        */</div><div class="line">        mallard.performFly();  //真正执行的是FlyWithWings类中中fly方法</div><div class="line">        mallard.performQuack();  //真正执行的是Quack类中的quack方法</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#观察者概念</p>
<blockquote>
<p>主题 + 观察者 = 观察者模式</p>
</blockquote>
<p>主题对象管理某些数据, 当主题内的数据改变, 就会通知观察者, 观察者已经向主题注册, 这样观察者在每次主题数据改变时都能收到更新</p>
<blockquote>
<p><strong>观察者模式</strong>定义了对象之间的一对多依赖(一个主题, 多个观察者), 当一个对象改变状态, 他的所有依赖者都会收到通知并更新</p>
</blockquote>
<p>#观察者模式(Observer Pattern)</p>
<p>首先定义主题, 观察者, 观察者抽象行为接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public interface Subject &#123;</div><div class="line">    //观察者向主题注册</div><div class="line">    public void registerObserver(Observer o);</div><div class="line">    //移除观察者</div><div class="line">    public void removeObserver(Observer o);</div><div class="line">    //通知所有观察者</div><div class="line">    public void notifyObservers();</div><div class="line">&#125;</div><div class="line">public interface Observer &#123;</div><div class="line">    //主题进行调用, 通知观察者数据以更新</div><div class="line">    public void update(float temp, float humidity, float pressure);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface DisplayElement &#123;</div><div class="line">    //每个观察者对于数据变化的反应不同, 可以抽象出来一个接口</div><div class="line">    public void display();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>定义实现主题接口的类(作为主题)</li>
<li>定义实现观察者接口的类(作为观察者)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">public class WeatherData implements  Subject &#123;</div><div class="line">    //WeatherData作为主题, 实现Subject的接口</div><div class="line">    private ArrayList observers;  //记录观察者</div><div class="line">    private float temperature;</div><div class="line">    private float humidity;</div><div class="line">    private float pressure;</div><div class="line"></div><div class="line">    public WeatherData() &#123;</div><div class="line">        observers = new ArrayList();  //初始化</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void registerObserver(Observer o) &#123;</div><div class="line">        observers.add(o);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void removeObserver(Observer o) &#123;</div><div class="line">        int i = observers.indexOf(o);</div><div class="line">        if (i &gt; 0) &#123;</div><div class="line">            observers.remove(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void notifyObservers() &#123;</div><div class="line">        for (int i = 0; i &lt; observers.size(); i++) &#123;</div><div class="line">            Observer observer = (Observer)observers.get(i);</div><div class="line">            observer.update(temperature, humidity, pressure);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //数据发生更新时此方法会被调用, 通知所有的观察者数据已更新</div><div class="line">    public void measurementsChanged() &#123;</div><div class="line">        notifyObservers();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //数据更新</div><div class="line">    public void setMeasurements(float temperature, float humidity, float pressure) &#123;</div><div class="line">        this.temperature = temperature;</div><div class="line">        this.humidity = humidity;</div><div class="line">        this.pressure = pressure;</div><div class="line">        measurementsChanged();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//作为观察者实现了观察者接口, 同时实现display接口</div><div class="line">public class CurrentConditiondDisplay implements Observer, DisplayElement &#123;</div><div class="line">    private float temperature;</div><div class="line">    private float humidity;</div><div class="line">    private Subject weatherData;</div><div class="line"></div><div class="line">    public CurrentConditiondDisplay(Subject weatherData) &#123;</div><div class="line">        this.weatherData = weatherData;  //获取主题对象, 保留Subject的引用</div><div class="line">        weatherData.registerObserver(this);  //将观察者注册到主题中</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //实现Observer的update接口</div><div class="line">    @Override</div><div class="line">    public void update(float temp, float humidity, float pressure) &#123;</div><div class="line">        this.temperature = temp;</div><div class="line">        this.humidity = humidity;</div><div class="line">        display();</div><div class="line">    &#125;</div><div class="line">    //实现DisplayElement的接口</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void display() &#123;</div><div class="line">        System.out.println(&quot;Current condition: &quot; + temperature</div><div class="line">         + &quot;F degresss and &quot; + humidity + &quot;% humidity&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>测试类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class WeatherStation &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        WeatherData weatherData = new WeatherData();</div><div class="line">        //初始化观察者, 并传入主题的引用</div><div class="line">        CurrentConditiondDisplay currentDisplay = new CurrentConditiondDisplay(weatherData);</div><div class="line">        //观察者数据变化, 会调用measurementsChanged()方法, 然后会调用notifyObservers()通知所有已注册的观察者</div><div class="line">        weatherData.setMeasurements(80, 65, 30.4f);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Java本身自带一套观察者模式, 其中Observable相当于Subject, 不过Observable是一个<code>类</code>, 而不是接口, Observer是一个观察者接口</p>
</blockquote>
<p>分析认为: iOS中按钮的点击事件使用了观察者模式, 按钮被点击后, 通知所有观察者, 合适的观察者对按钮点击事件进行处理</p>
<p>#参考连接</p>
<ul>
<li><a href="http://www.cnblogs.com/yhlx/articles/2177756.html" target="_blank" rel="external">Java中的抽象函数与C++中的虚函数</a></li>
<li><code>Head First Design Pattern</code></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2015/07/26/设计模式之装饰者模式与工厂模式/" class="prev">PREV</a><a href="/2015/07/12/Tmux入门指南/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>