<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Python爬虫(五)--多线程 · Snow Memory | Andrew Liu</title><meta name="description" content="Python爬虫(五)--多线程 - Andrew Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Python爬虫(五)--多线程</h1><div class="post-info">Dec 14, 2014</div><div class="post-content"><hr>
<h2 id="1-thread模块"><a href="#1-thread模块" class="headerlink" title="#1. thread模块"></a>#1. thread模块</h2><ul>
<li>python是支持多线程的, 主要是通过thread和threading这两个模块来实现的。</li>
<li>python的thread模块是比较底层的模块(或者说轻量级)，python的threading模块是对thread做了一些包装的，可以更加方便的被使用。</li>
</ul>
<p>简要的看一下thread模块中含函数和常量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> thread</div><div class="line"></div><div class="line">thread.LockType  <span class="comment">#锁对象的一种, 用于线程的同步</span></div><div class="line">thread.error  <span class="comment">#线程的异常</span></div><div class="line"></div><div class="line">thread.start_new_thread(function, args[, kwargs])  <span class="comment">#创建一个新的线程</span></div><div class="line">function : 线程执行函数</div><div class="line">args : 线程执行函数的参数, 类似为tuple,</div><div class="line">kwargs : 是一个字典</div><div class="line">返回值: 返回线程的标识符</div><div class="line"></div><div class="line">thread.exit()  <span class="comment">#线程退出函数</span></div><div class="line">thread.allocate_lock()  <span class="comment">#生成一个未锁状态的锁对象</span></div><div class="line">返回值: 返回一个锁对象</div></pre></td></tr></table></figure>
<p><code>锁对象</code>的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">lock.acquire([waitflag]) <span class="comment">#获取锁</span></div><div class="line">无参数时, 无条件获取锁, 无法获取时, 会被阻塞, 知道可以锁被释放</div><div class="line">有参数时, waitflag = <span class="number">0</span> 时,表示只有在不需要等待的情况下才获取锁, 非零情况与上面相同</div><div class="line">返回值 :　获得锁成功返回<span class="keyword">True</span>, 获得锁失败返回<span class="keyword">False</span></div><div class="line"></div><div class="line">lock.release() <span class="comment">#释放锁</span></div><div class="line"></div><div class="line">lock.locked() <span class="comment">#获取当前锁的状态</span></div><div class="line">返回值 : 如果锁已经被某个线程获取,返回<span class="keyword">True</span>, 否则为<span class="keyword">False</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>#1.1. thread多线程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> thread</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_time</span><span class="params">(thread_name, delay)</span> :</span></div><div class="line">    count = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> count &lt; <span class="number">5</span> :</div><div class="line">        time.sleep(delay)</div><div class="line">        count += <span class="number">1</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"%s : %s"</span> % (thread_name, time.ctime(time.time()))</div><div class="line"></div><div class="line"><span class="keyword">try</span> :</div><div class="line">    thread.start_new_thread(print_time, (<span class="string">"Thread-1"</span>, <span class="number">2</span>, ))</div><div class="line">    thread.start_new_thread(print_time, (<span class="string">"Thread-2"</span>, <span class="number">4</span>, ))</div><div class="line"><span class="keyword">except</span> : </div><div class="line">    <span class="keyword">print</span> <span class="string">"Error: unable to start the thread"</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span> :</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<h2 id="2-threading模块"><a href="#2-threading模块" class="headerlink" title="#2. threading模块"></a>#2. threading模块</h2><blockquote>
<p>python的threading模块是对thread做了一些包装的，可以更加方便的被使用。经常和<a href="https://docs.python.org/2/library/queue.html" target="_blank" rel="external">Queue</a>结合使用,Queue模块中提供了同步的、线程安全的队列类，包括<code>FIFO（先入先出)队列Queue</code>，<code>LIFO（后入先出）队列LifoQueue</code>，和<code>优先级队列PriorityQueue</code>。这些队列都实现了<code>锁原语</code>，能够在多线程中直接使用。可以使用队列来实现线程间的同步</p>
</blockquote>
<p>##2.1. 常用函数和对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#函数</span></div><div class="line">threading.active_count()  <span class="comment">#返回当前线程对象Thread的个数</span></div><div class="line">threading.enumerate()  <span class="comment">#返回当前运行的线程对象Thread(包括后台的)的list</span></div><div class="line">threading.Condition()  <span class="comment">#返回条件变量对象的工厂函数, 主要用户线程的并发</span></div><div class="line">threading.current_thread()  <span class="comment">#返回当前的线程对象Thread, 文档后面解释没看懂</span></div><div class="line">threading.Lock()  <span class="comment">#返回一个新的锁对象, 是在thread模块的基础上实现的 与acquire()和release()结合使用</span></div><div class="line"></div><div class="line"><span class="comment">#类</span></div><div class="line">threading.Thread  <span class="comment">#一个表示线程控制的类, 这个类常被继承</span></div><div class="line">thraeding.Timer  <span class="comment">#定时器,线程在一定时间后执行</span></div><div class="line">threading.ThreadError  <span class="comment">#引发中各种线程相关异常</span></div></pre></td></tr></table></figure>
<p>###2.1.1. Thread对象</p>
<blockquote>
<p>一般来说，使用线程有两种模式, 一种是创建线程要执行的函数, 把这个函数传递进Thread对象里，让它来执行. 另一种是直接从Thread继承，创建一个新的class，把线程执行的代码放到这个新的class里</p>
</blockquote>
<p>常用两种方式运行线程(线程中包含name属性) :</p>
<ul>
<li>在构造函数中传入用于线程运行的函数(这种方式更加灵活)</li>
<li>在子类中重写threading.Thread基类中run()方法(<code>只重写__init__()和run()方法</code>)</li>
</ul>
<p>创建线程对象后, 通过调用start()函数运行线程,  然后会自动调用<code>run()</code>方法.</p>
<blockquote>
<p>　通过设置｀daemon｀属性, 可以将线程设置为守护线程</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">threading.Thread(group = <span class="keyword">None</span>, target = <span class="keyword">None</span>, name = <span class="keyword">None</span>, args = () kwars = &#123;&#125;)</div><div class="line">group : 应该为<span class="keyword">None</span></div><div class="line">target : 可以传入一个函数用于run()方法调用,</div><div class="line">name : 线程名 默认使用<span class="string">"Thread-N"</span></div><div class="line">args : 元组, 表示传入target函数的参数</div><div class="line">kwargs : 字典, 传入target函数中关键字参数</div><div class="line"></div><div class="line">属性:</div><div class="line">name  <span class="comment">#线程表示, 没有任何语义</span></div><div class="line">doemon  <span class="comment">#布尔值, 如果是守护线程为True, 不是为False, 主线程不是守护线程, 默认threading.Thread.damon = False</span></div><div class="line"></div><div class="line">类方法: </div><div class="line">run()  <span class="comment">#用以表示线程活动的方法。</span></div><div class="line">start()  <span class="comment">#启动线程活动。</span></div><div class="line">join([time])  <span class="comment">#等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</span></div><div class="line">isAlive(): 返回线程是否活动的。</div><div class="line">getName(): 返回线程名。</div><div class="line">setName(): 设置线程名。</div></pre></td></tr></table></figure>
<p>范例: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_thread</span><span class="params">(count)</span> :</span></div><div class="line">    <span class="keyword">while</span> count &gt; <span class="number">0</span> :</div><div class="line">        <span class="keyword">print</span> <span class="string">"count = %d"</span> % count</div><div class="line">        count = count - <span class="number">1</span></div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> :</span></div><div class="line">    my_thread = threading.Thread(target = test_thread, args = (<span class="number">10</span>, ))</div><div class="line">    my_thread.start()</div><div class="line">    my_thread.join()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>##2.2. 常用多线程写法</p>
<ul>
<li>固定线程运行的函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> threading, thread</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="string">"""docstring for MyThread"""</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, thread_id, name, counter)</span> :</span></div><div class="line">        super(MyThread, self).__init__()  <span class="comment">#调用父类的构造函数 </span></div><div class="line">        self.thread_id = thread_id</div><div class="line">        self.name = name</div><div class="line">        self.counter = counter</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> :</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"Starting "</span> + self.name</div><div class="line">        print_time(self.name, self.counter, <span class="number">5</span>)</div><div class="line">        <span class="keyword">print</span> <span class="string">"Exiting "</span> + self.name</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_time</span><span class="params">(thread_name, delay, counter)</span> :</span></div><div class="line">    <span class="keyword">while</span> counter :</div><div class="line">        time.sleep(delay)</div><div class="line">        <span class="keyword">print</span> <span class="string">"%s %s"</span> % (thread_name, time.ctime(time.time()))</div><div class="line">        counter -= <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment">#创建新的线程</span></div><div class="line">    thread1 = MyThread(<span class="number">1</span>, <span class="string">"Thread-1"</span>, <span class="number">1</span>)</div><div class="line">    thread2 = MyThread(<span class="number">2</span>, <span class="string">"Thread-2"</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line">    <span class="comment">#开启线程</span></div><div class="line">    thread1.start()</div><div class="line">    thread2.start()</div><div class="line"></div><div class="line"></div><div class="line">    thread1.join()</div><div class="line">    thread2.join()</div><div class="line">    <span class="keyword">print</span> <span class="string">"Exiting Main Thread"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<ul>
<li>外部传入线程运行的函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    属性:</div><div class="line">    target: 传入外部函数, 用户线程调用</div><div class="line">    args: 函数参数</div><div class="line">    """</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, target, args)</span>:</span></div><div class="line">        super(MyThread, self).__init__()  <span class="comment">#调用父类的构造函数 </span></div><div class="line">        self.target = target</div><div class="line">        self.args = args</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> :</span></div><div class="line">        self.target(self.args)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_time</span><span class="params">(counter)</span> :</span></div><div class="line">    <span class="keyword">while</span> counter :</div><div class="line">        <span class="keyword">print</span> <span class="string">"counter = %d"</span> % counter</div><div class="line">        counter -= <span class="number">1</span></div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> :</span></div><div class="line">    my_thread = MyThread(print_time, <span class="number">10</span>)</div><div class="line">    my_thread.start()</div><div class="line">    my_thread.join()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>##2.3. 生产者消费者问题</p>
<blockquote>
<p>试着用python写了一个生产者消费者问题(伪生产者消费者), 只是使用简单的锁, 感觉有点不太对, 下面另一个程序会写出正确的生产者消费者问题</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> thread, threading</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"><span class="keyword">import</span> time, random</div><div class="line"><span class="keyword">import</span> Queue</div><div class="line"></div><div class="line">share_queue = Queue.Queue()  <span class="comment">#共享队列</span></div><div class="line">my_lock = thread.allocate_lock()</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span> :</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> :</span></div><div class="line">        products = range(<span class="number">5</span>)</div><div class="line">        <span class="keyword">global</span> share_queue</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span> :</div><div class="line">            num = random.choice(products)</div><div class="line">            my_lock.acquire()</div><div class="line">            share_queue.put(num)</div><div class="line">            <span class="keyword">print</span>  <span class="string">"Produce : "</span>, num</div><div class="line">            my_lock.release()</div><div class="line">            time.sleep(random.random())</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span> :</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> :</span></div><div class="line">        <span class="keyword">global</span> share_queue</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            my_lock.acquire()</div><div class="line">            <span class="keyword">if</span> share_queue.empty() : <span class="comment">#这里没有使用信号量机制进行阻塞等待, </span></div><div class="line">                <span class="keyword">print</span> <span class="string">"Queue is Empty..."</span>  </div><div class="line">                my_lock.release()</div><div class="line">                time.sleep(random.random())</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            num = share_queue.get()</div><div class="line">            <span class="keyword">print</span> <span class="string">"Consumer : "</span>, num</div><div class="line">            my_lock.release()</div><div class="line">            time.sleep(random.random())</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> :</span></div><div class="line">    producer = Producer()</div><div class="line">    consumer = Consumer()</div><div class="line">    producer.start()</div><div class="line">    consumer.start()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>杀死多线程程序方法: 使用<code>control + z</code>挂起程序(程序依然在后台, 可以使用<code>ps aux</code>查看), 获得程序的进程号, 然后使用<code>kill -9 进程号</code>杀死进程</p>
<blockquote>
<p>参考一篇帖子解决了上述问题,重写了生产者消费者问题程序, 参考链接惯例放在最后.</p>
</blockquote>
<p>使用了wait()和notify()解决</p>
<blockquote>
<p>当然最简答的方法是直接使用<code>Queue</code>,Queue封装了Condition的行为, 如wait(), notify(), acquire(), 没看文档就这样, 使用了Queue竟然不知道封装了这些函数, 继续滚去看文档了</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> random, time, Queue</div><div class="line"></div><div class="line">MAX_SIZE = <span class="number">5</span></div><div class="line">SHARE_Q = []  <span class="comment">#模拟共享队列</span></div><div class="line">CONDITION = threading.Condition()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span> :</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> :</span></div><div class="line">        products = range(<span class="number">5</span>)</div><div class="line">        <span class="keyword">global</span> SHARE_Q</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span> :</div><div class="line">            CONDITION.acquire()</div><div class="line">            <span class="keyword">if</span> len(SHARE_Q) == <span class="number">5</span> :</div><div class="line">                <span class="keyword">print</span> <span class="string">"Queue is full.."</span></div><div class="line">                CONDITION.wait()</div><div class="line">                <span class="keyword">print</span> <span class="string">"Consumer have comsumed something"</span></div><div class="line">            product = random.choice(products)</div><div class="line">            SHARE_Q.append(product)</div><div class="line">            <span class="keyword">print</span> <span class="string">"Producer : "</span>, product</div><div class="line">            CONDITION.notify()</div><div class="line">            CONDITION.release()</div><div class="line">            time.sleep(random.random())</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span> :</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> :</span></div><div class="line">        <span class="keyword">global</span> SHARE_Q</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            CONDITION.acquire()</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> SHARE_Q :</div><div class="line">                <span class="keyword">print</span> <span class="string">"Queue is Empty..."</span></div><div class="line">                CONDITION.wait()</div><div class="line">                <span class="keyword">print</span> <span class="string">"Producer have producted something"</span></div><div class="line">            product = SHARE_Q.pop(<span class="number">0</span>)</div><div class="line">            <span class="keyword">print</span> <span class="string">"Consumer :"</span>, product</div><div class="line">            CONDITION.notify()</div><div class="line">            CONDITION.release()</div><div class="line">            time.sleep(random.random())</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> :</span></div><div class="line">    producer = Producer()</div><div class="line">    consumer = Consumer()</div><div class="line">    producer.start()</div><div class="line">    consumer.start()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>##2.4.简单锁</p>
<blockquote>
<p>如果只是简单的加锁解锁可以直接使用threading.Lock()生成锁对象, 然后使用acquire()和release()方法</p>
</blockquote>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*- </span></div><div class="line"></div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span> :</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, thread_id, name, counter)</span> :</span></div><div class="line">        threading.Thread.__init__(self)</div><div class="line">        self.thread_id = thread_id</div><div class="line">        self.name = name</div><div class="line">        self.counter = counter</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> :</span></div><div class="line">        <span class="comment">#重写run方法, 添加线程执行逻辑, start函数运行会自动执行</span></div><div class="line">        <span class="keyword">print</span>  <span class="string">"Starting "</span> + self.name</div><div class="line">        threadLock.acquire() <span class="comment">#获取所</span></div><div class="line">        print_time(self.name, self.counter, <span class="number">3</span>)</div><div class="line">        threadLock.release() <span class="comment">#释放锁</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_time</span><span class="params">(thread_name, delay, counter)</span> :</span></div><div class="line">    <span class="keyword">while</span> counter :</div><div class="line">        time.sleep(delay)</div><div class="line">        <span class="keyword">print</span> <span class="string">"%s %s"</span> % (thread_name, time.ctime(time.time()))</div><div class="line">        counter -= <span class="number">1</span></div><div class="line"></div><div class="line">threadLock = threading.Lock()</div><div class="line">threads = [] <span class="comment">#存放线程对象</span></div><div class="line"></div><div class="line">thread1 = MyThread(<span class="number">1</span>, <span class="string">"Thread-1"</span>, <span class="number">1</span>)</div><div class="line">thread2 = MyThread(<span class="number">2</span>, <span class="string">"Thread-2"</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">#开启线程</span></div><div class="line">thread1.start()</div><div class="line">thread2.start()</div><div class="line"></div><div class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads :</div><div class="line">    t.join()  <span class="comment">#等待线程直到终止</span></div><div class="line"><span class="keyword">print</span> <span class="string">"Exiting Main Thread"</span></div></pre></td></tr></table></figure>
<p>##2.5. Condition</p>
<blockquote>
<p>如果是向生产者消费者类似的情形, 使用Condition类 或者直接使用<code>Queue</code>模块</p>
</blockquote>
<p><strong>Condition</strong></p>
<p>条件变量中有<code>acquire()和release方法用来调用锁的方法</code>, 有<code>wait(), notify(), notifyAll()方法</code>, 后面是三个方法必须在获取锁的情况下调用, 否则产生<code>RuntimeError</code>错误.</p>
<ul>
<li>当一个线程获得锁后, 发现没有期望的资源或者状态, 就会调用wait()阻塞, 并释放已经获得锁, 知道期望的资源或者状态发生改变</li>
<li>当一个线程获得锁, 改变了资源或者状态, 就会调用notify()和notifyAll()去通知其他线程, </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#官方文档中提供的生产者消费者模型</span></div><div class="line"><span class="comment"># Consume one item</span></div><div class="line">cv.acquire()</div><div class="line"><span class="keyword">while</span> <span class="keyword">not</span> an_item_is_available():</div><div class="line">    cv.wait()</div><div class="line">get_an_available_item()</div><div class="line">cv.release()</div><div class="line"></div><div class="line"><span class="comment"># Produce one item</span></div><div class="line">cv.acquire()</div><div class="line">make_an_item_available()</div><div class="line">cv.notify()</div><div class="line">cv.release()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#threading.Condition类</div><div class="line">thread.Condition([lock])</div><div class="line">可选参数lock: 必须是Lock或者RLock对象, 并被作为underlying锁(悲观锁?), 否则, 会创建一个新的RLock对象作为underlying锁</div><div class="line"></div><div class="line">类方法:</div><div class="line">acquire()  #获得锁</div><div class="line">release()  #释放锁</div><div class="line">wait([timeout])  #持续等待直到被notify()或者notifyAll()通知或者超时(必须先获得锁),</div><div class="line">#wait()所做操作, 先释放获得的锁, 然后阻塞, 知道被notify或者notifyAll唤醒或者超时, 一旦被唤醒或者超时, 会重新获取锁(应该说抢锁), 然后返回</div><div class="line">notify()  #唤醒一个wait()阻塞的线程.</div><div class="line">notify_all()或者notifyAll()  #唤醒所有阻塞的线程</div></pre></td></tr></table></figure>
<blockquote>
<p><code>参考程序可以查看上面的生产者消费者程序</code></p>
</blockquote>
<h2 id="3-参考链接"><a href="#3-参考链接" class="headerlink" title="#3. 参考链接"></a>#3. 参考链接</h2><ul>
<li><a href="http://blog.jobbole.com/52412/" target="_blank" rel="external">Python中的生产者消费者问题</a></li>
<li><a href="http://www.w3cschool.cc/python/python-multithreading.html" target="_blank" rel="external">Python多线程</a></li>
<li><a href="https://docs.python.org/2/library/threading.html" target="_blank" rel="external">threading官方文档</a></li>
<li><a href="https://docs.python.org/2/library/thread.html#module-thread" target="_blank" rel="external">thread官方文档</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2014/12/14/Python爬虫-三-Coursera抓站小结/" class="prev">PREV</a><a href="/2014/12/11/手把手教你写Sublime中的Snippet/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>