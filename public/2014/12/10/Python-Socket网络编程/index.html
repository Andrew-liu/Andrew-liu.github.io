<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Python爬虫(四)--Socket网络编程 · Snow Memory | Andrew Liu</title><meta name="description" content="Python爬虫(四)--Socket网络编程 - Andrew Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Python爬虫(四)--Socket网络编程</h1><div class="post-info">Dec 10, 2014</div><div class="post-content"><hr>
<p>python的网络变成比c语言简单许多, 封装许多底层的实现细节, 方便程序员使用的同时, 也使程序员比较难了解一些底层的东西, 我觉得学<code>网络编程</code>还是用c语言更好一点.</p>
<blockquote>
<p>写这篇博文, 也希望回顾并整理一下以前学过的c语言和linux下一些东西, 会将一些Linux网络编程的函数和Python网络变成函数做一个简单的对照, 方便记忆</p>
</blockquote>
<h2 id="1-Socket套接字的概念"><a href="#1-Socket套接字的概念" class="headerlink" title="#1. Socket套接字的概念"></a>#1. Socket套接字的概念</h2><p><code>Socket(翻译为套接字, 我觉得很挫)</code>,是操作系统内核中的一个数据结构，它是<code>网络中的节点进行相互通信的门户</code>。它是网络进程的ID。网络通信，归根到底还是进程间的通信（不同计算机上的进程间通信, 又称进程间通信, IP协议进行的主要是端到端通信）。在网络中，每一个节点（计算机或路由）都有一个网络地址，也就是IP地址。两个进程通信时，首先要确定各自所在的网络节点的网络地址。但是，网络地址只能确定进程所在的计算机，而一台计算机上很可能同时运行着多个进程，所以仅凭网络地址还不能确定到底是和网络中的哪一个进程进行通信，因此套接口中还需要包括其他的信息，也就是端口号（PORT）。在一台计算机中，一个端口号一次只能分配给一个进程，也就是说，在一台计算机中，端口号和进程之间是一一对应关系。<br>所以，使用端口号和网络地址的组合可以唯一的确定整个网络中的一个网络进程. </p>
<a id="more"></a>
<blockquote>
<p>端口号的范围从0~65535，一类是由互联网指派名字和号码公司ICANN负责分配给一些常用的应用程序固定使用的“周知的端口”，其值一般为0~1023, 用户自定义端口号一般大于等于1024, 我比较喜欢用8888</p>
</blockquote>
<p>每一个socket都用一个半相关描述{协议、本地地址、本地端口}来表示；一个完整的套接字则用一个相关描述{协议、本地地址、本地端口、远程地址、远程端口}来表示。socket也有一个类似于打开文件的函数调用，该函数返回一个整型的socket描述符，随后的连接建立、数据传输等操作都是通过socket来实现的</p>
<p>##1.1. Socket类型</p>
<blockquote>
<p>socket类型在Liunx和Python是一样的, 只是Python中的类型都定义在<code>socket模块</code>中, 调用方式<code>socket.SOCK_XXXX</code></p>
</blockquote>
<ul>
<li>流式socket（SOCK_STREAM） <code>用于TCP通信</code></li>
</ul>
<blockquote>
<p>流式套接字提供可靠的、面向连接的通信流；它使用TCP协议，从而保证了数据传输的正确性和顺序性</p>
</blockquote>
<ul>
<li>数据报socket（SOCK_DGRAM）    <code>用于UDP通信</code></li>
</ul>
<blockquote>
<p>数据报套接字定义了一种无连接的服务，数据通过相互独立的报文进行传输，是无序的，并且不保证是可靠、无差错的。它使用数据报协议UDP</p>
</blockquote>
<ul>
<li>原始socket（SOCK_RAW）    <code>用于新的网络协议实现的测试等</code></li>
</ul>
<blockquote>
<p>原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以, 其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。</p>
</blockquote>
<h2 id="2-Socket编程"><a href="#2-Socket编程" class="headerlink" title="#2. Socket编程"></a>#2. Socket编程</h2><p>##2.1. TCP通信</p>
<p>TCP通信的基本步骤如下：<br>服务端：socket—bind—listen—while(True){—accept—recv—send—-}—close<br>客户端：socket———————————-connect—send—recv——-close</p>
<p><img src="http://picturebag.qiniudn.com/48.png" alt="TCP"></p>
<p><strong>socket函数</strong><br>使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Linux</span></div><div class="line">int socket(int domain, int type, int protocol);</div><div class="line">domain：AF_INET：Ipv4网络协议 AF_INET6：IPv6网络协议</div><div class="line">type : tcp：SOCK_STREAM   udp：SOCK_DGRAM</div><div class="line">protocol : 指定socket所使用的传输协议编号。通常为<span class="number">0.</span></div><div class="line">返回值：成功则返回套接口描述符，失败返回<span class="number">-1</span>。</div><div class="line"></div><div class="line"><span class="comment">#python</span></div><div class="line">socket.socket([family[, type[, proto]]])</div><div class="line">family : AF_INET (默认ipv4), AF_INET6(ipv6) <span class="keyword">or</span> AF_UNIX(Unix系统进程间通信). </div><div class="line">type : SOCK_STREAM (TCP), SOCK_DGRAM(UDP) . </div><div class="line">protocol : 一般为<span class="number">0</span>或者默认</div><div class="line"></div><div class="line">如果socket创建失败会抛出一个socket.error异常</div></pre></td></tr></table></figure>
<p>###2.1.1. 服务器端函数</p>
<p><strong>bind函数</strong><br>将套接字绑定到地址, python下,以元组（host,port）的形式表示地址, Linux下使用<code>sockaddr_in</code>结构体指针</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Linux</span></div><div class="line">int bind(int sockfd, struct sockaddr * my_addr, int addrlen);</div><div class="line">sockfd : 前面socket()的返回值</div><div class="line">my_addr : 结构体指针变量</div><div class="line"><span class="comment">#####</span></div><div class="line">struct sockaddr_in  //常用的结构体</div><div class="line">&#123;</div><div class="line">unsigned short int sin_family;  //即为sa_family AF_INET</div><div class="line">uint16_t sin_port;  //为使用的port编号</div><div class="line">struct in_addr sin_addr;  //为IP地址</div><div class="line">unsigned char sin_zero[<span class="number">8</span>];  //未使用</div><div class="line">&#125;;</div><div class="line">struct in_addr</div><div class="line">&#123;</div><div class="line">uint32_t s_addr;</div><div class="line">&#125;;</div><div class="line"><span class="comment">####</span></div><div class="line">addrlen : sockaddr的结构体长度。通常是计算sizeof(struct sockaddr);</div><div class="line">返回值：成功则返回<span class="number">0</span>，失败返回<span class="number">-1</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#python</span></div><div class="line">s.bind(address)</div><div class="line">s为socket.socket()返回的套接字对象</div><div class="line">address为元组（host,port）</div><div class="line">host: ip地址, 为一个字符串</div><div class="line">post: 自定义主机号, 为整型</div></pre></td></tr></table></figure>
<p><strong>listen函数</strong><br>使服务器的这个端口和IP处于监听状态，等待网络中某一客户机的连接请求。如果客户端有连接请求，端口就会接受这个连接</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Linux</span></div><div class="line">int listen(int sockfd,int backlog);</div><div class="line">sockfd : 为前面socket的返回值.</div><div class="line">backlog : 指定同时能处理的最大连接要求，通常为<span class="number">10</span>或者<span class="number">5</span>。最大值可设至<span class="number">128</span></div><div class="line">返回值：成功则返回<span class="number">0</span>，失败返回<span class="number">-1</span></div><div class="line"></div><div class="line"><span class="comment">#python</span></div><div class="line">s.listen(backlog)</div><div class="line">s为socket.socket()返回的套接字对象</div><div class="line">backlog : 操作系统可以挂起的最大连接数量。该值至少为<span class="number">1</span>，大部分应用程序设为<span class="number">5</span>就可以了</div></pre></td></tr></table></figure>
<p><strong>accept函数</strong><br>接受远程计算机的连接请求，建立起与客户机之间的通信连接。服务器处于监听状态时，如果某时刻获得客户机的连接请求，此时并不是立即处理这个请求，而是将这个请求放在等待队列中，当系统空闲时再处理客户机的连接请求。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Linux</span></div><div class="line">int accept(int s,struct sockaddr * addr,int * addrlen);</div><div class="line">sockfd : 为前面socket的返回值.</div><div class="line">addr : 为结构体指针变量，和bind的结构体是同种类型的，系统会把远程主机的信息（远程主机的地址和端口号信息）保存到这个指针所指的结构体中。</div><div class="line">addrlen : 表示结构体的长度，为整型指针 </div><div class="line">返回值：成功则返回新的socket处理代码new_fd，失败返回<span class="number">-1</span></div><div class="line"></div><div class="line"><span class="comment">#python</span></div><div class="line">s.accept()</div><div class="line">s为socket.socket()返回的套接字对象</div><div class="line">返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址</div></pre></td></tr></table></figure>
<p>###2.1.2. 客户端函数</p>
<p><strong>connect函数</strong><br>用来请求连接远程服务器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Linux</span></div><div class="line">int connect (int sockfd,struct sockaddr * serv_addr,int addrlen);</div><div class="line">sockfd : 为前面socket的返回值.</div><div class="line">serv_addr : 为结构体指针变量，存储着远程服务器的IP与端口号信息</div><div class="line">addrlen : 表示结构体变量的长度</div><div class="line">返回值：成功则返回<span class="number">0</span>，失败返回<span class="number">-1</span></div><div class="line"></div><div class="line"><span class="comment">#python</span></div><div class="line">s.connect(address)</div><div class="line">s为socket.socket()返回的套接字对象</div><div class="line">address : 格式为元组（hostname,port），如果连接出错，返回socket.error错误</div></pre></td></tr></table></figure>
<p>###2.1.3. 通用函数<br>接收远端主机传来的数据</p>
<p><strong>recv函数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Linux</span></div><div class="line">int recv(int sockfd,void *buf,int len,unsigned int flags);</div><div class="line">sockfd : 为前面accept的返回值.也就是新的套接字。</div><div class="line">buf : 表示缓冲区</div><div class="line">len : 表示缓冲区的长度</div><div class="line">flags : 通常为<span class="number">0</span></div><div class="line">返回值：成功则返回实际接收到的字符数，可能会少于你所指定的接收长度。失败返回<span class="number">-1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#python</span></div><div class="line">s.recv(bufsize[,flag])</div><div class="line">s为socket.socket()返回的套接字对象</div><div class="line">bufsize : 指定要接收的数据大小</div><div class="line">flag : 提供有关消息的其他信息，通常可以忽略</div><div class="line">返回值为数据以字符串形式</div></pre></td></tr></table></figure>
<p><strong>send函数</strong><br>发送数据给指定的远端主机</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Linux</span></div><div class="line">int send(int s,const void * msg,int len,unsigned int flags);</div><div class="line">sockfd : 为前面socket的返回值.</div><div class="line">msg : 一般为常量字符串</div><div class="line">len : 表示长度</div><div class="line">flags : 通常为<span class="number">0</span></div><div class="line">返回值：成功则返回实际传送出去的字符数，可能会少于你所指定的发送长度。失败返回<span class="number">-1</span></div><div class="line"></div><div class="line"><span class="comment">#python</span></div><div class="line">s.send(string[,flag])</div><div class="line">s为socket.socket()返回的套接字对象</div><div class="line">string : 要发送的字符串数据 </div><div class="line">flag : 提供有关消息的其他信息，通常可以忽略</div><div class="line">返回值是要发送的字节数量，该数量可能小于string的字节大小。</div><div class="line">s.sendall(string[,flag])</div><div class="line"><span class="comment">#完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。</span></div><div class="line">返回值 : 成功返回<span class="keyword">None</span>，失败则抛出异常。</div></pre></td></tr></table></figure>
<p><strong>close函数</strong><br>关闭套接字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Linux</span></div><div class="line">int close(int fd);</div><div class="line">fd : 为前面的sockfd</div><div class="line">返回值：若文件顺利关闭则返回<span class="number">0</span>，发生错误时返回<span class="number">-1</span></div><div class="line"></div><div class="line"><span class="comment">#python</span></div><div class="line">s.close()</div><div class="line">s为socket.socket()返回的套接字对象</div></pre></td></tr></table></figure>
<p>##2.2. 简单的客户端服务器TCP连接</p>
<blockquote>
<p>一个简单的回显服务器和客户端模型, 客户端发出的数据, 服务器会回显到客户端的终端上(只是一个简单的模型, 没考虑错误处理等问题)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#服务器端</span></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> socket   <span class="comment">#socket模块</span></div><div class="line"><span class="keyword">import</span> commands   <span class="comment">#执行系统命令模块</span></div><div class="line"></div><div class="line"></div><div class="line">BUF_SIZE = <span class="number">1024</span>  <span class="comment">#设置缓冲区大小</span></div><div class="line">server_addr = (<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>)  <span class="comment">#IP和端口构成表示地址</span></div><div class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <span class="comment">#生成一个新的socket对象</span></div><div class="line">server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)  <span class="comment">#设置地址复用</span></div><div class="line">server.bind(server_addr)  <span class="comment">#绑定地址</span></div><div class="line">server.listen(<span class="number">5</span>)  <span class="comment">#监听, 最大监听数为5</span></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    client, client_addr = server.accept()  <span class="comment">#接收TCP连接, 并返回新的套接字和地址</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'Connected by'</span>, client_addr</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span> :</div><div class="line">        data = client.recv(BUF_SIZE)  <span class="comment">#从客户端接收数据</span></div><div class="line">        <span class="keyword">print</span> data</div><div class="line">        client.sendall(data)  <span class="comment">#发送数据到客户端</span></div><div class="line">server.close()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#客户端</span></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> socket</div><div class="line"></div><div class="line">BUF_SIZE = <span class="number">1024</span>  <span class="comment">#设置缓冲区的大小</span></div><div class="line">server_addr = (<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>)  <span class="comment">#IP和端口构成表示地址</span></div><div class="line">client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <span class="comment">#返回新的socket对象</span></div><div class="line">client.connect(server_addr)  <span class="comment">#要连接的服务器地址</span></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    data = raw_input(<span class="string">"Please input some string &gt; "</span>)  </div><div class="line">    client.sendall(data)  <span class="comment">#发送数据到服务器</span></div><div class="line">    data = client.recv(BUF_SIZE)  <span class="comment">#从服务器端接收数据</span></div><div class="line">    <span class="keyword">print</span> data</div><div class="line">client.close()</div></pre></td></tr></table></figure>
<p>###2.2.1. 带错误处理的客户端服务器TCP连接</p>
<blockquote>
<p>在进行网络编程时, 最好使用大量的错误处理, 能够尽量的发现错误, 也能够使代码显得更加严谨</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#服务器端</span></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> socket   <span class="comment">#socket模块</span></div><div class="line"></div><div class="line">BUF_SIZE = <span class="number">1024</span>  <span class="comment">#设置缓冲区大小</span></div><div class="line">server_addr = (<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>)  <span class="comment">#IP和端口构成表示地址</span></div><div class="line"><span class="keyword">try</span> :</div><div class="line">  server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <span class="comment">#生成一个新的socket对象</span></div><div class="line"><span class="keyword">except</span> socket.error, msg :</div><div class="line">    <span class="keyword">print</span> <span class="string">"Creating Socket Failure. Error Code : "</span> + str(msg[<span class="number">0</span>]) + <span class="string">" Message : "</span> + msg[<span class="number">1</span>]</div><div class="line">    sys.exit()</div><div class="line"><span class="keyword">print</span> <span class="string">"Socket Created!"</span></div><div class="line">server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)  <span class="comment">#设置地址复用</span></div><div class="line"><span class="keyword">try</span> : </div><div class="line">    server.bind(server_addr)  <span class="comment">#绑定地址</span></div><div class="line"><span class="keyword">except</span> socket.error, msg :</div><div class="line">  <span class="keyword">print</span> <span class="string">"Binding Failure. Error Code : "</span> + str(msg[<span class="number">0</span>]) + <span class="string">" Message : "</span> + msg[<span class="number">1</span>]</div><div class="line">  sys.exit()</div><div class="line"><span class="keyword">print</span> <span class="string">"Socket Bind!"</span></div><div class="line">server.listen(<span class="number">5</span>)  <span class="comment">#监听, 最大监听数为5</span></div><div class="line"><span class="keyword">print</span> <span class="string">"Socket listening"</span></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    client, client_addr = server.accept()  <span class="comment">#接收TCP连接, 并返回新的套接字和地址, 阻塞函数</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'Connected by'</span>, client_addr</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span> :</div><div class="line">        data = client.recv(BUF_SIZE)  <span class="comment">#从客户端接收数据</span></div><div class="line">        <span class="keyword">print</span> data</div><div class="line">        client.sendall(data)  <span class="comment">#发送数据到客户端</span></div><div class="line">server.close()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#客户端</span></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> socket</div><div class="line"></div><div class="line"></div><div class="line">BUF_SIZE = <span class="number">1024</span>  <span class="comment">#设置缓冲区的大小</span></div><div class="line">server_addr = (<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>)  <span class="comment">#IP和端口构成表示地址</span></div><div class="line"><span class="keyword">try</span> : </div><div class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <span class="comment">#返回新的socket对象</span></div><div class="line"><span class="keyword">except</span> socket.error, msg :</div><div class="line">    <span class="keyword">print</span> <span class="string">"Creating Socket Failure. Error Code : "</span> + str(msg[<span class="number">0</span>]) + <span class="string">" Message : "</span> + msg[<span class="number">1</span>]</div><div class="line">    sys.exit()</div><div class="line">client.connect(server_addr)  <span class="comment">#要连接的服务器地址</span></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    data = raw_input(<span class="string">"Please input some string &gt; "</span>)  </div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data :</div><div class="line">        <span class="keyword">print</span> <span class="string">"input can't empty, Please input again.."</span></div><div class="line">        <span class="keyword">continue</span></div><div class="line">    client.sendall(data)  <span class="comment">#发送数据到服务器</span></div><div class="line">    data = client.recv(BUF_SIZE)  <span class="comment">#从服务器端接收数据</span></div><div class="line">    <span class="keyword">print</span> data</div><div class="line">client.close()</div></pre></td></tr></table></figure>
<p>##2.3. UDP通信</p>
<p>UDP通信流程图如下：<br>服务端：socket—bind—recvfrom—sendto—close<br>客户端：socket———-sendto—recvfrom—close</p>
<p><img src="http://picturebag.qiniudn.com/49.png" alt="UDP"></p>
<p><strong>sendto()函数</strong><br>发送UDP数据, 将数据发送到套接字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Linux</span></div><div class="line">int sendto(int sockfd, const void *msg,int len,unsigned int flags,const struct sockaddr *to, int tolen);</div><div class="line">sockfd : 为前面socket的返回值.</div><div class="line">msg : 一般为常量字符串</div><div class="line">len : 表示长度</div><div class="line">flags : 通常为<span class="number">0</span></div><div class="line">to : 表示目地机的IP地址和端口号信息, 表示地址的结构体</div><div class="line">tolen : 常常被赋值为sizeof (struct sockaddr)</div><div class="line">返回值 :　返回实际发送的数据字节长度或在出现发送错误时返回<span class="number">-1</span>。</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#Python</span></div><div class="line">s.sendto(string[,flag],address)</div><div class="line">s为socket.socket()返回的套接字对象</div><div class="line">address : 指定远程地址, 形式为（ipaddr，port）的元组</div><div class="line">flag : 提供有关消息的其他信息，通常可以忽略</div><div class="line">返回值 : 发送的字节数。</div></pre></td></tr></table></figure>
<p><strong>recvfrom()函数</strong><br>接受UDP套接字的数据, 与recv()类似</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Linux</span></div><div class="line">int recvfrom(int sockfd,void *buf,int len,unsigned int flags,struct sockaddr *<span class="keyword">from</span>,int *fromlen);</div><div class="line">sockfd : 为前面socket的返回值.</div><div class="line">msg : 一般为常量字符串</div><div class="line">len : 表示长度</div><div class="line">flags : 通常为<span class="number">0</span></div><div class="line"><span class="keyword">from</span> :是一个struct sockaddr类型的变量，该变量保存连接机的IP地址及端口号</div><div class="line">fromlen : 常置为sizeof (struct sockaddr)。</div><div class="line">返回值 : 返回接收到的字节数或当出现错误时返回<span class="number">-1</span>，并置相应的errno。</div><div class="line"></div><div class="line"><span class="comment">#Python</span></div><div class="line">s.recvfrom(bufsize[.flag])</div><div class="line">返回值 : （data,address）元组, 其中data是包含接收数据的字符串，address是发送数据的套接字地址</div><div class="line">bufsize : 指定要接收的数据大小</div><div class="line">flag : 提供有关消息的其他信息，通常可以忽略</div></pre></td></tr></table></figure>
<p>##2.4. 简单的客户端服务器UDP连接</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#服务器端</span></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> socket</div><div class="line"></div><div class="line">BUF_SIZE = <span class="number">1024</span>  <span class="comment">#设置缓冲区大小</span></div><div class="line">server_addr = (<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>)  <span class="comment">#IP和端口构成表示地址</span></div><div class="line">server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  <span class="comment">#生成新的套接字对象</span></div><div class="line">server.bind(server_addr)  <span class="comment">#套接字绑定IP和端口</span></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span> :</div><div class="line">    <span class="keyword">print</span> <span class="string">"waitting for data"</span></div><div class="line">    data, client_addr = server.recvfrom(BUF_SIZE)  <span class="comment">#从客户端接收数据</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'Connected by'</span>, client_addr, <span class="string">' Receive Data : '</span>, data</div><div class="line">    server.sendto(data, client_addr)  <span class="comment">#发送数据给客户端</span></div><div class="line">server.close()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#客户端</span></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> socket</div><div class="line"><span class="keyword">import</span> struct</div><div class="line"></div><div class="line">BUF_SIZE = <span class="number">1024</span>  <span class="comment">#设置缓冲区</span></div><div class="line">server_addr = (<span class="string">'127.0.0.1'</span>, <span class="number">8888</span>)  <span class="comment">#IP和端口构成表示地址</span></div><div class="line">client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  <span class="comment">#生成新的套接字对象</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span> :</div><div class="line">    data = raw_input(<span class="string">'Please Input data &gt; '</span>)</div><div class="line">    client.sendto(data, server_addr)  <span class="comment">#向服务器发送数据</span></div><div class="line">    data, addr = client.recvfrom(BUF_SIZE)  <span class="comment">#从服务器接收数据</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"Data : "</span>, data</div><div class="line">client.close()</div></pre></td></tr></table></figure>
<p>##2.5. 其他</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">s.getpeername()</div><div class="line">#返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</div><div class="line"></div><div class="line">s.getsockname()</div><div class="line">#返回套接字自己的地址。通常是一个元组(ipaddr,port)</div><div class="line"></div><div class="line">s.setsockopt(level,optname,value)</div><div class="line">#设置给定套接字选项的值。</div><div class="line"></div><div class="line">s.getsockopt(level,optname[.buflen])</div><div class="line">#返回套接字选项的值。</div><div class="line"></div><div class="line">s.settimeout(timeout)</div><div class="line">#设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）</div><div class="line"></div><div class="line">s.gettimeout()</div><div class="line">#返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。</div><div class="line"></div><div class="line">s.fileno()</div><div class="line">#返回套接字的文件描述符。</div><div class="line"></div><div class="line">s.setblocking(flag)</div><div class="line">#如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。</div><div class="line"></div><div class="line">s.makefile()</div><div class="line">#创建一个与该套接字相关连的文件</div></pre></td></tr></table></figure>
<h2 id="3-参考链接"><a href="#3-参考链接" class="headerlink" title="#3. 参考链接"></a>#3. 参考链接</h2><p><a href="https://docs.python.org/2/library/socket.html" target="_blank" rel="external">python-socket官方文档</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/12/11/手把手教你写Sublime中的Snippet/" class="prev">PREV</a><a href="/2014/12/08/Virtualenv简明教程/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>