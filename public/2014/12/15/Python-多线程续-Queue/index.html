<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Python爬虫(六)--多线程续(Queue) · Snow Memory | Andrew Liu</title><meta name="description" content="Python爬虫(六)--多线程续(Queue) - Andrew Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Python爬虫(六)--多线程续(Queue)</h1><div class="post-info">Dec 15, 2014</div><div class="post-content"><hr>
<p>本文希望达到的目标:</p>
<ol>
<li>学习Queue模块</li>
<li>将Queue模块与多线程编程相结合</li>
<li>通过Queue和threading模块, 重构爬虫, 实现多线程爬虫, </li>
<li>通过以上学习希望总结出一个通用的多线程爬虫小模版</li>
</ol>
<h2 id="1-Queue模块"><a href="#1-Queue模块" class="headerlink" title="#1. Queue模块"></a>#1. Queue模块</h2><p><code>Queue</code>模块实现了多生产者多消费者队列, 尤其适合多线程编程.<code>Queue</code>类中<code>实现了所有需要的锁原语</code>(这句话非常重要), Queue模块实现了三种类型队列:</p>
<ul>
<li>FIFO(先进先出)队列, 第一加入队列的任务, 被第一个取出</li>
<li>LIFO(后进先出)队列,最后加入队列的任务, 被第一个取出(操作类似与栈, 总是从栈顶取出, 这个队列还不清楚内部的实现)</li>
<li>PriorityQueue(优先级)队列, 保持队列数据有序, 最小值被先取出(在C++中我记得优先级队列是可以自己重写排序规则的, Python不知道可以吗)</li>
</ul>
<a id="more"></a>
<p>##1.1. 类和异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Queue</div><div class="line"></div><div class="line"><span class="comment">#类</span></div><div class="line">Queue.Queue(maxsize = <span class="number">0</span>)  <span class="comment">#构造一个FIFO队列,maxsize设置队列大小的上界, 如果插入数据时, 达到上界会发生阻塞, 直到队列可以放入数据. 当maxsize小于或者等于0, 表示不限制队列的大小(默认)</span></div><div class="line"></div><div class="line">Queue.LifoQueue(maxsize = <span class="number">0</span>)  <span class="comment">#构造一LIFO队列,maxsize设置队列大小的上界, 如果插入数据时, 达到上界会发生阻塞, 直到队列可以放入数据. 当maxsize小于或者等于0, 表示不限制队列的大小(默认)</span></div><div class="line"></div><div class="line">Queue.PriorityQueue(maxsize = <span class="number">0</span>)  <span class="comment">#构造一个优先级队列,,maxsize设置队列大小的上界, 如果插入数据时, 达到上界会发生阻塞, 直到队列可以放入数据. 当maxsize小于或者等于0, 表示不限制队列的大小(默认). 优先级队列中, 最小值被最先取出</span></div><div class="line"></div><div class="line"><span class="comment">#异常</span></div><div class="line">Queue.Empty  <span class="comment">#当调用非阻塞的get()获取空队列的元素时, 引发异常</span></div><div class="line">Queue.Full  <span class="comment">#当调用非阻塞的put()向满队列中添加元素时, 引发异常</span></div></pre></td></tr></table></figure>
<p>##1.2. Queue对象</p>
<p>三种队列对象<code>提供公共的方法</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Queue.empty()  #如果队列为空, 返回True(注意队列为空时, 并不能保证调用put()不会阻塞); 队列不空返回False(不空时, 不能保证调用get()不会阻塞)</div><div class="line">Queue.full()  #如果队列为满, 返回True(不能保证调用get()不会阻塞), 如果队列不满, 返回False(并不能保证调用put()不会阻塞)</div><div class="line"></div><div class="line">Queue.put(item[, block[, timeout]])  #向队列中放入元素, 如果可选参数block为True并且timeout参数为None(默认), 为阻塞型put(). 如果timeout是正数, 会阻塞timeout时间并引发Queue.Full异常. 如果block为False为非阻塞put</div><div class="line">Queue.put_nowait(item)  #等价于put(itme, False)</div><div class="line"></div><div class="line">Queue.get([block[, timeout]])  #移除列队元素并将元素返回, block = True为阻塞函数, block = False为非阻塞函数. 可能返回Queue.Empty异常</div><div class="line">Queue.get_nowait()  #等价于get(False)</div><div class="line"></div><div class="line">Queue.task_done()  #在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号</div><div class="line">Queue.join()  #实际上意味着等到队列为空，再执行别的操作</div></pre></td></tr></table></figure>
<p>下面是官方文档给多出的多线程模型(官方文档果然是个好东西):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        item = q.get()</div><div class="line">        do_work(item)</div><div class="line">        q.task_done()</div><div class="line"></div><div class="line">q = Queue()</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num_worker_threads):</div><div class="line">     t = Thread(target=worker)</div><div class="line">     t.daemon = <span class="keyword">True</span></div><div class="line">     t.start()</div><div class="line"></div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> source():</div><div class="line">    q.put(item)</div><div class="line"></div><div class="line">q.join()       <span class="comment"># block until all tasks are done</span></div></pre></td></tr></table></figure>
<h2 id="2-Queue模块与线程相结合"><a href="#2-Queue模块与线程相结合" class="headerlink" title="#2. Queue模块与线程相结合"></a>#2. Queue模块与线程相结合</h2><p>简单写了一个Queue和线程结合的小程序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> Queue</div><div class="line"></div><div class="line">SHARE_Q = Queue.Queue()  <span class="comment">#构造一个不限制大小的的队列</span></div><div class="line">_WORKER_THREAD_NUM = <span class="number">3</span>   <span class="comment">#设置线程个数</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span> :</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span> :</span></div><div class="line">        super(MyThread, self).__init__()</div><div class="line">        self.func = func</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> :</span></div><div class="line">        self.func()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span> :</span></div><div class="line">    <span class="keyword">global</span> SHARE_Q</div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> SHARE_Q.empty():</div><div class="line">        item = SHARE_Q.get() <span class="comment">#获得任务</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"Processing : "</span>, item</div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> :</span></div><div class="line">    <span class="keyword">global</span> SHARE_Q</div><div class="line">    threads = []</div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> xrange(<span class="number">5</span>) :  <span class="comment">#向队列中放入任务</span></div><div class="line">        SHARE_Q.put(task)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(_WORKER_THREAD_NUM) :</div><div class="line">        thread = MyThread(worker)</div><div class="line">        thread.start()</div><div class="line">        threads.append(thread)</div><div class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads :</div><div class="line">        thread.join()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<h2 id="3-重构爬虫"><a href="#3-重构爬虫" class="headerlink" title="#3. 重构爬虫"></a>#3. 重构爬虫</h2><p>主要针对之间写过的豆瓣爬虫进行重构:</p>
<ul>
<li><a href="http://andrewliu.tk/2014/12/05/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-%E4%BA%8C-%E8%B1%86%E7%93%A3%E6%8A%93%E7%AB%99%E5%B0%8F%E8%AE%A1/" target="_blank" rel="external">Python网络爬虫(二)–豆瓣抓站小计</a></li>
</ul>
<p>##3.1. 豆瓣电影爬虫重构</p>
<p>通过对Queue和线程模型进行改写, 可以写出下面的爬虫程序 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># -*- coding:utf-8 -*-</div><div class="line"># 多线程爬取豆瓣Top250的电影名称</div><div class="line"></div><div class="line">import urllib2, re, string</div><div class="line">import threading, Queue, time</div><div class="line">import sys</div><div class="line"></div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(&apos;utf8&apos;)</div><div class="line">_DATA = []</div><div class="line">FILE_LOCK = threading.Lock()</div><div class="line">SHARE_Q = Queue.Queue()  #构造一个不限制大小的的队列</div><div class="line">_WORKER_THREAD_NUM = 3  #设置线程的个数</div><div class="line"></div><div class="line">class MyThread(threading.Thread) :</div><div class="line"></div><div class="line">    def __init__(self, func) :</div><div class="line">        super(MyThread, self).__init__()  #调用父类的构造函数</div><div class="line">        self.func = func  #传入线程函数逻辑</div><div class="line"></div><div class="line">    def run(self) :</div><div class="line">        self.func()</div><div class="line"></div><div class="line">def worker() :</div><div class="line">    global SHARE_Q</div><div class="line">    while not SHARE_Q.empty():</div><div class="line">        url = SHARE_Q.get() #获得任务</div><div class="line">        my_page = get_page(url)  #爬取整个网页的HTML代码</div><div class="line">        find_title(my_page)  #获得当前页面的电影名</div><div class="line">        time.sleep(1)</div><div class="line">        SHARE_Q.task_done()</div></pre></td></tr></table></figure>
<p>完整代码请查看<a href="https://github.com/Andrew-liu/dou_ban_spider/blob/master/threading_douban.py" target="_blank" rel="external">Github豆瓣多线程爬虫</a><br>完成这个程序后, 又出现了新的问题:</p>
<blockquote>
<p>无法保证数据的顺序性, 因为线程是并发的, 思考的方法是: 设置一个主线程进行管理, 然后他们的线程工作</p>
</blockquote>
<h2 id="4-通用的多线程爬虫小模版"><a href="#4-通用的多线程爬虫小模版" class="headerlink" title="#4. 通用的多线程爬虫小模版"></a>#4. 通用的多线程爬虫小模版</h2><p>下面是根据上面的爬虫做了点小改动后形成的模板</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> Queue</div><div class="line"></div><div class="line">SHARE_Q = Queue.Queue()  <span class="comment">#构造一个不限制大小的的队列</span></div><div class="line">_WORKER_THREAD_NUM = <span class="number">3</span>  <span class="comment">#设置线程的个数</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span> :</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    </div><div class="line">    doc of class</div><div class="line">    </div><div class="line">    Attributess:</div><div class="line">        func: 线程函数逻辑</div><div class="line">    """</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span> :</span></div><div class="line">        super(MyThread, self).__init__()  <span class="comment">#调用父类的构造函数</span></div><div class="line">        self.func = func  <span class="comment">#传入线程函数逻辑</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> :</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        重写基类的run方法</div><div class="line">        </div><div class="line">        """</div><div class="line">        self.func()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_something</span><span class="params">(item)</span> :</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    运行逻辑, 比如抓站</div><div class="line">    """</div><div class="line">    <span class="keyword">print</span> item</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span> :</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    主要用来写工作逻辑, 只要队列不空持续处理</div><div class="line">    队列为空时, 检查队列, 由于Queue中已经包含了wait,</div><div class="line">    notify和锁, 所以不需要在取任务或者放任务的时候加锁解锁</div><div class="line">    """</div><div class="line">    <span class="keyword">global</span> SHARE_Q</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span> : </div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> SHARE_Q.empty():</div><div class="line">            item = SHARE_Q.get() <span class="comment">#获得任务</span></div><div class="line">            do_something(item)</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line">            SHARE_Q.task_done()</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> :</span></div><div class="line">    <span class="keyword">global</span> SHARE_Q</div><div class="line">    threads = []</div><div class="line">    <span class="comment">#向队列中放入任务, 真正使用时, 应该设置为可持续的放入任务</span></div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> xrange(<span class="number">5</span>) :   </div><div class="line">        SHARE_Q.put(task)</div><div class="line">    <span class="comment">#开启_WORKER_THREAD_NUM个线程</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(_WORKER_THREAD_NUM) :</div><div class="line">        thread = MyThread(worker)</div><div class="line">        thread.start()  <span class="comment">#线程开始处理任务</span></div><div class="line">        threads.append(thread)</div><div class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads :</div><div class="line">        thread.join()</div><div class="line">    <span class="comment">#等待所有任务完成</span></div><div class="line">    SHARE_Q.join()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<h2 id="5-思考更高效的爬虫方法"><a href="#5-思考更高效的爬虫方法" class="headerlink" title="#5. 思考更高效的爬虫方法"></a>#5. 思考更高效的爬虫方法</h2><ul>
<li>使用<a href="https://twistedmatrix.com/trac/wiki/Documentation" target="_blank" rel="external">twisted</a>进行异步IO抓取</li>
<li>使用<code>Scrapy</code>框架(Scrapy 使用了 Twisted 异步网络库来处理网络通讯)</li>
</ul>
<p><a href="http://krondo.com/blog/?page_id=1327" target="_blank" rel="external">http://krondo.com/blog/?page_id=1327</a><br><a href="http://turtlerbender007.appspot.com/twisted/index.html" target="_blank" rel="external">http://turtlerbender007.appspot.com/twisted/index.html</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/12/17/Python爬虫-四-Scrapy框架学习/" class="prev">PREV</a><a href="/2014/12/14/Python爬虫-三-Coursera抓站小结/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>