<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Python源码剖析读书笔记(二) · Snow Memory | Andrew Liu</title><meta name="description" content="Python源码剖析读书笔记(二) - Andrew Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Python源码剖析读书笔记(二)</h1><div class="post-info">Jan 16, 2015</div><div class="post-content"><blockquote>
<p>第二部分看完了, 但是字节码部分还是有很多不懂的地方, 这部分等以后有长进了在回来读一遍…</p>
</blockquote>
<h2 id="Python虚拟机"><a href="#Python虚拟机" class="headerlink" title="#Python虚拟机"></a>#Python虚拟机</h2><h2 id="1-Python的编译结果"><a href="#1-Python的编译结果" class="headerlink" title="#1. Python的编译结果"></a>#1. Python的编译结果</h2><blockquote>
<p>Code对象和pyc文件, Python执行原理<code>虚拟机, 字节码</code></p>
</blockquote>
<p>当输入命令<code>python my_program.py</code>时:</p>
<ol>
<li>python解释器被激活执行python程序</li>
<li>编译.py文件(生成字节码)</li>
<li>将编译结果交给虚拟机</li>
</ol>
<p>##1.1. PyCodeObject对象</p>
<blockquote>
<p>编译结果存在内存中的<code>PyCodeObject</code>对象中, python运行结束后, 编译结果又被保存到pyc文件中, 下一次运行相同程序,python会根据pyc文件中的编译结果直接建立内存中<code>PyCodeObject</code>对象, 不再对源文件编译</p>
</blockquote>
<a id="more"></a>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#code.h</div><div class="line">/* Bytecode object 字节码对象 */</div><div class="line">typedef struct &#123;</div><div class="line">    PyObject_HEAD</div><div class="line">    int co_argcount;        /* #arguments, except *args位置参数的个数 */</div><div class="line">    int co_nlocals;     /* #local variables 局部变量个数 */</div><div class="line">    int co_stacksize;       /* #entries needed for evaluation stack 执行code block需要的栈空间*/</div><div class="line">    int co_flags;       /* CO_..., see below */</div><div class="line">    PyObject *co_code;      /* instruction opcodes 字节码指令序列*/</div><div class="line">    PyObject *co_consts;    /* list (constants used) 所有常量*/</div><div class="line">    PyObject *co_names;     /* list of strings (names used) 所有符号*/</div><div class="line">    PyObject *co_varnames;  /* tuple of strings (local variable names) 局部变量名集合*/</div><div class="line">    PyObject *co_freevars;  /* tuple of strings (free variable names) 闭包需要的东西*/</div><div class="line">    PyObject *co_cellvars;      /* tuple of strings (cell variable names) 内部嵌套函数引用的局部变量名集合*/</div><div class="line">    /* The rest doesn't count for hash/cmp */</div><div class="line">    PyObject *co_filename;  /* string (where it was loaded from) .py的完整路径*/</div><div class="line">    PyObject *co_name;      /* string (name, for reference) 函数名或雷鸣*/</div><div class="line">    int co_firstlineno;     /* first source line number .py文件起始行*/</div><div class="line">    PyObject *co_lnotab;    /* string (encoding addr&lt;-&gt;lineno mapping) See</div><div class="line">                   Objects/lnotab_notes.txt for details.字节码与.py源码行号对应关系 */</div><div class="line">    void *co_zombieframe;     /* for optimization only (see frameobject.c) */</div><div class="line">    PyObject *co_weakreflist;   /* to support weakrefs to code objects */</div><div class="line">&#125; PyCodeObject;</div></pre></td></tr></table></figure>
<blockquote>
<p>代码中一个Code Block(对应一个名字空间)创建一个<code>PyCodeObject</code>对象(包含Code<br>Block编译后的byte code)</p>
</blockquote>
<p>名字空间: 符号的上下文(一个变量名对应的变量值是什么需要通过名字空间决定)</p>
<p>一般对于有import语句的程序, 例如import abc, 运行时会先到设定好的路径找abc.pyc或abc.dll, 如果没有会先将abc.py编译成响应的<code>PyCodeObject</code>对象, 然后创建abc.pyc并将中间结果写入文件, 接下来python才对abc.pyc进行import操作(<code>PyCodeObject</code>对象复制到内存)</p>
<p>##1.2. pyc文件的生成</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">#import.c</div><div class="line">#define MAGIC (62211 | ((long)'\r'&lt;&lt;16) | ((long)'\n'&lt;&lt;24))</div><div class="line">static void</div><div class="line">write_compiled_module(PyCodeObject *co, char *cpathname, struct stat *srcstat, time_t mtime)</div><div class="line">&#123;</div><div class="line">    FILE *fp;  #排他性的打开文件</div><div class="line">#ifdef MS_WINDOWS   /* since Windows uses different permissions  */</div><div class="line">    mode_t mode = srcstat-&gt;st_mode &amp; ~S_IEXEC;</div><div class="line">    /* Issue #6074: We ensure user write access, so we can delete it later</div><div class="line">     * when the source file changes. (On POSIX, this only requires write</div><div class="line">     * access to the directory, on Windows, we need write access to the file</div><div class="line">     * as well)</div><div class="line">     */</div><div class="line">    mode |= _S_IWRITE;</div><div class="line">#else</div><div class="line">    mode_t mode = srcstat-&gt;st_mode &amp; ~S_IXUSR &amp; ~S_IXGRP &amp; ~S_IXOTH;</div><div class="line">#endif</div><div class="line"></div><div class="line">    fp = open_exclusive(cpathname, mode);</div><div class="line">    if (fp == NULL) &#123;</div><div class="line">        if (Py_VerboseFlag)</div><div class="line">            PySys_WriteStderr(</div><div class="line">                "# can't create %s\n", cpathname);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    #写入python的magic number(保证兼容性)</div><div class="line">    PyMarshal_WriteLongToFile(pyc_magic, fp, Py_MARSHAL_VERSION);</div><div class="line">    /* First write a 0 for mtime */</div><div class="line">    PyMarshal_WriteLongToFile(0L, fp, Py_MARSHAL_VERSION);</div><div class="line">    #写入PyCodeObject对象</div><div class="line">    PyMarshal_WriteObjectToFile((PyObject *)co, fp, Py_MARSHAL_VERSION);</div><div class="line">    if (fflush(fp) != 0 || ferror(fp)) &#123;</div><div class="line">        if (Py_VerboseFlag)</div><div class="line">            PySys_WriteStderr("# can't write %s\n", cpathname);</div><div class="line">        /* Don't keep partial file */</div><div class="line">        fclose(fp);</div><div class="line">        (void) unlink(cpathname);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    /* Now write the true mtime (as a 32-bit field)写入时间 */</div><div class="line">    fseek(fp, 4L, 0);</div><div class="line">    assert(mtime &lt;= 0xFFFFFFFF);</div><div class="line">    PyMarshal_WriteLongToFile((long)mtime, fp, Py_MARSHAL_VERSION);</div><div class="line">    fflush(fp);</div><div class="line">    fclose(fp);</div><div class="line">    if (Py_VerboseFlag)</div><div class="line">        PySys_WriteStderr("# wrote %s\n", cpathname);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#marshal.c</div><div class="line">void</div><div class="line">PyMarshal_WriteObjectToFile(PyObject *x, FILE *fp, int version)</div><div class="line">&#123;</div><div class="line">    WFILE wf;</div><div class="line">    wf.fp = fp;</div><div class="line">    wf.error = WFERR_OK;</div><div class="line">    wf.depth = 0;</div><div class="line">    wf.strings = (version &gt; 0) ? PyDict_New() : NULL;</div><div class="line">    wf.version = version;</div><div class="line">    w_object(x, &amp;wf); #借用这个完成PyCodeObject对象写入pyc文件的操作</div><div class="line">    Py_XDECREF(wf.strings);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将PyCodeObject对象写入pyc文件会调用write_compiled_module函数, 这个函数又会调用PyMarshal_WriteLongToFile函数, PyMarshal_WriteLongToFile函数会调用w_object函数, w_object函数会对不同对象执行不同的写入文件操作(其中会写入对象类型), 其中*WFILE中strings在向pyc写入时会指向PyDictObject对象, 从pyc读出时调用PyMarshal_ReadLongToFile函数, strings会指向PyListObject</p>
<p>字符串对象写入pyc有三种情况:</p>
<ol>
<li>普通字符串, 写入类型, 长度和字符串</li>
<li>intern字符串写入先进行查找, 查找失败进行首次写入, 将(字符串, 序号)添加到strings中, 将类型和字符串本身写入pyc</li>
<li>查找成功进行非首次写入,仅仅将类型和查到的序号写入pyc中</li>
</ol>
<p>字符串从pyc读操作:</p>
<ol>
<li>读好TYPE_INTERN后, 字符串进行intern操作, 并将intern操作结果添加到strings指向的PyListObject中</li>
<li>当读到TYPE_STRINGREF, 后根据跟随的序号(写入pyc使生成的)访问strings, 从来获得进行了intern操作的字符串对象</li>
</ol>
<blockquote>
<p>pyc中的PyCodeObject对象是以一种嵌套的关系联系在一起, 意味着pyc文件中的二进制数据有结构, 则可以进行可视化</p>
</blockquote>
<h2 id="2-Python虚拟机架构"><a href="#2-Python虚拟机架构" class="headerlink" title="#2. Python虚拟机架构"></a>#2. Python虚拟机架构</h2><blockquote>
<p>python虚拟机模拟操作系统运行可执行文件的过程, 其中<code>PyCodeObject</code>没有包含程序<code>执行环境</code></p>
</blockquote>
<p>##2.1. PyFrameObject</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">#frameobject.h</div><div class="line">typedef struct _frame &#123;</div><div class="line">    PyObject_VAR_HEAD   #变长对象, 不同PyCodeObject, 栈空间大小不同</div><div class="line">    struct _frame *f_back;  /* previous frame, or NULL 执行环境链上的前一个frame*/</div><div class="line">    PyCodeObject *f_code;   /* code segment PyCodeObject对象*/</div><div class="line">    PyObject *f_builtins;   /* builtin symbol table (PyDictObject) buildin名字空间*/</div><div class="line">    PyObject *f_globals;    /* global symbol table (PyDictObject) global名字空间*/</div><div class="line">    PyObject *f_locals;     /* local symbol table (any mapping) local名字空间*/</div><div class="line">    PyObject **f_valuestack;    /* points after the last local 运行时栈的栈底位置*/</div><div class="line">    /* Next free slot in f_valuestack.  Frame creation sets to f_valuestack.</div><div class="line">       Frame evaluation usually NULLs it, but a frame that yields sets it</div><div class="line">       to the current stack top. */</div><div class="line">    PyObject **f_stacktop;  #运行时栈的栈底位置</div><div class="line">    PyObject *f_trace;      /* Trace function */</div><div class="line"></div><div class="line">    /* If an exception is raised in this frame, the next three are used to</div><div class="line">     * record the exception info (if any) originally in the thread state.  See</div><div class="line">     * comments before set_exc_info() -- it's not obvious.</div><div class="line">     * Invariant:  if _type is NULL, then so are _value and _traceback.</div><div class="line">     * Desired invariant:  all three are NULL, or all three are non-NULL.  That</div><div class="line">     * one isn't currently true, but "should be".</div><div class="line">     */</div><div class="line">    PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;</div><div class="line"></div><div class="line">    PyThreadState *f_tstate;</div><div class="line">    int f_lasti;        /* Last instruction if called 上一条字节码指令在f_code中的偏移位置*/</div><div class="line">    /* Call PyFrame_GetLineNumber() instead of reading this field</div><div class="line">       directly.  As of 2.3 f_lineno is only valid when tracing is</div><div class="line">       active (i.e. when f_trace is set).  At other times we use</div><div class="line">       PyCode_Addr2Line to calculate the line from the current</div><div class="line">       bytecode index. */</div><div class="line">    int f_lineno;       /* Current line number 当前字节码对应的源代码行*/</div><div class="line">    int f_iblock;       /* index in f_blockstack */</div><div class="line">    PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */</div><div class="line">    PyObject *f_localsplus[1];  /* locals+stack, dynamically sized 动态内存,维护(局部变量+cell对象集合+free对象集合+运行时栈)所需要的空间*/</div><div class="line">&#125; PyFrameObject;</div></pre></td></tr></table></figure>
<p>程序运行, 会生成PyFrameObject执行环境(栈帧)链, f_back指向前一个对象</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PyFrameObject *</div><div class="line">PyFrame_New(PyThreadState *tstate, PyCodeObject *code, PyObject *globals,</div><div class="line">            PyObject *locals)</div><div class="line">&#123;</div><div class="line">...</div><div class="line">extras = code-&gt;co_stacksize + code-&gt;co_nlocals + ncells +</div><div class="line">            nfrees; #四部分构成PyFrameObject动态内存区域</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##2.2. 名字/作用域和名字空间(重要)</p>
<p>python赋值语句的动作:</p>
<ol>
<li>创建一个对象</li>
<li>将对象赋给一个名字name(函数, 类定义和import等也赋值语句)</li>
</ol>
<p>一个约束在程序正文的某个位置是否起作用, 是由约束在文本中的位置是否唯一决定的, 不动态决定的, <code>所以Python具有静态作用域(编译时就知道名字空间)</code>, 程序作用域在python运行转化为<code>名字空间</code>, python支持嵌套作用域.</p>
<ul>
<li>Python最顶层作用域为builtin作用域</li>
<li>一个源文件对应一个global作用域</li>
<li>每个函数定义一个local作用域</li>
<li><code>LGB查找规则, 现在local作用域查找-&gt;再到global作用域查找-&gt;最后到python自身定义的builtin作用域查找</code></li>
<li><code>LE(enclosing直接外围作用域)GB</code>(闭包)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a = 1</div><div class="line">def test():</div><div class="line">    print a #1</div><div class="line">    a = 2 #2</div><div class="line">    print a</div><div class="line"></div><div class="line">test()</div><div class="line">#会输出错误:UnboundLocalError: local variable &apos;a&apos; referenced before assignment</div></pre></td></tr></table></figure>
<p>原因在注释1和注释2同在一个作用域, 所以在按照LEGB规则, 在local名字空间可以找到名字a, 但是a的赋值发生在注释1之后, 所以出现错误. <code>global关键字解决这种问题</code></p>
<p>##2.3. Python虚拟机的运行框架</p>
<p>python虚拟机的具体实现</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#ceval.c</span></div><div class="line">PyObject *</div><div class="line">PyEval_EvalFrameEx(PyFrameObject *f, int throwflag</div></pre></td></tr></table></figure>
<ul>
<li>Python进入PyEval_EvalFrameEx函数</li>
<li>通过for循环取出字节码,查看对应的参数(如果有的话)</li>
<li>结束字节码的执行</li>
<li>最后why指示退出for循环时python执行引擎的状态</li>
</ul>
<p>##2.4. Python运行时环境</p>
<ul>
<li>PyFrameObject对应可执行文件执行时的栈帧</li>
<li>进程(PyInterpreterState, 线程的活动环境)和线程(PyThreadState对象是线程状态信息的抽象)</li>
<li>其中线程同步通过全局解释锁(Global Interpreter Lock)实现</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#pystate.c</span></div><div class="line">typedef struct _is &#123;</div><div class="line"></div><div class="line">    struct _is *next;</div><div class="line">    struct _ts *tstate_head;  <span class="comment">#模拟进程环境中的线程集合</span></div><div class="line"></div><div class="line">    PyObject *modules;</div><div class="line">    PyObject *sysdict;</div><div class="line">    PyObject *builtins;</div><div class="line">    PyObject *modules_reloading;</div><div class="line"></div><div class="line">    PyObject *codec_search_path;</div><div class="line">    PyObject *codec_search_cache;</div><div class="line">    PyObject *codec_error_registry;</div><div class="line"></div><div class="line"><span class="comment">#ifdef HAVE_DLOPEN</span></div><div class="line">    int dlopenflags;</div><div class="line"><span class="comment">#endif</span></div><div class="line"><span class="comment">#ifdef WITH_TSC</span></div><div class="line">    int tscdump;</div><div class="line"><span class="comment">#endif</span></div><div class="line"></div><div class="line">&#125; PyInterpreterState;</div><div class="line"></div><div class="line">typedef struct _ts &#123;</div><div class="line">    /* See Python/ceval.c <span class="keyword">for</span> comments explaining most fields */</div><div class="line"></div><div class="line">    struct _ts *next;</div><div class="line">    PyInterpreterState *interp;</div><div class="line"></div><div class="line">    struct _frame *frame;  <span class="comment">#模拟线程中的函数调用堆栈, PyFrameObject对象</span></div><div class="line">    int recursion_depth;</div><div class="line">    /* <span class="string">'tracing'</span> keeps track of the execution depth when tracing/profiling.</div><div class="line">       This <span class="keyword">is</span> to prevent the actual trace/profile code <span class="keyword">from</span> being recorded <span class="keyword">in</span></div><div class="line">       the trace/profile. */</div><div class="line">    int tracing;</div><div class="line">    int use_tracing;</div><div class="line"></div><div class="line">    Py_tracefunc c_profilefunc;</div><div class="line">    Py_tracefunc c_tracefunc;</div><div class="line">    PyObject *c_profileobj;</div><div class="line">    PyObject *c_traceobj;</div><div class="line"></div><div class="line">    PyObject *curexc_type;</div><div class="line">    PyObject *curexc_value;</div><div class="line">    PyObject *curexc_traceback;</div><div class="line"></div><div class="line">    PyObject *exc_type;</div><div class="line">    PyObject *exc_value;</div><div class="line">    PyObject *exc_traceback;</div><div class="line"></div><div class="line">    PyObject *dict;  /* Stores per-thread state */</div><div class="line"></div><div class="line">    /* tick_counter <span class="keyword">is</span> incremented whenever the check_interval ticker</div><div class="line">     * reaches zero. The purpose <span class="keyword">is</span> to give a useful measure of the number</div><div class="line">     * of interpreted bytecode instructions <span class="keyword">in</span> a given thread.  This</div><div class="line">     * extremely lightweight statistic collector may be of interest to</div><div class="line">     * profilers (like psyco.jit()), although nothing <span class="keyword">in</span> the core uses it.</div><div class="line">     */</div><div class="line">    int tick_counter;</div><div class="line"></div><div class="line">    int gilstate_counter;</div><div class="line"></div><div class="line">    PyObject *async_exc; /* Asynchronous exception to <span class="keyword">raise</span> */</div><div class="line">    long thread_id; /* Thread id where this tstate was created */</div><div class="line"></div><div class="line">    int trash_delete_nesting;</div><div class="line">    PyObject *trash_delete_later;</div><div class="line"></div><div class="line">    /* XXX signal handlers should also be here */</div><div class="line"></div><div class="line">&#125; PyThreadState;</div></pre></td></tr></table></figure>
<p>python虚拟机开始执行, 会先将PyThreadState对象中的frame设置为当前执行环境(PyFrameObject), 当简称新的PyFrameObject环境时, 线程状态对象取出旧的frame, 建立PyFrameObject链表(在PyFrame_NEW中完成 <code>frameobject.c</code>)</p>
<blockquote>
<p>Python编译器完成编译后, 得到PyCodeObject对象,包含源文件的常量表(<code>co_consts</code>)和符号表(<code>co_names</code>), 然后形成PyFrameObject链, 在PyEval_EvalFrame函数中进行字节码指令执行, why维护python虚拟机中执行字节码执行的状态, WHY_NOT表示正常, WHY_EXCEPTION表示有异常抛出. 处理异常时, 创建traceback对象, 记录异常发生时活动栈帧的状态, 重新设置当前线程状态对象的活动帧, 完成栈帧回退动作, 最后python虚拟机流程一直返回到PyRun_SimpleFileExFlags函数(pythonrun.c), 然后会盗用PyErr_Print函数打印异常.(这样说整个过程不知道对不对, 还需要再读一遍书再来重新整理)</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#traceback.h</div><div class="line">typedef struct _traceback &#123;</div><div class="line">    PyObject_HEAD</div><div class="line">    struct _traceback *tb_next;  #链式结构</div><div class="line">    struct _frame *tb_frame;  #一个PyTracebackObject对应一个PyFrameObject对象</div><div class="line">    int tb_lasti;</div><div class="line">    int tb_lineno;</div><div class="line">&#125; PyTracebackObject;</div><div class="line"></div><div class="line">#traceback.c, 创建一个traceback对象</div><div class="line">int PyTraceBack_Here(PyFrameObject *frame)</div><div class="line">&#123;</div><div class="line">    #获得线程的状态对象</div><div class="line">    PyThreadState *tstate = PyThreadState_GET();</div><div class="line">    #保存线程状态对象中维护的traceback对象</div><div class="line">    PyTracebackObject *oldtb = (PyTracebackObject *) tstate-&gt;curexc_traceback;</div><div class="line">    #创建新的traceback对象</div><div class="line">    PyTracebackObject *tb = newtracebackobject(oldtb, frame);</div><div class="line">    if (tb == NULL)</div><div class="line">        return -1;</div><div class="line">    #将心的traceback对象交给线程状态对象</div><div class="line">    tstate-&gt;curexc_traceback = (PyObject *)tb;</div><div class="line">    Py_XDECREF(oldtb);</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#线程traceback对象链表</div><div class="line">static PyTracebackObject *</div><div class="line">newtracebackobject(PyTracebackObject *next, PyFrameObject *frame)</div></pre></td></tr></table></figure>
<blockquote>
<p>PyFrameObjectd是对栈帧的模拟， PyFrameObject连接成一条对象链时，就是对栈的模拟</p>
</blockquote>
<h2 id="3-Python虚拟机中的函数机制"><a href="#3-Python虚拟机中的函数机制" class="headerlink" title="#3. Python虚拟机中的函数机制"></a>#3. Python虚拟机中的函数机制</h2><h2 id="3-1-PyFunctionObject对象"><a href="#3-1-PyFunctionObject对象" class="headerlink" title="##3.1. PyFunctionObject对象"></a>##3.1. PyFunctionObject对象</h2><p>函数的python对象是PyFunctionObject</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#funcobject.h</div><div class="line">typedef struct &#123;</div><div class="line">    PyObject_HEAD</div><div class="line">    PyObject *func_code;    /* A code object 函数编译后的PyCodeObject对象*/</div><div class="line">    PyObject *func_globals; /* A dictionary (other mappings won't do) 函数运行时global名字空间*/</div><div class="line">    PyObject *func_defaults;    /* NULL or a tuple 默认参数*/</div><div class="line">    PyObject *func_closure; /* NULL or a tuple of cell objects 闭包的实现*/</div><div class="line">    PyObject *func_doc;     /* The __doc__ attribute, can be anything 函数文档*/</div><div class="line">    PyObject *func_name;    /* The __name__ attribute, a string object 函数名称*/</div><div class="line">    PyObject *func_dict;    /* The __dict__ attribute, a dict or NULL 函数的__dict__*/</div><div class="line">    PyObject *func_weakreflist; /* List of weak references */</div><div class="line">    PyObject *func_module;  /* The __module__ attribute, can be anything */</div><div class="line"></div><div class="line">    /* Invariant:</div><div class="line">     *     func_closure contains the bindings for func_code-&gt;co_freevars, so</div><div class="line">     *     PyTuple_Size(func_closure) == PyCode_GetNumFree(func_code)</div><div class="line">     *     (func_closure may be NULL if PyCode_GetNumFree(func_code) == 0).</div><div class="line">     */</div><div class="line">&#125; PyFunctionObject;</div></pre></td></tr></table></figure>
<ul>
<li>PyCodeObject是对源代码的静态表示</li>
<li><p>PyFunctionObject是python代码运行时动态产生的(执行def时创建,包含静态信息)</p>
</li>
<li><p>无参函数调用</p>
</li>
</ul>
<ol>
<li>加载函数对应PyCodeObject到运行栈</li>
<li>在执行MAKE_FUCNTION时,将对象弹出栈</li>
<li>通过PyFunction_New创建新的PyFunctionObject对象,并传入源对象的global名称空间</li>
<li>将新创建的对象压入运行栈</li>
<li>执行到函数调用CALL_FUNCTION指令时, 获得栈顶指针然后执行call_function函数</li>
<li>在fast_function函数中进入PyEval_EvalFrameEx,在新的frame栈帧(传入了PyFunctionObject对象中的字节码指令序列PyCodeObject和global名字空间)环境下执行函数中的语句</li>
</ol>
<blockquote>
<p>PyFunctionObject对象主要是对字节码指令和global名字空间进行打包和运输<br>Function, CFunction和Method都会调用这个函数</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">#ceval.c</div><div class="line">static PyObject *</div><div class="line">call_function(PyObject ***pp_stack, int oparg</div><div class="line">#ifdef WITH_TSC</div><div class="line">                , uint64* pintr0, uint64* pintr1</div><div class="line">#endif</div><div class="line">                )</div><div class="line">&#123;</div><div class="line">    #1. 处理函数参数信息</div><div class="line">    int na = oparg &amp; 0xff;  #oparg记录了参数的个数, na是位置参数的个数</div><div class="line">    int nk = (oparg&gt;&gt;8) &amp; 0xff;  #nk是键参数的个数</div><div class="line">    int n = na + 2 * nk;</div><div class="line">    #2. 获得PyFunctionObject对象</div><div class="line">    PyObject **pfunc = (*pp_stack) - n - 1;</div><div class="line">    PyObject *func = *pfunc;</div><div class="line">    PyObject *x, *w;</div><div class="line"></div><div class="line">    /* Always dispatch PyCFunction first, because these are</div><div class="line">       presumed to be the most frequent callable object.</div><div class="line">    */</div><div class="line">    if (PyCFunction_Check(func) &amp;&amp; nk == 0) &#123;</div><div class="line">        ...</div><div class="line">        #3. 调用PyFunctionObject对象</div><div class="line">        if (PyFunction_Check(func)) </div><div class="line">            x = fast_function(func, pp_stack, n, na, nk);  #一般函数通道和快速通道(通过参数形式来确定是否进入快速通道)</div><div class="line">        else</div><div class="line">            x = do_call(func, pp_stack, na, nk);</div><div class="line">        READ_TIMESTAMP(*pintr1);</div><div class="line">        Py_DECREF(func);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Clear the stack of the function object.  Also removes</div><div class="line">       the arguments in case they weren't consumed already</div><div class="line">       (fast_function() and err_args() leave them on the stack).</div><div class="line">     */</div><div class="line">    while ((*pp_stack) &gt; pfunc) &#123;</div><div class="line">        w = EXT_POP(*pp_stack);</div><div class="line">        Py_DECREF(w);</div><div class="line">        PCALL(PCALL_POP);</div><div class="line">    &#125;</div><div class="line">    return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##3.2. 参数的传递机制</p>
<ul>
<li>位置参数(positional argument): f(a, b)中的a, b</li>
<li>键参数(key argument): f(a, b, name = ‘Python’)</li>
<li>扩展位置参数: f(a, b, *args) </li>
<li>扩展键参数: f(a, b, **kwargs) </li>
</ul>
<blockquote>
<p>函数参数和局部变量关系密切</p>
</blockquote>
<ol>
<li>LOAD字节码指令将参数压入运行时栈</li>
<li>调用CALL_FUNCTION, 判断后调用fast_function</li>
<li>拷贝函数参数,从运行时栈到PyFrameObject.f_localplus</li>
<li>参数拷贝结束后, 进入新的PyEval_EvalFrameEx开始真正函数调用</li>
<li>在访问函数参数时,直接通过索引访问f_localsplus中存储的符号对应的值对象</li>
<li>对于带默认参数的函数处理有所不同, 会讲默认参数放入PyFunctionObject.func_defaults, 在fast_function中调用PyEval_EvalCodeEx(ceval.c)</li>
</ol>
<p>##3.3. 扩展位置参数和扩展键参数</p>
<blockquote>
<p><code>*args</code>和<code>*kwargs</code>作为一个局部变量实现, 分别有PyTupleObject和PyDictObject实现</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">#ceval.c</div><div class="line">PyObject *</div><div class="line">PyEval_EvalCodeEx(PyCodeObject *co, PyObject *globals, PyObject *locals,</div><div class="line">           PyObject **args, int argcount, PyObject **kws, int kwcount,</div><div class="line">           PyObject **defs, int defcount, PyObject *closure) #位置参数, 键参数, 默认参</div><div class="line">&#123;</div><div class="line">    register PyFrameObject *f;</div><div class="line">    register PyObject *retval = NULL;</div><div class="line">    register PyObject **fastlocals, **freevars;</div><div class="line">    PyThreadState *tstate = PyThreadState_GET();</div><div class="line">    PyObject *x, *u;</div><div class="line"></div><div class="line">    if (globals == NULL) &#123;</div><div class="line">        PyErr_SetString(PyExc_SystemError,</div><div class="line">                        "PyEval_EvalCodeEx: NULL globals");</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    assert(tstate != NULL);</div><div class="line">    assert(globals != NULL);</div><div class="line">    f = PyFrame_New(tstate, co, globals, locals);  #创建PyFrameObject对象</div><div class="line">    if (f == NULL)</div><div class="line">        return NULL;</div><div class="line"></div><div class="line">    fastlocals = f-&gt;f_localsplus;</div><div class="line">    freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;</div><div class="line">    #1. 判断是否需要处理扩展位置参数或者扩展键参数</div><div class="line">    if (co-&gt;co_argcount &gt; 0 ||</div><div class="line">        co-&gt;co_flags &amp; (CO_VARARGS | CO_VARKEYWORDS)) &#123;</div><div class="line">        ...</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">        #2. 设置位置参数的参数值</div><div class="line">        for (i = 0; i &lt; n; i++) &#123;</div><div class="line">            x = args[i];</div><div class="line">            Py_INCREF(x);</div><div class="line">            SETLOCAL(i, x);</div><div class="line">        &#125;</div><div class="line">        #3. 处理扩展位置参数</div><div class="line">        if (co-&gt;co_flags &amp; CO_VARARGS) &#123;</div><div class="line">            u = PyTuple_New(argcount - n); #4. 将PyTupleObject对象放入f_localsplus中</div><div class="line">            if (u == NULL)</div><div class="line">                goto fail;</div><div class="line">            SETLOCAL(co-&gt;co_argcount, u);</div><div class="line">            for (i = n; i &lt; argcount; i++) &#123; #5. 将扩展位置参数放入到PyTupleObject中</div><div class="line">                x = args[i];</div><div class="line">                Py_INCREF(x);</div><div class="line">                PyTuple_SET_ITEM(u, i-n, x);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        for (i = 0; i &lt; kwcount; i++) &#123;</div><div class="line">            PyObject **co_varnames;</div><div class="line">            PyObject *keyword = kws[2*i];</div><div class="line">            PyObject *value = kws[2*i + 1];</div><div class="line">            int j;</div><div class="line">            if (keyword == NULL || !(PyString_Check(keyword)</div><div class="line">#ifdef Py_USING_UNICODE</div><div class="line">                                     || PyUnicode_Check(keyword)</div><div class="line">#endif</div><div class="line">                        )) &#123;</div><div class="line">                PyErr_Format(PyExc_TypeError,</div><div class="line">                    "%.200s() keywords must be strings",</div><div class="line">                    PyString_AsString(co-&gt;co_name));</div><div class="line">                goto fail;</div><div class="line">            &#125;</div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当编译函数发现扩展位置参数后, 会在编译得到的PyCodeObject对象添加CO_VARARGS标识</li>
<li>对键扩展位置参数, 添加CO_VARKEYWORDS标识, 对扩展X参数放入对应的对象中</li>
<li>对象被放到frame中f_localsplus中</li>
<li>对于键参数, python虚拟机会先判断是否是一般的键参数</li>
</ul>
<p>##3.4. 嵌套函数/闭包与装饰器</p>
<blockquote>
<p>名字空间是在运行时python虚拟机动态维护的, 但时候希望名字空间静态化. 一种方法是将名字空间与函数绑定(<code>闭包</code>)</p>
</blockquote>
<p>闭包通过嵌套函数实现, PyCodeObject, PyFrameObject有关嵌套函数的属性</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#PyCodeObject</span></div><div class="line">co_cellvars  <span class="comment">#通常为tuple, 保存嵌套的作用域中使用的变量名集合</span></div><div class="line">co_freevars  <span class="comment">#通常为tuple, 保存使用了外层作用域中的变量名集合</span></div><div class="line"><span class="comment">#PyFrameObject</span></div><div class="line">f_localsplus <span class="comment">#extras = code-&gt;co_stacksize + code-&gt;co_nlocals + ncells + nfrees; 运行时栈+局部变量+cell对象+free对象</span></div></pre></td></tr></table></figure>
<p>闭包执行 :</p>
<ol>
<li>CALL_FUNCTION指令执行fast_funciton, 判断是否进入快速通道</li>
<li>python虚拟机创建cell对象(PyCellObject), 将参数(包括cell)拷贝到新创建的PyFrameObject中的f_localsplus</li>
<li>处理cell结束后, 虚拟机进入PyEval_EvalFrameEx,正式对外层函数调用</li>
<li>在执行内部函数时, 虚拟机会将外层的参数对应关系放到PyFunctionObject中.</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#cellobject.h</div><div class="line">typedef struct &#123;</div><div class="line">    PyObject_HEAD</div><div class="line">    PyObject *ob_ref;   /* Content of the cell or NULL when empty */</div><div class="line">&#125; PyCellObject;</div><div class="line"></div><div class="line">#cellobject.c</div><div class="line">PyObject *</div><div class="line">PyCell_New(PyObject *obj)</div><div class="line">&#123;</div><div class="line">    PyCellObject *op;</div><div class="line"></div><div class="line">    op = (PyCellObject *)PyObject_GC_New(PyCellObject, &amp;PyCell_Type);</div><div class="line">    if (op == NULL)</div><div class="line">        return NULL;</div><div class="line">    op-&gt;ob_ref = obj;</div><div class="line">    Py_XINCREF(obj);</div><div class="line"></div><div class="line">    _PyObject_GC_TRACK(op);</div><div class="line">    return (PyObject *)op;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#funcobject.h</div><div class="line">#define PyFunction_GET_CLOSURE(func) \</div><div class="line">    (((PyFunctionObject *)func) -&gt; func_closure)</div></pre></td></tr></table></figure>
<blockquote>
<p>装饰器则是对函数的闭包包装模式</p>
</blockquote>
<h2 id="4-Python虚拟机中的类机制"><a href="#4-Python虚拟机中的类机制" class="headerlink" title="#4. Python虚拟机中的类机制"></a>#4. Python虚拟机中的类机制</h2><p>##4.1. python中的对象模型</p>
<p>python中三类对象</p>
<ul>
<li>type对象:python内置对象的类型</li>
<li>class对象:python程序员自定义的类型</li>
<li>instance对象: 表示由class对象创建的实例</li>
</ul>
<blockquote>
<p>通过对象<code>__class__</code>属性或者python内置type方法可以探测is-instance-of关系(对象与实例), 使用对象的<code>__base__</code>属性可以探测is-kind-of关系</p>
</blockquote>
<ul>
<li>任何一个class类的type都是metaclass对象(<code>&lt;type, type&gt;</code>, 内部为PyType_Type)</li>
<li>Python中只要一个对象对应的class实现了<code>__call__</code>操作,那么这个对象就是可调用对象(在运行期在PyObject_CallFuunctionObjArgs中确定)</li>
</ul>
<p>python启动时,对类型系统进行初始化, 从<code>PyType_Ready</code>开始</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">#typeobject.c</div><div class="line">int</div><div class="line">PyType_Ready(PyTypeObject *type)</div><div class="line">&#123;</div><div class="line">    PyObject *dict, *bases;</div><div class="line">    PyTypeObject *base;</div><div class="line">    Py_ssize_t i, n;</div><div class="line"></div><div class="line">    if (type-&gt;tp_flags &amp; Py_TPFLAGS_READY) &#123;</div><div class="line">        assert(type-&gt;tp_dict != NULL);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    assert((type-&gt;tp_flags &amp; Py_TPFLAGS_READYING) == 0);</div><div class="line"></div><div class="line">    type-&gt;tp_flags |= Py_TPFLAGS_READYING;</div><div class="line"></div><div class="line">#ifdef Py_TRACE_REFS</div><div class="line">    /* PyType_Ready is the closest thing we have to a choke point</div><div class="line">     * for type objects, so is the best place I can think of to try</div><div class="line">     * to get type objects into the doubly-linked list of all objects.</div><div class="line">     * Still, not all type objects go thru PyType_Ready.</div><div class="line">     */</div><div class="line">    _Py_AddToAllObjects((PyObject *)type, 0);</div><div class="line">#endif</div><div class="line"></div><div class="line">    /* Initialize tp_base (defaults to BaseObject unless that's us) 尝试获得type的tp_base中指定的基类 class对象都是直接或者间接以PyBaseObject_Type(object)为基类 */</div><div class="line">    base = type-&gt;tp_base;</div><div class="line">    if (base == NULL &amp;&amp; type != &amp;PyBaseObject_Type) &#123;</div><div class="line">        base = type-&gt;tp_base = &amp;PyBaseObject_Type;</div><div class="line">        Py_INCREF(base);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Now the only way base can still be NULL is if type is</div><div class="line">     * &amp;PyBaseObject_Type.</div><div class="line">     */</div><div class="line"></div><div class="line">    /* Initialize the base class 如果基类没有初始化, 先初始化基类*/</div><div class="line">    if (base &amp;&amp; base-&gt;tp_dict == NULL) &#123;</div><div class="line">        if (PyType_Ready(base) &lt; 0)</div><div class="line">            goto error;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Initialize ob_type if NULL.      This means extensions that want to be</div><div class="line">       compilable separately on Windows can call PyType_Ready() instead of</div><div class="line">       initializing the ob_type field of their type objects. */</div><div class="line">    /* The test for base != NULL is really unnecessary, since base is only</div><div class="line">       NULL when type is &amp;PyBaseObject_Type, and we know its ob_type is</div><div class="line">       not NULL (it's initialized to &amp;PyType_Type).      But coverity doesn't</div><div class="line">       know that. 设置基类信息*/</div><div class="line">    if (Py_TYPE(type) == NULL &amp;&amp; base != NULL)</div><div class="line">        Py_TYPE(type) = Py_TYPE(base);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>处理基类和type信息(type中的tp_base中指定基类)</li>
<li>处理基类的列表(多重继承)</li>
<li>填充tp_dict(将与类型相关的descriptor加入tp_dict中, 其中slot表示PyTypeObject中定义的操作.通过slotdef结构体实现, 在init_slotdefs对整个slotdefs进行排序(操作优先级)), 一个操作对应一个包装slot的PyObject, 称为descriptor</li>
<li>tp_dict建立从从操作名到descriptor的关联(slot)</li>
<li>确定MRO(class对象属性解析顺序)</li>
<li>基本mro列表从基类继承操作</li>
<li>填充基本中的子类列表</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#typeobject.c</div><div class="line">typedef struct wrapperbase slotdef;</div><div class="line"></div><div class="line">#descrobject.c</div><div class="line">struct wrapperbase &#123;</div><div class="line">    char *name;  #操作对应的名字</div><div class="line">    int offset;  #操作函数在PyHeapTypeObject中的偏移量</div><div class="line">    void *function;  #slot function函数</div><div class="line">    wrapperfunc wrapper;</div><div class="line">    char *doc;</div><div class="line">    int flags;</div><div class="line">    PyObject *name_strobj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#创建descriptor的函数</div><div class="line">PyObject *</div><div class="line">PyDescr_NewWrapper(PyTypeObject *type, struct wrapperbase *base, void *wrapped)</div><div class="line">&#123;</div><div class="line">    PyWrapperDescrObject *descr;</div><div class="line"></div><div class="line">    descr = (PyWrapperDescrObject *)descr_new(&amp;PyWrapperDescr_Type,</div><div class="line">                                             type, base-&gt;name);</div><div class="line">    if (descr != NULL) &#123;</div><div class="line">        descr-&gt;d_base = base;</div><div class="line">        descr-&gt;d_wrapped = wrapped;  #d_wrapped存放操作对应的函数指针</div><div class="line">    &#125;</div><div class="line">    return (PyObject *)descr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##4.2. 用户自定义class及instance对象</p>
<ul>
<li>创建一个class对象, class的动态元信息存放在local名字空间中</li>
<li>获得class动态原信息/class名称/class基类列表, 虚拟机调用build_class创建class对象, 然后压入运行栈</li>
<li>将创建class对象存入local名称空间</li>
<li>创建实例时, 从local名称空间取出对象, 压入运行时栈</li>
<li>调用class对象创建instance对象</li>
<li>将instance对象存入loacal名字空间</li>
<li>python虚拟机使用object_new调用object继承来的tp_alloc(PyType_GenericAlllc)申请内存</li>
<li>回到type_csll进行初始化(tp_init指向slotdefs中指定与<code>__init__</code>对应的<code>slot_tp_init</code>)</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">#typeobject.c</div><div class="line">static PyObject *</div><div class="line">type_call(PyTypeObject *type, PyObject *args, PyObject *kwds)</div><div class="line">&#123;</div><div class="line">    PyObject *obj;</div><div class="line"></div><div class="line">    if (type-&gt;tp_new == NULL) &#123;</div><div class="line">        PyErr_Format(PyExc_TypeError,</div><div class="line">                     "cannot create '%.100s' instances",</div><div class="line">                     type-&gt;tp_name);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    obj = type-&gt;tp_new(type, args, kwds);</div><div class="line">    if (obj != NULL) &#123;</div><div class="line">        /* Ugly exception: when the call was type(something),</div><div class="line">           don't call tp_init on the result. */</div><div class="line">        if (type == &amp;PyType_Type &amp;&amp;</div><div class="line">            PyTuple_Check(args) &amp;&amp; PyTuple_GET_SIZE(args) == 1 &amp;&amp;</div><div class="line">            (kwds == NULL ||</div><div class="line">             (PyDict_Check(kwds) &amp;&amp; PyDict_Size(kwds) == 0)))</div><div class="line">            return obj;</div><div class="line">        /* If the returned object is not an instance of type,</div><div class="line">           it won't be initialized. */</div><div class="line">        if (!PyType_IsSubtype(obj-&gt;ob_type, type))</div><div class="line">            return obj;</div><div class="line">        type = obj-&gt;ob_type;</div><div class="line">        if (PyType_HasFeature(type, Py_TPFLAGS_HAVE_CLASS) &amp;&amp;</div><div class="line">            type-&gt;tp_init != NULL &amp;&amp;</div><div class="line">            type-&gt;tp_init(obj, args, kwds) &lt; 0) &#123;</div><div class="line">            Py_DECREF(obj);</div><div class="line">            obj = NULL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##4.3. 访问instance对象中属性</p>
<p>形如<code>x.y或x.y()</code>称为属性引用.</p>
<ul>
<li>instance对象入栈</li>
<li>通过PyObject_GetAttr获得属性</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#object.c</div><div class="line">PyObject *</div><div class="line">PyObject_GetAttr(PyObject *v, PyObject *name)</div><div class="line">&#123;</div><div class="line">    PyTypeObject *tp = Py_TYPE(v);</div><div class="line"></div><div class="line">    if (!PyString_Check(name)) &#123;</div><div class="line">#ifdef Py_USING_UNICODE</div><div class="line">        /* The Unicode to string conversion is done here because the</div><div class="line">           existing tp_getattro slots expect a string object as name</div><div class="line">           and we wouldn't want to break those. */</div><div class="line">        if (PyUnicode_Check(name)) &#123;</div><div class="line">            name = _PyUnicode_AsDefaultEncodedString(name, NULL);</div><div class="line">            if (name == NULL)</div><div class="line">                return NULL;</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">#endif</div><div class="line">        &#123;</div><div class="line">            PyErr_Format(PyExc_TypeError,</div><div class="line">                         "attribute name must be string, not '%.200s'",</div><div class="line">                         Py_TYPE(name)-&gt;tp_name);</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    #1. 通过tp_getattro获得属性对应对象</div><div class="line">    if (tp-&gt;tp_getattro != NULL)</div><div class="line">        return (*tp-&gt;tp_getattro)(v, name);</div><div class="line">    #2. 通过tp_getattr获得属性对应对象</div><div class="line">    if (tp-&gt;tp_getattr != NULL)</div><div class="line">        return (*tp-&gt;tp_getattr)(v, PyString_AS_STRING(name));</div><div class="line">    #3. 属性不存在,抛出异常</div><div class="line">    PyErr_Format(PyExc_AttributeError,</div><div class="line">                 "'%.50s' object has no attribute '%.400s'",</div><div class="line">                 tp-&gt;tp_name, PyString_AS_STRING(name));</div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2015/01/20/Python中logging模块/" class="prev">PREV</a><a href="/2015/01/13/看见/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'snow-memory';
var disqus_identifier = '2015/01/16/Python源码剖析读书笔记-二/';
var disqus_title = 'Python源码剖析读书笔记(二)';
var disqus_url = 'http://andrewliu.in/2015/01/16/Python源码剖析读书笔记-二/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//snow-memory.disqus.com/count.js" async></script><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>