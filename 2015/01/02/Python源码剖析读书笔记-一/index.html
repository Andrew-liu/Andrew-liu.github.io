<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Python源码剖析读书笔记(一) · Snow Memory | Andrew Liu</title><meta name="description" content="Python源码剖析读书笔记(一) - Andrew Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Python源码剖析读书笔记(一)</h1><div class="post-info">Jan 2, 2015</div><div class="post-content"><h2 id="0-编译Python"><a href="#0-编译Python" class="headerlink" title="#0. 编译Python"></a>#0. 编译Python</h2><ul>
<li>Include: 包含Python所有头文件</li>
<li>Lib: Python自带的所有标准库</li>
<li>Modules: 所有C语言编写的模块</li>
<li>Paser: Python解释器中Scanner和Parser部分(词法分析和语法分析)</li>
<li>Objects: Python所有内建对象及运行时需要的所有内部使用对象的实现</li>
<li>Python: Python解释器的Compiler和执行引擎(核心)</li>
<li>PCBuild: 工程文件</li>
</ul>
<p><strong>编译</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ./configure --prefix=/Users/andrew_liu/GitClone/cpython/Build</div><div class="line">$ make</div><div class="line">$ make install</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>#1. Python内建对象</p>
<blockquote>
<p>Python世界中一切都是对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* PyObject_HEAD defines the initial segment of every PyObject. */</div><div class="line">#define PyObject_HEAD                   \</div><div class="line">    _PyObject_HEAD_EXTRA                \</div><div class="line">    Py_ssize_t ob_refcnt;               \</div><div class="line">    struct _typeobject *ob_type;</div><div class="line"></div><div class="line">/* PyObject_VAR_HEAD defines the initial segment of all variable-sizecontainer objects */</div><div class="line">#define PyObject_VAR_HEAD               \</div><div class="line">    PyObject_HEAD                       \</div><div class="line">    Py_ssize_t ob_size; /* Number of items in variable part 指明变长对象中容纳元素的个数*/</div></pre></td></tr></table></figure>
<p>##1.1. Python内的对象</p>
<ul>
<li>Python中所有的内建的类型对象(int, str等对象)都是被静态初始化的</li>
<li>对象一旦创建, 内存大小就是不变的(变长的对象内部维护一个指向可变内存的指针)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">#object.h</div><div class="line">typedef struct _object &#123;</div><div class="line">    PyObject_HEAD</div><div class="line">&#125; PyObject;</div><div class="line"></div><div class="line">#实际是一个整型引用计数, 一个类型结构体指针</div><div class="line">typedef struct _object &#123;</div><div class="line">    Py_ssize_t ob_refcnt;  #int引用计数        </div><div class="line">    struct _typeobject *ob_type;</div><div class="line">&#125; PyObject;</div><div class="line"></div><div class="line">typedef struct _typeobject &#123;</div><div class="line">    PyObject_VAR_HEAD</div><div class="line">    const char *tp_name; /* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</div><div class="line">    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation 对象分配内存空间大小信息*/</div><div class="line"></div><div class="line">    /* Methods to implement standard operations */</div><div class="line"></div><div class="line">    destructor tp_dealloc;</div><div class="line">    printfunc tp_print;</div><div class="line">    getattrfunc tp_getattr;</div><div class="line">    setattrfunc tp_setattr;</div><div class="line">    cmpfunc tp_compare;</div><div class="line">    reprfunc tp_repr;</div><div class="line"></div><div class="line">    /* Method suites for standard classes */</div><div class="line"></div><div class="line">    PyNumberMethods *tp_as_number;  #数值对象支持操作</div><div class="line">    PySequenceMethods *tp_as_sequence;  #序列对象支持操作</div><div class="line">    PyMappingMethods *tp_as_mapping;  #关联对象支持操作</div><div class="line"></div><div class="line">    /* More standard operations (here for binary compatibility) */</div><div class="line">...</div><div class="line">&#125; PyTypeObject;</div><div class="line"></div><div class="line">#通过PyType_Type(对应&lt;type &apos;type&apos;&gt;, 被称为metaclass)来确定PyTypeObject</div><div class="line">#用户自定义class所对应的PyTypeObject就是通过PyType_Type创建</div><div class="line">#typeobject.c</div><div class="line">PyTypeObject PyType_Type = &#123;</div><div class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</div><div class="line">    &quot;type&quot;,                                     /* tp_name */</div><div class="line">    sizeof(PyHeapTypeObject),                   /* tp_basicsize */</div><div class="line">    sizeof(PyMemberDef),                        /* tp_itemsize */</div><div class="line">    (destructor)type_dealloc,                   /* tp_dealloc */</div><div class="line">...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Python每个对象除了PyObject还保存了属于自己的特殊的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#变长对象</div><div class="line">#define PyObject_VAR_HEAD               \</div><div class="line">    PyObject_HEAD                       \</div><div class="line">    Py_ssize_t ob_size; /* Number of items in variable part 指明变长对象中容纳元素的个数*/</div><div class="line">typedef struct &#123;</div><div class="line">    PyObject_VAR_HEAD</div><div class="line">&#125; PyVarObject;</div></pre></td></tr></table></figure>
<ul>
<li>int对象类型PyInt__Type</li>
<li>object对象类型PyBaseObject__Type</li>
</ul>
<blockquote>
<p>对象创建int为例, 调用<code>PyInt_Type</code>中的<code>tp_new</code>, 若为NULL则找到基类的<code>tp_new</code>, 知道找到不为NULL的<code>tp_new</code>, <code>tp_new</code>指向<code>object_new</code>, <code>object_new</code>访问<code>PyInt_Type</code>中的<code>tp_basicsize</code>完成内存申请.<code>PyInt_Type</code>继续执行<code>tp_init</code>初始化</p>
</blockquote>
<p><img src="http://picturebag.qiniudn.com/59.png" alt="对象"></p>
<blockquote>
<p>多态的核心: 通过传入对象的ob_type类型确定对象的类型, 从来调用对象对应的操作.</p>
</blockquote>
<p>###1.1.1. 引用计数</p>
<p>python每个对象都有一个<code>ob_refcnt</code>对象, 用来维持变量的引用计数.当引用计数减少到0, 调用对象对应的<code>tp_dealloc</code>析构.</p>
<blockquote>
<p>Python使用内存对象池计数, 避免频繁申请和释放内存.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#define _Py_NewReference(op) (  #初始化引用计数为1         \</div><div class="line">    _Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA         \</div><div class="line">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA               \</div><div class="line">    Py_REFCNT(op) = 1)</div><div class="line"></div><div class="line">#define _Py_ForgetReference(op) _Py_INC_TPFREES(op)</div><div class="line"></div><div class="line">#define _Py_Dealloc(op) (#为0时销毁对象            \</div><div class="line">    _Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA          \</div><div class="line">    (*Py_TYPE(op)-&gt;tp_dealloc)((PyObject *)(op)))</div><div class="line">#endif /* !Py_TRACE_REFS */</div><div class="line"></div><div class="line">#define Py_INCREF(op) ( #增加对象引用计数       \</div><div class="line">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</div><div class="line">    ((PyObject*)(op))-&gt;ob_refcnt++)</div><div class="line"></div><div class="line">#define Py_DECREF(op) #减少对象引用计数, 为0时调用dealloc销毁  \</div><div class="line">    do &#123;                                                \</div><div class="line">        if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</div><div class="line">        --((PyObject*)(op))-&gt;ob_refcnt != 0)            \</div><div class="line">            _Py_CHECK_REFCNT(op)                        \</div><div class="line">        else                                            \</div><div class="line">        _Py_Dealloc((PyObject *)(op));                  \</div><div class="line">    &#125; while (0)</div></pre></td></tr></table></figure>
<p>###1.1.2. Python中五大对象</p>
<p><img src="http://picturebag.qiniudn.com/60.png" alt="五大对象"></p>
<h2 id="2-Python中的整数对象"><a href="#2-Python中的整数对象" class="headerlink" title="#2. Python中的整数对象"></a>#2. Python中的整数对象</h2><p>##2.1. PyIntOject对象</p>
<p>Python中的整型对象就是对C原生类型long的简单封装</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#intobject.h</span></div><div class="line"><span class="comment">#PyIntOject创建方式</span></div><div class="line">PyAPI_FUNC(PyObject *) PyInt_FromString(char*, char**, int);</div><div class="line"><span class="comment">#ifdef Py_USING_UNICODE</span></div><div class="line">PyAPI_FUNC(PyObject *) PyInt_FromUnicode(Py_UNICODE*, Py_ssize_t, int);</div><div class="line"><span class="comment">#endif</span></div><div class="line">PyAPI_FUNC(PyObject *) PyInt_FromLong(long);</div><div class="line">PyAPI_FUNC(PyObject *) PyInt_FromSize_t(size_t);</div><div class="line">PyAPI_FUNC(PyObject *) PyInt_FromSsize_t(Py_ssize_t);</div></pre></td></tr></table></figure>
<p>从字符串和Py_UNICODE生成整型对象, 都是先转换为浮点数在调用<code>PyInt_FromLong</code></p>
<ul>
<li>对于小整数, 在小整数对象池中缓存PyIntOjects对象, 范围<code>[-5, 257)</code></li>
<li>对于大整数, 提供一块内存空间供大整数轮流使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#intoject.c</div><div class="line">#小整数</div><div class="line">#ifndef NSMALLPOSINTS</div><div class="line">#define NSMALLPOSINTS           257</div><div class="line">#endif</div><div class="line">#ifndef NSMALLNEGINTS</div><div class="line">#define NSMALLNEGINTS           5</div><div class="line">#endif</div><div class="line">#if NSMALLNEGINTS + NSMALLPOSINTS &gt; 0</div><div class="line">/* References to small integers are saved in this array so that they</div><div class="line">   can be shared.</div><div class="line">   The integers that are saved are those in the range</div><div class="line">   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).</div><div class="line">*/</div><div class="line"></div><div class="line">#大整数</div><div class="line">#define BLOCK_SIZE      1000    /* 1K less typical malloc overhead */</div><div class="line">#define BHEAD_SIZE      8       /* Enough for a 64-bit pointer */</div><div class="line">#define N_INTOBJECTS    ((BLOCK_SIZE - BHEAD_SIZE) / sizeof(PyIntObject))</div><div class="line"></div><div class="line">struct _intblock &#123;</div><div class="line">    struct _intblock *next;</div><div class="line">    PyIntObject objects[N_INTOBJECTS];</div><div class="line">&#125;;</div><div class="line">typedef struct _intblock PyIntBlock;</div><div class="line">static PyIntBlock *block_list = NULL;</div><div class="line">static PyIntObject *free_list = NULL;</div></pre></td></tr></table></figure>
<p>PyIntBlock单项列表通过block_list维护, 每个block中维护一个PyIntObject数组<code>objects</code>, 通过单项链表指针<code>free_list</code>指向空闲内存头部</p>
<p>###2.1.1. 添加和删除</p>
<ul>
<li>如果小整数对象池被激活, 则尝试使用小整数对象池</li>
<li>否则, 使用通用的整数对象池</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#intojects.c</div><div class="line">PyObject * PyInt_FromLong(long ival)</div><div class="line">&#123;</div><div class="line">    register PyIntObject *v;  #尝试使用小整数对象池</div><div class="line">#if NSMALLNEGINTS + NSMALLPOSINTS &gt; 0</div><div class="line">    if (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS) &#123;</div><div class="line">        v = small_ints[ival + NSMALLNEGINTS];</div><div class="line">        Py_INCREF(v); #引用计数加一</div><div class="line">#ifdef COUNT_ALLOCS</div><div class="line">        if (ival &gt;= 0)</div><div class="line">            quick_int_allocs++;</div><div class="line">        else</div><div class="line">            quick_neg_int_allocs++;</div><div class="line">#endif</div><div class="line">        return (PyObject *) v;</div><div class="line">    &#125;</div><div class="line">#endif  #为通用整数对象池申请新的内存空间</div><div class="line">    if (free_list == NULL) &#123;</div><div class="line">        if ((free_list = fill_free_list()) == NULL)</div><div class="line">            return NULL;</div><div class="line">    &#125;</div><div class="line">    /* Inline PyObject_New */</div><div class="line">    v = free_list;  #通过free_list找到空闲的内存</div><div class="line">    free_list = (PyIntObject *)Py_TYPE(v);</div><div class="line">    PyObject_INIT(v, &amp;PyInt_Type);</div><div class="line">    v-&gt;ob_ival = ival;</div><div class="line">    return (PyObject *) v;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结: 对于小整数, 会直接使用固定的小整数对象池, 对使用的对象引用计数加一, 对于非小整数, 通过free_list获得空闲内存来创建对象, 若为NULL表示用完或者初次创建, 会调用fill_free_list函数来创建新的空闲内存, 并且在引用计数为零时, 将对象销毁, 这块内存会重新加入到free_list中被使用.</p>
<h2 id="3-Python中的字符串对象"><a href="#3-Python中的字符串对象" class="headerlink" title="#3. Python中的字符串对象"></a>#3. Python中的字符串对象</h2><ul>
<li>定长对象和变长对象区别在于数据的长度是否在<code>对象创建时</code>就已经确定(内存长度). 简单的判断方式结构体是否有<code>PyObject_VAR_HEAD</code>宏(其中ob_size表示内存长度)</li>
<li>可变对象和不可变对象的区别在于<code>对象被创建后</code>是否还能够变化</li>
</ul>
<blockquote>
<p>PyStringObject是对字符串对象的实现, 是拥有可变长度内存的对象, PyStringObject是一个变长对象且是不可变对象</p>
</blockquote>
<p>##3.1. PyStringObject和PyString_Type</p>
<p><code>PyStringObject</code>对象定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#stringobject.h</div><div class="line">typedef struct &#123;</div><div class="line">    PyObject_VAR_HEAD</div><div class="line">    long ob_shash;  #缓存对象的hash值, 初始-1, string_hash计算哈希</div><div class="line">    int ob_sstate;</div><div class="line">    char ob_sval[1];  #实际作为一个字符指针指向一段内存, 这段内存保存着字符串所维护的实际字符串</div><div class="line">&#125; PyStringObject;</div></pre></td></tr></table></figure>
<p><code>PyStringObject</code>对一个的类型对象<code>PyString_Type</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#stringobject.c</div><div class="line">PyTypeObject PyString_Type = &#123;</div><div class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</div><div class="line">    &quot;str&quot;,</div><div class="line">    PyStringObject_SIZE,</div><div class="line">    sizeof(char),  #指明变长对象保存的元素的单位长度</div><div class="line">    string_dealloc,                             /* tp_dealloc */</div><div class="line">    (printfunc)string_print,                    /* tp_print */</div><div class="line">...</div><div class="line">   string_repr,                                /* tp_repr */</div><div class="line">    &amp;string_as_number,                          /* tp_as_number */</div><div class="line">    &amp;string_as_sequence,                        /* tp_as_sequence */</div><div class="line">    &amp;string_as_mapping,                         /* tp_as_mapping */</div><div class="line">    (hashfunc)string_hash,                      /* tp_hash */</div><div class="line">...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>##3.2. 创建PyStringOject对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">#stringobject.c</div><div class="line">PyObject *</div><div class="line">PyString_FromString(const char *str)</div><div class="line">&#123;</div><div class="line">    register size_t size;</div><div class="line">    register PyStringObject *op;</div><div class="line"></div><div class="line">    assert(str != NULL);</div><div class="line">    size = strlen(str);  #获得字符串长度</div><div class="line">    if (size &gt; PY_SSIZE_T_MAX - PyStringObject_SIZE) &#123;</div><div class="line">        PyErr_SetString(PyExc_OverflowError,</div><div class="line">            &quot;string is too long for a Python string&quot;);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    if (size == 0 &amp;&amp; (op = nullstring) != NULL) &#123;  #处理null string</div><div class="line">#ifdef COUNT_ALLOCS</div><div class="line">        null_strings++;</div><div class="line">#endif</div><div class="line">        Py_INCREF(op);</div><div class="line">        return (PyObject *)op;</div><div class="line">    &#125;</div><div class="line">    if (size == 1 &amp;&amp; (op = characters[*str &amp; UCHAR_MAX]) != NULL) &#123;  #处理字符</div><div class="line">#ifdef COUNT_ALLOCS</div><div class="line">        one_strings++;</div><div class="line">#endif</div><div class="line">        Py_INCREF(op);</div><div class="line">        return (PyObject *)op;</div><div class="line">    &#125;</div><div class="line">    /* Inline PyObject_NewVar 创建新的对象, 并初始化 */</div><div class="line">    op = (PyStringObject *)PyObject_MALLOC(PyStringObject_SIZE + size);</div><div class="line">    if (op == NULL)</div><div class="line">        return PyErr_NoMemory();</div><div class="line">    PyObject_INIT_VAR(op, &amp;PyString_Type, size);</div><div class="line">    op-&gt;ob_shash = -1;</div><div class="line">    op-&gt;ob_sstate = SSTATE_NOT_INTERNED;</div><div class="line">    Py_MEMCPY(op-&gt;ob_sval, str, size+1);</div><div class="line">    /* share short strings */</div><div class="line">    if (size == 0) &#123;</div><div class="line">        PyObject *t = (PyObject *)op;</div><div class="line">        PyString_InternInPlace(&amp;t);</div><div class="line">        op = (PyStringObject *)t;</div><div class="line">        nullstring = op;</div><div class="line">        Py_INCREF(op);</div><div class="line">    &#125; else if (size == 1) &#123;</div><div class="line">        PyObject *t = (PyObject *)op;</div><div class="line">        PyString_InternInPlace(&amp;t);</div><div class="line">        op = (PyStringObject *)t;</div><div class="line">        characters[*str &amp; UCHAR_MAX] = op;</div><div class="line">        Py_INCREF(op);</div><div class="line">    &#125;</div><div class="line">    return (PyObject *) op;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一种创建方法<code>PyString_FromStringAndSize</code>, 两者区别在于前者要求字符串以<code>\0</code>结尾, 后者要传入size长度’</p>
<p><img src="http://picturebag.qiniudn.com/61.png" alt="string"></p>
<p>##3.3. 字符串对象的intern机制</p>
<p><code>PyString_InternInPlace(&amp;t);</code>表示intern机制</p>
<p>一个被intern后的字符串, 在python运行期中, 只有唯一一个对应的字符串, 在判断两个字符喘对象是否相同时, 如果都被intern了, 值需要检查对应的<code>PyObject *</code>是否相同, 这个机制节省空间, 并简化了字符串对象的比较</p>
<blockquote>
<p>也就是说, intern机制对相同的字符串只会占用一块内存, 每次创建字符串会先查找相同字符串是否已经存在, 存在就返回对象的引用, <code>重要的是一点, 字符串对象是先被创建, 然后才调用intern机制, 创建的对象相当于临时对象, 在intern机制成功时, 马上因引用计数为0被销毁</code></p>
</blockquote>
<p>intern机制(<code>pystring_interninplace</code>):</p>
<ol>
<li>检查是否为PyStringObject对象</li>
<li>检查对象是否被intern机制处理过</li>
<li>系统使用一个字典保存映射关系</li>
<li>当对象a应用intern机制, 检查字典是否有符合条件的对象b, 若有, a的<code>PyObject *</code>指针指向b, a的引用计数减一</li>
<li>没有符合的则将a记录到interned中</li>
</ol>
<p>##3.4. 字符缓冲池</p>
<p>对于字符对象:</p>
<ol>
<li>创建PyStringObject对象</li>
<li>对对象进行intern操作</li>
<li>将对象缓存到字符串缓冲池中</li>
</ol>
<blockquote>
<p>由于字符串对象是不可变对象, 不推荐使用<code>+</code>操作(会不断创建新的中间对象, 不断申请内存), 推荐将字符串存入list或tuple, 使用<code>join</code>方法(只申请一次内存)</p>
</blockquote>
<h2 id="4-Python中的list对象"><a href="#4-Python中的list对象" class="headerlink" title="#4. Python中的list对象"></a>#4. Python中的list对象</h2><p>python中的list(<code>vector&lt;PyOject *&gt;</code>)与STL中的vector类似</p>
<blockquote>
<p>list是一个变长对象(结构体包含<code>PyObject_VAR_HEAD</code>)和可变对象</p>
</blockquote>
<p>##4.1. PyListObject对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    PyObject_VAR_HEAD  #ob_size表示使用中的内存</div><div class="line">    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. </div><div class="line">    *     0 &lt;= ob_size &lt;= allocated</div><div class="line">    *     len(list) == ob_size</div><div class="line">    *     ob_item == NULL implies ob_size == allocated == 0</div><div class="line">    */</div><div class="line">    PyObject **ob_item;</div><div class="line">    /* ob_item contains space for &apos;allocated&apos; elements.  The number currently in use is ob_size. */</div><div class="line">    Py_ssize_t allocated;  #记录申请的总内存大小</div><div class="line">&#125; PyListObject;</div></pre></td></tr></table></figure>
<p>##4.2. PyListObject对象的创建与维护</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">#listobject.c</div><div class="line">#define PyList_MAXFREELIST 80</div><div class="line">PyObject *</div><div class="line">PyList_New(Py_ssize_t size)  #指定元素个数, 不是内存大小</div><div class="line">&#123;</div><div class="line">    PyListObject *op;</div><div class="line">    size_t nbytes;</div><div class="line">#ifdef SHOW_ALLOC_COUNT</div><div class="line">    static int initialized = 0;</div><div class="line">    if (!initialized) &#123;</div><div class="line">        Py_AtExit(show_alloc);</div><div class="line">        initialized = 1;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">    if (size &lt; 0) &#123;</div><div class="line">        PyErr_BadInternalCall();</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    /* Check for overflow without an actual overflow,</div><div class="line">     *  which can cause compiler to optimise out  内存数量计算, 溢出检查*/</div><div class="line">    if ((size_t)size &gt; PY_SIZE_MAX / sizeof(PyObject *))</div><div class="line">        return PyErr_NoMemory();</div><div class="line">    nbytes = size * sizeof(PyObject *);</div><div class="line">    if (numfree) &#123;  #缓冲池可用</div><div class="line">        numfree--;</div><div class="line">        op = free_list[numfree];</div><div class="line">        _Py_NewReference((PyObject *)op);</div><div class="line">#ifdef SHOW_ALLOC_COUNT</div><div class="line">        count_reuse++;</div><div class="line">#endif</div><div class="line">    &#125; else &#123;  #缓冲池不可用</div><div class="line">        op = PyObject_GC_New(PyListObject, &amp;PyList_Type);</div><div class="line">        if (op == NULL)</div><div class="line">            return NULL;</div><div class="line">#ifdef SHOW_ALLOC_COUNT</div><div class="line">        count_alloc++;</div><div class="line">#endif</div><div class="line">    &#125;</div><div class="line">    if (size &lt;= 0)  #为PyListObject对象中维护的元素列表申请空间</div><div class="line">        op-&gt;ob_item = NULL;</div><div class="line">    else &#123;</div><div class="line">        op-&gt;ob_item = (PyObject **) PyMem_MALLOC(nbytes);</div><div class="line">        if (op-&gt;ob_item == NULL) &#123;</div><div class="line">            Py_DECREF(op);</div><div class="line">            return PyErr_NoMemory();</div><div class="line">        &#125;</div><div class="line">        memset(op-&gt;ob_item, 0, nbytes);</div><div class="line">    &#125;</div><div class="line">    Py_SIZE(op) = size;</div><div class="line">    op-&gt;allocated = size;</div><div class="line">    _PyObject_GC_TRACK(op);</div><div class="line">    return (PyObject *) op;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PyListObject对象创建分为两部分, 对象本身和对象维护的元素列表,他们通过<code>ob_item</code>建立联系.完成两者创建会调用对象用于维护ob_size和allocated变量, 创建对象时, 如果numfree为0, 会绕过对象缓冲池在堆上创建新的对象</p>
<p>设置元素调用<code>PyList_SetItem</code>不会导致内存变量, 插入元素调用<code>PyList_Insert</code>可能导致ob_item指向的内存变量, 附加元素调用<code>PyList_Append</code>, 删除元素调用<code>listremove</code>(实际内部执行了list_ass_slice函数)会触发内存搬移的工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">static int</div><div class="line">ins1(PyListObject *self, Py_ssize_t where, PyObject *v)</div><div class="line">&#123;</div><div class="line">    Py_ssize_t i, n = Py_SIZE(self);</div><div class="line">    PyObject **items;</div><div class="line">    if (v == NULL) &#123;</div><div class="line">        PyErr_BadInternalCall();</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    if (n == PY_SSIZE_T_MAX) &#123;</div><div class="line">        PyErr_SetString(PyExc_OverflowError,</div><div class="line">            &quot;cannot add more objects to list&quot;);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (list_resize(self, n+1) == -1)  #调整列表容量realloc</div><div class="line">        return -1;</div><div class="line"></div><div class="line">    if (where &lt; 0) &#123;  #确定插入点 为负的时候</div><div class="line">        where += n;</div><div class="line">        if (where &lt; 0)</div><div class="line">            where = 0;</div><div class="line">    &#125;</div><div class="line">    if (where &gt; n) #大于容量时</div><div class="line">        where = n;</div><div class="line">    items = self-&gt;ob_item;</div><div class="line">    for (i = n; --i &gt;= where; ) #元素后移</div><div class="line">        items[i+1] = items[i];</div><div class="line">    Py_INCREF(v);</div><div class="line">    items[where] = v; #插入元素</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>##4.3. PyListObject对象缓冲池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">static void</div><div class="line">list_dealloc(PyListObject *op)</div><div class="line">&#123;</div><div class="line">    Py_ssize_t i;</div><div class="line">    PyObject_GC_UnTrack(op);</div><div class="line">    Py_TRASHCAN_SAFE_BEGIN(op)</div><div class="line">    if (op-&gt;ob_item != NULL) &#123;  #销毁元素列表</div><div class="line">        /* Do it backwards, for Christian Tismer.</div><div class="line">           There&apos;s a simple test case where somehow this reduces</div><div class="line">           thrashing when a *very* large list is created and</div><div class="line">           immediately deleted. */</div><div class="line">        i = Py_SIZE(op);</div><div class="line">        while (--i &gt;= 0) &#123; </div><div class="line">            Py_XDECREF(op-&gt;ob_item[i]);  #减少引用计数</div><div class="line">        &#125;</div><div class="line">        PyMem_FREE(op-&gt;ob_item);</div><div class="line">    &#125;</div><div class="line">    if (numfree &lt; PyList_MAXFREELIST &amp;&amp; PyList_CheckExact(op))  #销毁list对象自身, 先查看缓冲池是否满了, 没满就放入缓冲池</div><div class="line">        free_list[numfree++] = op;</div><div class="line">    else</div><div class="line">        Py_TYPE(op)-&gt;tp_free((PyObject *)op);</div><div class="line">    Py_TRASHCAN_SAFE_END(op)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>缓冲的仅仅是<code>PyListObject</code>对象, 不包含维护的元素列表</p>
</blockquote>
<p><img src="http://picturebag.qiniudn.com/62.png" alt="list"></p>
<h2 id="5-Python中Dict对象"><a href="#5-Python中Dict对象" class="headerlink" title="#5. Python中Dict对象"></a>#5. Python中Dict对象</h2><p>关联式容器元素通常以key-value形式存在,PyDictObject采用了散列表(hash table), </p>
<p>##5.1. PyDictObject</p>
<p>Python中哈希表使用开放定址法处理冲突, 删除时使用<code>伪删除操作</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#dictobject.h</div><div class="line">typedef struct &#123;</div><div class="line">    /* Cached hash code of me_key.  Note that hash codes are C longs.</div><div class="line">     * We have to use Py_ssize_t instead because dict_popitem() abuses</div><div class="line">     * me_hash to hold a search finger.</div><div class="line">     */</div><div class="line">    Py_ssize_t me_hash;</div><div class="line">    PyObject *me_key;</div><div class="line">    PyObject *me_value;</div><div class="line">&#125; PyDictEntry;</div></pre></td></tr></table></figure>
<p>python中dict什么都能装下, 是因为<code>Pyobject *</code>相当于<code>void *</code>.</p>
<p>dict中entry三态:</p>
<ul>
<li><code>Unused</code>: 未存储key-value, 每个entry的初始状态, me_key和me_value为NULL</li>
<li><code>Active</code>: 存储了key-value,me_key和me_valu都不能为NULL,me_key不能为dummy对象</li>
<li><code>Dummy</code>: 当entry中存储的key-value被删除后, me_key指向dummy对象, entry进入Dummy</li>
</ul>
<p><strong>关联容器的实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">typedef struct _dictobject PyDictObject;</div><div class="line">struct _dictobject &#123;</div><div class="line">    PyObject_HEAD</div><div class="line">    Py_ssize_t ma_fill;  /* 曾经和正使用的个数# Active + # Dummy */</div><div class="line">    Py_ssize_t ma_used;  /* 被正常使用的元素个数# Active */</div><div class="line"></div><div class="line">    /* The table contains ma_mask + 1 slots, and that&apos;s a power of 2.</div><div class="line">     * We store the mask instead of the size because the mask is more</div><div class="line">     * frequently needed.</div><div class="line">     */</div><div class="line">    Py_ssize_t ma_mask;  #entry个数, 因为作大量与操作, 所以不用ma_size命名</div><div class="line"></div><div class="line">    /* ma_table points to ma_smalltable for small tables, else to</div><div class="line">     * additional malloc&apos;ed memory.  ma_table is never NULL!  This rule</div><div class="line">     * saves repeated runtime null-tests in the workhorse getitem and</div><div class="line">     * setitem calls.</div><div class="line">     */</div><div class="line">    PyDictEntry *ma_table; #entry小于8,则指向ma_smalltable, 超过8个会额外申请内存, 并且指针指向内存, 不会为NULL</div><div class="line">    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);</div><div class="line">    PyDictEntry ma_smalltable, [PyDict_MINSIZE]; #至少有8个entry被创建</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><img src="http://picturebag.qiniudn.com/63.png" alt="table"></p>
<p>##5.2. PyDictObject的创建和维护</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">PyObject *</div><div class="line">PyDict_New(void)</div><div class="line">&#123;</div><div class="line">    register PyDictObject *mp;</div><div class="line">    if (dummy == NULL) &#123; /* Auto-initialize dummy, 是一个字符串对象PyString_FromString */</div><div class="line">        dummy = PyString_FromString(&quot;&lt;dummy key&gt;&quot;);</div><div class="line">        if (dummy == NULL)  </div><div class="line">            return NULL;</div><div class="line">#ifdef SHOW_CONVERSION_COUNTS</div><div class="line">        Py_AtExit(show_counts);</div><div class="line">#endif</div><div class="line">#ifdef SHOW_ALLOC_COUNT</div><div class="line">        Py_AtExit(show_alloc);</div><div class="line">#endif</div><div class="line">#ifdef SHOW_TRACK_COUNT</div><div class="line">        Py_AtExit(show_track);</div><div class="line">#endif</div><div class="line">    &#125;</div><div class="line">    if (numfree) &#123;  #使用缓冲池</div><div class="line">        mp = free_list[--numfree];</div><div class="line">        assert (mp != NULL);</div><div class="line">        assert (Py_TYPE(mp) == &amp;PyDict_Type);</div><div class="line">        _Py_NewReference((PyObject *)mp);</div><div class="line">        if (mp-&gt;ma_fill) &#123;</div><div class="line">            EMPTY_TO_MINSIZE(mp);</div><div class="line">        &#125; else &#123;</div><div class="line">            /* At least set ma_table and ma_mask; these are wrong</div><div class="line">               if an empty but presized dict is added to freelist */</div><div class="line">            INIT_NONZERO_DICT_SLOTS(mp);</div><div class="line">        &#125;</div><div class="line">        assert (mp-&gt;ma_used == 0);</div><div class="line">        assert (mp-&gt;ma_table == mp-&gt;ma_smalltable);</div><div class="line">        assert (mp-&gt;ma_mask == PyDict_MINSIZE - 1);</div><div class="line">#ifdef SHOW_ALLOC_COUNT</div><div class="line">        count_reuse++;</div><div class="line">#endif</div><div class="line">    &#125; else &#123;  #创建新的PyDictObject对象</div><div class="line">        mp = PyObject_GC_New(PyDictObject, &amp;PyDict_Type);</div><div class="line">        if (mp == NULL)</div><div class="line">            return NULL;</div><div class="line">        EMPTY_TO_MINSIZE(mp);</div><div class="line">#ifdef SHOW_ALLOC_COUNT</div><div class="line">        count_alloc++;</div><div class="line">#endif</div><div class="line">    &#125;</div><div class="line">    mp-&gt;ma_lookup = lookdict_string;  #包含了哈希函数和冲突函数的实现</div><div class="line">#ifdef SHOW_TRACK_COUNT</div><div class="line">    count_untracked++;</div><div class="line">#endif</div><div class="line">#ifdef SHOW_CONVERSION_COUNTS</div><div class="line">    ++created;</div><div class="line">#endif</div><div class="line">    return (PyObject *)mp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*将ma_smalltable清零, 同时设置ma_used和ma_fill*/</div><div class="line">#define EMPTY_TO_MINSIZE(mp) do &#123;                                       \</div><div class="line">    memset((mp)-&gt;ma_smalltable, 0, sizeof((mp)-&gt;ma_smalltable));        \</div><div class="line">    (mp)-&gt;ma_used = (mp)-&gt;ma_fill = 0;                                  \</div><div class="line">    INIT_NONZERO_DICT_SLOTS(mp);                                        \</div><div class="line">    &#125; while(0)</div><div class="line">/*将ma_table指向ma_samlltable, 并设置ma_mask为7*/</div><div class="line">#define INIT_NONZERO_DICT_SLOTS(mp) do &#123;                                \</div><div class="line">    (mp)-&gt;ma_table = (mp)-&gt;ma_smalltable;                               \</div><div class="line">    (mp)-&gt;ma_mask = PyDict_MINSIZE - 1;                                 \</div><div class="line">    &#125; while(0)</div></pre></td></tr></table></figure>
<p>python中提供了<code>lookdict</code>和<code>lookdict_string</code>(key多为字符串, 所以作为默认搜索方法, 两者使用相同的算法)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">static PyDictEntry *</div><div class="line">lookdict(PyDictObject *mp, PyObject *key, register long hash)</div><div class="line">&#123;</div><div class="line">    register size_t i;</div><div class="line">    register size_t perturb;</div><div class="line">    register PyDictEntry *freeslot;</div><div class="line">    register size_t mask = (size_t)mp-&gt;ma_mask;</div><div class="line">    PyDictEntry *ep0 = mp-&gt;ma_table;</div><div class="line">    register PyDictEntry *ep;</div><div class="line">    register int cmp;</div><div class="line">    PyObject *startkey;</div><div class="line"></div><div class="line">    i = (size_t)hash &amp; mask;  #哈希, 定位第一个entry</div><div class="line">    ep = &amp;ep0[i]; #entry处理Unused或者entry中key匹配</div><div class="line">    if (ep-&gt;me_key == NULL || ep-&gt;me_key == key)</div><div class="line">        return ep;</div><div class="line"></div><div class="line">    if (ep-&gt;me_key == dummy) #第一个entry的key为dummy状态</div><div class="line">        freeslot = ep; #freeslot指向第一个处于Dummy的entry</div><div class="line">    else &#123;  #检查Active的entry</div><div class="line">        if (ep-&gt;me_hash == hash) &#123;  </div><div class="line">            startkey = ep-&gt;me_key;</div><div class="line">            Py_INCREF(startkey);</div><div class="line">            cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);</div><div class="line">            Py_DECREF(startkey);</div><div class="line">            if (cmp &lt; 0)</div><div class="line">                return NULL;</div><div class="line">            if (ep0 == mp-&gt;ma_table &amp;&amp; ep-&gt;me_key == startkey) &#123;</div><div class="line">                if (cmp &gt; 0)</div><div class="line">                    return ep;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                /* The compare did major nasty stuff to the</div><div class="line">                 * dict:  start over.</div><div class="line">                 * XXX A clever adversary could prevent this</div><div class="line">                 * XXX from terminating.</div><div class="line">                 */</div><div class="line">                return lookdict(mp, key, hash);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        freeslot = NULL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* In the loop, me_key == dummy is by far (factor of 100s) the</div><div class="line">       least likely outcome, so test for that last. */</div><div class="line">    for (perturb = hash; ; perturb &gt;&gt;= PERTURB_SHIFT) &#123;</div><div class="line">        i = (i &lt;&lt; 2) + i + perturb + 1;</div><div class="line">        ep = &amp;ep0[i &amp; mask];</div><div class="line">        if (ep-&gt;me_key == NULL) #到达Unused状态entry,搜索失败</div><div class="line">            return freeslot == NULL ? ep : freeslot;</div><div class="line">        if (ep-&gt;me_key == key)  #检查是否引用相同</div><div class="line">            return ep;</div><div class="line">        if (ep-&gt;me_hash == hash &amp;&amp; ep-&gt;me_key != dummy) &#123; #检查值是否相同</div><div class="line">            startkey = ep-&gt;me_key;</div><div class="line">            Py_INCREF(startkey);</div><div class="line">            cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);</div><div class="line">            Py_DECREF(startkey);</div><div class="line">            if (cmp &lt; 0)</div><div class="line">                return NULL;</div><div class="line">            if (ep0 == mp-&gt;ma_table &amp;&amp; ep-&gt;me_key == startkey) &#123;</div><div class="line">                if (cmp &gt; 0)</div><div class="line">                    return ep;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                /* The compare did major nasty stuff to the</div><div class="line">                 * dict:  start over.</div><div class="line">                 * XXX A clever adversary could prevent this</div><div class="line">                 * XXX from terminating.</div><div class="line">                 */</div><div class="line">                return lookdict(mp, key, hash);</div><div class="line">            &#125;</div><div class="line">        &#125; </div><div class="line">        else if (ep-&gt;me_key == dummy &amp;&amp; freeslot == NULL) #设置freeslot</div><div class="line">            freeslot = ep; </div><div class="line">    &#125;</div><div class="line">    assert(0);          /* NOT REACHED */</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>For both, when the key isn’t found a PyDictEntry* is returned for which the <code>me_value field is NULL</code></p>
</blockquote>
<ul>
<li>第一阶段: 判断冲突探测链上第一个entry的key与待查找key是否匹配</li>
<li>第二阶段: 若不匹配, 再一次比较探测脸上的entry与带查找key</li>
</ul>
<p>插入函数<code>insertdict</code></p>
<ol>
<li>先调用<code>PyDict_SetItem</code>获得hash只(必要时会调整dict的内存空间)</li>
<li>搜索成功, 返回Active的entry, 然后替换me_value</li>
<li>搜索失败, 返回Unused或者Dummy的entry, 完整设置key-value</li>
</ol>
<p>改变ma_table大小由<code>dictresize</code>完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">Restructure the table by allocating a new table and reinserting all</div><div class="line">items again.  When entries have been deleted, the new table may</div><div class="line">actually be smaller than the old one.</div><div class="line">*/</div><div class="line">static int</div><div class="line">dictresize(PyDictObject *mp, Py_ssize_t minused)</div><div class="line">&#123;</div><div class="line">    Py_ssize_t newsize;</div><div class="line">    PyDictEntry *oldtable, *newtable, *ep;</div><div class="line">    Py_ssize_t i;</div><div class="line">    int is_oldtable_malloced;</div><div class="line">    PyDictEntry small_copy[PyDict_MINSIZE];</div><div class="line"></div><div class="line">    assert(minused &gt;= 0);</div><div class="line"></div><div class="line">    /* Find the smallest table size &gt; minused. 确定新table的大小 */</div><div class="line">    for (newsize = PyDict_MINSIZE;</div><div class="line">         newsize &lt;= minused &amp;&amp; newsize &gt; 0;</div><div class="line">         newsize &lt;&lt;= 1)</div><div class="line">        ;</div><div class="line">    if (newsize &lt;= 0) &#123;</div><div class="line">        PyErr_NoMemory();</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Get space for a new table. */</div><div class="line">    oldtable = mp-&gt;ma_table;</div><div class="line">    assert(oldtable != NULL);</div><div class="line">    is_oldtable_malloced = oldtable != mp-&gt;ma_smalltable;</div><div class="line"></div><div class="line">    if (newsize == PyDict_MINSIZE) &#123; #新table可以使用mp-&gt;ma_smalltable</div><div class="line">        /* A large table is shrinking, or we can&apos;t get any smaller. */</div><div class="line">        newtable = mp-&gt;ma_smalltable;</div><div class="line">        if (newtable == oldtable) &#123;</div><div class="line">            if (mp-&gt;ma_fill == mp-&gt;ma_used) &#123;</div><div class="line">                /* No dummies, so no point doing anything. */</div><div class="line">                return 0;</div><div class="line">            &#125;</div><div class="line">            /* We&apos;re not going to resize it, but rebuild the</div><div class="line">               table anyway to purge old dummy entries.</div><div class="line">               Subtle:  This is *necessary* if fill==size,</div><div class="line">               as lookdict needs at least one virgin slot to</div><div class="line">               terminate failing searches.  If fill &lt; size, it&apos;s</div><div class="line">               merely desirable, as dummies slow searches. */</div><div class="line">            assert(mp-&gt;ma_fill &gt; mp-&gt;ma_used);</div><div class="line">            memcpy(small_copy, oldtable, sizeof(small_copy)); #将旧table拷贝, 进行备份</div><div class="line">            oldtable = small_copy;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else &#123;  #新table需要在系统堆上申请</div><div class="line">        newtable = PyMem_NEW(PyDictEntry, newsize);</div><div class="line">        if (newtable == NULL) &#123;</div><div class="line">            PyErr_NoMemory();</div><div class="line">            return -1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Make the dict empty, using the new table. */</div><div class="line">    assert(newtable != oldtable);</div><div class="line">    mp-&gt;ma_table = newtable;</div><div class="line">    mp-&gt;ma_mask = newsize - 1;</div><div class="line">    memset(newtable, 0, sizeof(PyDictEntry) * newsize);</div><div class="line">    mp-&gt;ma_used = 0;</div><div class="line">    i = mp-&gt;ma_fill;</div><div class="line">    mp-&gt;ma_fill = 0;</div><div class="line"></div><div class="line">    /* Copy the data over; this is refcount-neutral for active entries;</div><div class="line">       dummy entries aren&apos;t copied over, of course */</div><div class="line">    for (ep = oldtable; i &gt; 0; ep++) &#123;</div><div class="line">        if (ep-&gt;me_value != NULL) &#123;             /* active entry */</div><div class="line">            --i;</div><div class="line">            insertdict_clean(mp, ep-&gt;me_key, (long)ep-&gt;me_hash,</div><div class="line">                             ep-&gt;me_value);</div><div class="line">        &#125;</div><div class="line">        else if (ep-&gt;me_key != NULL) &#123;          /* dummy entry */</div><div class="line">            --i;</div><div class="line">            assert(ep-&gt;me_key == dummy);</div><div class="line">            Py_DECREF(ep-&gt;me_key);</div><div class="line">        &#125;</div><div class="line">        /* else key == value == NULL:  nothing to do */</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (is_oldtable_malloced)</div><div class="line">        PyMem_DEL(oldtable);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>确定新table的大小</li>
<li>如果新table大小为8, 不需要在堆上分配空间, 使用ma_smalltabel, 否则在堆上分配空间</li>
<li>新table初始化</li>
<li>对非Unused处理, Active插入到新表,Dummy丢弃</li>
<li>如果旧table指向系统堆内存, 需要释放内存</li>
</ol>
<p>删除流程<code>PyDict_DelItem</code></p>
<ol>
<li>计算hash</li>
<li>搜索entry</li>
<li>删除entry中的元素, 并将Active置为Dummy态</li>
<li>调整维护table使用情况的变量</li>
</ol>
<p>##5.3. PyDictObject对象缓冲池</p>
<p>类似于PyListObject缓冲池机制, 初始缓冲池空, 直到第一个PyDictObject销毁, 缓冲池才开始接纳被缓冲的PydictObject对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#ifndef PyDict_MAXFREELIST</div><div class="line">#define PyDict_MAXFREELIST 80</div><div class="line">#endif</div><div class="line">static PyDictObject *free_list[PyDict_MAXFREELIST];</div><div class="line">static int numfree = 0;</div><div class="line"></div><div class="line">static void</div><div class="line">dict_dealloc(register PyDictObject *mp)</div><div class="line">&#123;</div><div class="line">    register PyDictEntry *ep;</div><div class="line">    Py_ssize_t fill = mp-&gt;ma_fill;</div><div class="line">    PyObject_GC_UnTrack(mp);</div><div class="line">    Py_TRASHCAN_SAFE_BEGIN(mp)</div><div class="line">    #调整dict中对象引用计数</div><div class="line">    for (ep = mp-&gt;ma_table; fill &gt; 0; ep++) &#123;</div><div class="line">        if (ep-&gt;me_key) &#123;</div><div class="line">            --fill;</div><div class="line">            Py_DECREF(ep-&gt;me_key);</div><div class="line">            Py_XDECREF(ep-&gt;me_value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (mp-&gt;ma_table != mp-&gt;ma_smalltable)</div><div class="line">        PyMem_DEL(mp-&gt;ma_table); #释放table指向的堆内存</div><div class="line">    if (numfree &lt; PyDict_MAXFREELIST &amp;&amp; Py_TYPE(mp) == &amp;PyDict_Type)</div><div class="line">        free_list[numfree++] = mp; #销毁的对象放入缓冲池</div><div class="line">    else</div><div class="line">        Py_TYPE(mp)-&gt;tp_free((PyObject *)mp);</div><div class="line">    Py_TRASHCAN_SAFE_END(mp)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2015/01/09/Django搭建简易博客教程-九-多说-markdown和代码高亮/" class="prev">上一篇</a><a href="/2014/12/31/Python闭包和装饰器/" class="next">下一篇</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>