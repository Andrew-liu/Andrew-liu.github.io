<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> UNIX网络编程基础 · Snow Memory | Andrew Liu</title><meta name="description" content="UNIX网络编程基础 - Andrew Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">UNIX网络编程基础</h1><div class="post-info">Jul 5, 2015</div><div class="post-content"><p>本博客采用创作共用版权协议, 要求署名、非商业用途和保持一致. 转载本博客文章必须也遵循<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">署名-非商业用途-保持一致</a>的创作共用协议.</p>
<p>#传输层</p>
<ul>
<li>UDP(User Datagram Protocol), 无连接, 不可靠, 全双工,  UDP套接字是一种数据报套接字</li>
<li>TCP(Transmission Control Protocol), 客户端服务器建立连接, 全双工, 可靠, 包含动态估算RTT算法, 流量控制, 超时重传</li>
<li>SCTP(Stream Control Transmission Protocol), 面向消息, 面向连接, 单个SCTP断点支持多个IP地址(<code>多宿性</code>)</li>
</ul>
<a id="more"></a>
<p><strong>TCP三次握手</strong></p>
<ol>
<li>客户端主动连接服务器(<code>connect()</code>), 并发送一个SYN(告诉服务器未来发送数据的初始序列号)</li>
<li>服务器一直等待连接(<code>accept()</code>), 收到SYN后, 发出新的SYN+ACK进行确认</li>
<li>客户端向服务器发出ACK确认, accept返回套接字描述符</li>
</ol>
<p><strong>TCP四次终止</strong></p>
<ol>
<li>客户端主动关闭(<code>close()</code>), 向服务器端发送FIN表示数据发送完毕</li>
<li>服务器端收到FIN后, 向客户端发出ACK确认, FIN表明服务器端不需要再接收数据</li>
<li>一段时间后, 服务器端接收到进程关闭套接字描述符(<code>close()</code>), 并想客户端发送一个FIN</li>
<li>客户端收到FIN后, 向服务器发出确认</li>
</ol>
<blockquote>
<p>(<strong>注意:</strong>)三阶段到四阶段, 主动关闭的一方进入<code>TIME_WAIT</code>状态, 为了可靠的实现TCP全双工连接的终止, 允许老的重复分解在网络中消失(P37)</p>
</blockquote>
<p><strong>套接字表面上可以认为由IP和端口号组成, IP用来表示不同的主机(也就是端到端), 端口号用来表示一台主机上不同的进程(不同进程使用不同的端口号)</strong></p>
<p><strong>TCP输出过程:</strong></p>
<ul>
<li>进程调用write(), 内核从应用进程的缓冲区复制所有数据到套接字的发送缓冲区(<code>SO_SNDBUF</code>)</li>
<li>如果套接字发送缓冲区小于应用发送缓冲区(或者套接字发送缓冲已有数据), 则进程睡眠(<code>阻塞</code>).</li>
<li>直到进程缓冲区所有数据都复制的发送缓冲区.</li>
<li>TCP从套接字发送缓冲区提取并发送数据(<code>数据未确认前, TCP保留数据副本</code>)</li>
</ul>
<blockquote>
<p>write()返回仅表示可以重新使用应用缓冲区, 并<code>不标明另一端的TCP接收到数据</code></p>
</blockquote>
<p>对于UDP, 如果进程写一个<code>大于套接字缓冲区大小的数据报</code>, 内核将返回<code>EMSGSIZE错误</code>, UDP不保留数据副本</p>
<blockquote>
<p>write调用成功返回表示<code>所写数据报已被加入数据链路层的传输队列</code></p>
</blockquote>
<p>#套接字</p>
<ul>
<li>bind, connect, sendto, sendmsg是从进程到内核传递套接字</li>
<li>accept, recvfrom, recvmsg, getpeername, getsockname是从内核到进程传递套接字</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//所有类型的套接字都至少是16字节</span></div><div class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">sockaddr_in</span> &#123;</span></div><div class="line">    <span class="keyword">uint8_t</span> sin_len;   <span class="comment">/* length of struct */</span></div><div class="line">    <span class="keyword">sa_family_t</span> sin_family;  <span class="comment">/* Address family */</span></div><div class="line"><span class="keyword">in_port_t</span>  <span class="keyword">int</span>  sin_port;  <span class="comment">/* Port number */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>  <span class="comment">/* Internet address */</span></div><div class="line">    <span class="keyword">unsigned</span>  <span class="keyword">char</span>  sin_zero[<span class="number">8</span>];  <span class="comment">/* Same size as struct sockaddr */</span></div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span> &#123;</span></div><div class="line">    <span class="keyword">in_addr_t</span>  s_addr; <span class="comment">/* 32-bit network byte ordered IPv4 address */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//网络编程函数中的struct sockaddr参数</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></div><div class="line">    <span class="keyword">uint8_t</span> sa_len;    </div><div class="line">    sa_family sa_family;     <span class="comment">/* address family, AF_xxx */</span></div><div class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];                 <span class="comment">/* 14 bytes of protocol address */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//网络编程需要将指向特定协议的套接字地址结构的指针进行强制转换, 编程通用套接字地址结构指针</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span>  <span class="comment">//IPv4套接字结构</span></div><div class="line">(struct sockaddr *)&amp;serv  <span class="comment">//强制类型转换</span></div></pre></td></tr></table></figure>
<ul>
<li>内存中存储数据的方法分为<code>小端字节序</code>和<code>大端字节序</code></li>
<li>网络协议指定<code>网络字节序</code>规则各字节传送顺序(使用大端字节序)</li>
</ul>
<p><strong>ASCII字符串与网络字节序的二进制值进行转换</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="comment">/* 下面两个函数仅适用于IPv4 */</span></div><div class="line"><span class="comment">//将字符串转换为网络字节序二进制数, 字符串有效返回1, 否则返回0</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *pin)</span></span>;</div><div class="line"><span class="comment">//将网络字节序二进制转换为点十进制字符换</span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">/* 适用于IPv4和IPv6 */</span></div><div class="line"><span class="comment">//第一个参数可以是AF_INET或者AF_INET6, 将表达格式(点十进制IP地址, presentation format address)转换为网络格式(network format), 成功返回1, 表达格式无效返回0, 出错返回-1</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> src, <span class="keyword">void</span> * <span class="keyword">restrict</span> dst)</span></span>;</div><div class="line"><span class="comment">//将网络格式转换为表达格式(presentation format address), 成功返回指向结果的指针, 出错则为NULL</span></div><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">restrict</span> src, <span class="keyword">char</span> * <span class="keyword">restrict</span> dst, <span class="keyword">socklen_t</span> size)</span></span>;</div></pre></td></tr></table></figure>
<p>##Rio</p>
<p><strong>字节流套接字条用调用read或write输入和输出的字节数可以比请求的数量少, 原因在于内核中用于套接字的缓冲区可能已达到极限</strong>, 这一点在<code>CSAPP</code>中<code>Rio</code>章节同样有深入的讲解.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*********************************************************************</span></div><div class="line"> * The Rio package - robust I/O functions</div><div class="line"> **********************************************************************/</div><div class="line"><span class="comment">/*</span></div><div class="line"> * rio_readn - robustly read n bytes (unbuffered)</div><div class="line"> */</div><div class="line"><span class="comment">/* $begin rio_readn */</span></div><div class="line"><span class="keyword">ssize_t</span> rio_readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n) &#123; <span class="comment">//等价与UNP中的readn函数</span></div><div class="line">    <span class="keyword">size_t</span> nleft = n;</div><div class="line">    <span class="keyword">ssize_t</span> nread;</div><div class="line">    <span class="keyword">char</span> *bufp = usrbuf;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">if</span> ((nread = read(fd, bufp, nleft)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (errno == EINTR) <span class="comment">/* interrupted by sig handler return */</span></div><div class="line">        nread = <span class="number">0</span>;      <span class="comment">/* and call read() again */</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">/* errno set by read() */</span> </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</div><div class="line">        <span class="keyword">break</span>;              <span class="comment">/* EOF */</span></div><div class="line">    nleft -= nread;  <span class="comment">//nleft保存剩余需要读取的字节数， nread表示已读字节数</span></div><div class="line">    bufp += nread;  <span class="comment">// bufp始终指向要读取的字符串起始位置</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (n - nleft);         <span class="comment">/* return &gt;= 0 */</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/* $end rio_readn */</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * rio_writen - robustly write n bytes (unbuffered)</div><div class="line"> */</div><div class="line"><span class="comment">/* $begin rio_writen */</span></div><div class="line"><span class="keyword">ssize_t</span> rio_writen(<span class="keyword">int</span> fd, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n) &#123;  <span class="comment">//等价于UNP中的writen函数</span></div><div class="line">    <span class="keyword">size_t</span> nleft = n;</div><div class="line">    <span class="keyword">ssize_t</span> nwritten;</div><div class="line">    <span class="keyword">char</span> *bufp = usrbuf;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">if</span> ((nwritten = write(fd, bufp, nleft)) &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (errno == EINTR)  <span class="comment">/* interrupted by sig handler return */</span></div><div class="line">        nwritten = <span class="number">0</span>;    <span class="comment">/* and call write() again */</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;       <span class="comment">/* errno set by write() */</span></div><div class="line">    &#125;</div><div class="line">    nleft -= nwritten;</div><div class="line">    bufp += nwritten;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* $end rio_writen */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line"> * rio_read - This is a wrapper for the Unix read() function that</div><div class="line"> *    transfers min(n, rio_cnt) bytes from an internal buffer to a user</div><div class="line"> *    buffer, where n is the number of bytes requested by the user and</div><div class="line"> *    rio_cnt is the number of unread bytes in the internal buffer. On</div><div class="line"> *    entry, rio_read() refills the internal buffer via a call to</div><div class="line"> *    read() if the internal buffer is empty.</div><div class="line"> */</div><div class="line"><span class="comment">/* $begin rio_read */</span></div><div class="line"><span class="comment">//当调用rio_read读取n个字节时，读缓冲区内有rp-&gt;rio_cnt个未读字节 //如果缓冲区为空，则调用read填满</span></div><div class="line"><span class="comment">//缓冲区非空， rio_read从读缓冲区拷贝n和rp-&gt;rio_cnt中较小的字节到用户缓冲区，并返回拷贝字节</span></div><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">rio_read</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">char</span> *usrbuf, <span class="keyword">size_t</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> cnt;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (rp-&gt;rio_cnt &lt;= <span class="number">0</span>) &#123;  <span class="comment">/* refill if buf is empty */</span></div><div class="line">        rp-&gt;rio_cnt = read(rp-&gt;rio_fd, rp-&gt;rio_buf, </div><div class="line">               <span class="keyword">sizeof</span>(rp-&gt;rio_buf));  <span class="comment">//调用的是系统read函数，预先读取到内部缓冲区中</span></div><div class="line">    <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (errno != EINTR) <span class="comment">/* interrupted by sig handler return */</span></div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rp-&gt;rio_cnt == <span class="number">0</span>)  <span class="comment">/* EOF */</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span> </div><div class="line">        rp-&gt;rio_bufptr = rp-&gt;rio_buf; <span class="comment">/* reset buffer ptr */</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Copy min(n, rp-&gt;rio_cnt) bytes from internal buf to user buf */</span></div><div class="line">    cnt = n;          </div><div class="line">    <span class="keyword">if</span> (rp-&gt;rio_cnt &lt; n)   </div><div class="line">        cnt = rp-&gt;rio_cnt;</div><div class="line">    <span class="built_in">memcpy</span>(usrbuf, rp-&gt;rio_bufptr, cnt); <span class="comment">//rio_bufptr始终指向字符串初始复制位置，复制cnt个倡导到usrbuf</span></div><div class="line">    rp-&gt;rio_bufptr += cnt; <span class="comment">//复制初始位置指针后移</span></div><div class="line">    rp-&gt;rio_cnt -= cnt;  <span class="comment">//缓冲区大小剪掉已读取字符数</span></div><div class="line">    <span class="keyword">return</span> cnt;  <span class="comment">//返回已读取字符数， 返回值与系统read含义类似</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/* $end rio_read */</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * rio_readinitb - Associate a descriptor with a read buffer and reset buffer*（缓冲区初始化）</div><div class="line"> */</div><div class="line"><span class="comment">/* $begin rio_readinitb */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">rio_readinitb</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">int</span> fd)</span> </span></div><div class="line">&#123;</div><div class="line">    rp-&gt;rio_fd = fd;  </div><div class="line">    rp-&gt;rio_cnt = <span class="number">0</span>;  </div><div class="line">    rp-&gt;rio_bufptr = rp-&gt;rio_buf;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* $end rio_readinitb */</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * rio_readnb - Robustly read n bytes (buffered)</div><div class="line"> */</div><div class="line"><span class="comment">/* $begin rio_readnb */</span></div><div class="line"><span class="keyword">ssize_t</span> rio_readnb(<span class="keyword">rio_t</span> *rp, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n) </div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> nleft = n;</div><div class="line">    <span class="keyword">ssize_t</span> nread;</div><div class="line">    <span class="keyword">char</span> *bufp = usrbuf;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((nread = rio_read(rp, bufp, nleft)) &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (errno == EINTR) <span class="comment">/* interrupted by sig handler return */</span></div><div class="line">                nread = <span class="number">0</span>;      <span class="comment">/* call read() again */</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">/* errno set by read() */</span> </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</div><div class="line">        <span class="keyword">break</span>;              <span class="comment">/* EOF */</span></div><div class="line">    nleft -= nread;</div><div class="line">    bufp += nread;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> (n - nleft);         <span class="comment">/* return &gt;= 0 */</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/* $end rio_readnb */</span></div><div class="line"></div><div class="line"><span class="comment">/* </span></div><div class="line"> * rio_readlineb - robustly read a text line (buffered) 线程安全</div><div class="line"> */</div><div class="line"><span class="comment">/* $begin rio_readlineb */</span></div><div class="line"><span class="keyword">ssize_t</span> rio_readlineb(<span class="keyword">rio_t</span> *rp, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> maxlen) </div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n, rc;</div><div class="line">    <span class="keyword">char</span> c, *bufp = usrbuf;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123; </div><div class="line">        <span class="keyword">if</span> ((rc = rio_read(rp, &amp;c, <span class="number">1</span>)) == <span class="number">1</span>) &#123;</div><div class="line">            *bufp++ = c;</div><div class="line">        <span class="keyword">if</span> (c == <span class="string">'\n'</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* EOF, no data read */</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">break</span>;    <span class="comment">/* EOF, some data was read */</span></div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">/* error */</span></div><div class="line">    &#125;</div><div class="line">    *bufp = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* $end rio_readlineb */</span></div><div class="line"></div><div class="line"><span class="comment">/**********************************</span></div><div class="line"> * Wrappers for robust I/O routines</div><div class="line"> **********************************/</div><div class="line"><span class="keyword">ssize_t</span> Rio_readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nbytes) </div><div class="line">&#123;</div><div class="line">    <span class="keyword">ssize_t</span> n;</div><div class="line">  </div><div class="line">    <span class="keyword">if</span> ((n = rio_readn(fd, ptr, nbytes)) &lt; <span class="number">0</span>)</div><div class="line">        unix_error(<span class="string">"Rio_readn error"</span>);</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rio_writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (rio_writen(fd, usrbuf, n) != n)</div><div class="line">        unix_error(<span class="string">"Rio_writen error"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rio_readinitb</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">int</span> fd)</span></span></div><div class="line">&#123;</div><div class="line">    rio_readinitb(rp, fd);</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> Rio_readnb(<span class="keyword">rio_t</span> *rp, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> n) </div><div class="line">&#123;</div><div class="line">    <span class="keyword">ssize_t</span> rc;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((rc = rio_readnb(rp, usrbuf, n)) &lt; <span class="number">0</span>)</div><div class="line">        unix_error(<span class="string">"Rio_readnb error"</span>);</div><div class="line">    <span class="keyword">return</span> rc;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> Rio_readlineb(<span class="keyword">rio_t</span> *rp, <span class="keyword">void</span> *usrbuf, <span class="keyword">size_t</span> maxlen) </div><div class="line">&#123;</div><div class="line">    <span class="keyword">ssize_t</span> rc;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((rc = rio_readlineb(rp, usrbuf, maxlen)) &lt; <span class="number">0</span>)</div><div class="line">        unix_error(<span class="string">"Rio_readlineb error"</span>);</div><div class="line">    <span class="keyword">return</span> rc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Stevens的UNP中使用static不是线程安全的，在CSapp中rio_readlineb和rio_readnb修改了两个缺陷，都是缓冲区读，并且线程安全， 其中核心为rio_t读缓冲区struct</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/* Persistent state for the robust I/O (Rio) package */</span></div><div class="line"><span class="comment">/* $begin rio_t */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RIO_BUFSIZE 8192</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> rio_fd;                <span class="comment">/* descriptor for this internal buf */</span></div><div class="line">    <span class="keyword">int</span> rio_cnt;               <span class="comment">/* unread bytes in internal buf */</span></div><div class="line">    <span class="keyword">char</span> *rio_bufptr;          <span class="comment">/* next unread byte in internal buf */</span></div><div class="line">    <span class="keyword">char</span> rio_buf[RIO_BUFSIZE]; <span class="comment">/* internal buffer */</span></div><div class="line">&#125; <span class="keyword">rio_t</span>;</div><div class="line"><span class="comment">/* $end rio_t */</span></div></pre></td></tr></table></figure>
<p>#参考</p>
<ul>
<li>UNIX网络编程第三版</li>
<li>深入理解计算机系统（系统I/O章节）</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2015/07/12/Tmux入门指南/" class="prev">PREV</a><a href="/2015/06/27/Redis使用入门/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'snow-memory';
var disqus_identifier = '2015/07/05/UNIX网络编程基础/';
var disqus_title = 'UNIX网络编程基础';
var disqus_url = 'http://andrewliu.in/2015/07/05/UNIX网络编程基础/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//snow-memory.disqus.com/count.js" async></script><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>