<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 迷之指针指针 · Snow Memory | Andrew Liu</title><meta name="description" content="迷之指针指针 - Andrew Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">迷之指针指针</h1><div class="post-info">Oct 3, 2015</div><div class="post-content"><p>本博客采用创作共用版权协议, 要求署名、非商业用途和保持一致. 转载本博客文章必须也遵循<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">署名-非商业用途-保持一致</a>的创作共用协议.</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul>
<li>高级语言中的变量是使用户以一种简单的方式记住内存地址, <code>硬件依然是通过地址访问内存位置</code></li>
<li>如何判断地址中存储变量类型是通过访问时使用的<code>机器指令</code></li>
<li>指针存储内存地址, 通过指针访问指针所指向的内存地址的过程称为<code>间接访问</code></li>
<li>指针和一个整数量执行算术运算时, 整数在执行加法/减法前始终根据合适的大小调整(int型指针加一操作实际上内存地址+4, int占四个字节)</li>
</ul>
<a id="more"></a>
<p>动态内存分配问题:</p>
<p>当指针指向一块已经分配内存的变量时, 无需malloc分配动态内存. 当想通过指针使用一块内存存储数据时, 需要动态开辟内存.</p>
<p>传参问题: </p>
<ul>
<li>如果不想修改指针, 指向修改指针中内存的值的时候, 不需要再加一重指针</li>
<li>如果需要修改指针中存储的内存地址时, 需要在原基础上增加一重指针</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ListNode* root;  //链表的根节点</div><div class="line">bool FindValue(ListNode* root, int value); //从链表中查找某个值是否存在. 无需修改root内存储的地址.</div><div class="line"></div><div class="line">bool InsertValue(ListNode** root, int value); //将一个值插入某有序链表. 此函数可能使插入的节点变为新的头结点, 此时需要修改root, 所以需要使用二重指针使函数外部同步修改.</div></pre></td></tr></table></figure>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数指针的初始化, 其中<code>&amp;</code>是可选的, <strong>函数名被使用时总是被编译器转换成函数指针, 指针指向函数在内存中的位置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int f(int); //函数原型</div><div class="line">int (*pf)(int) = &amp;f; </div><div class="line">int (*pf)(int) = f; //等价</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 函数指针数组</div><div class="line">int* (*fun[])(float left, int right); //合法声明一个函数指针数组, 接受两个参数并返回int型指针</div></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>数组名的值是一个<code>指针常量(无法修改)</code>, 即数组第一个元素的地址. <code>数组名的类型是指向数组类型的常量指针</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 声明一个数组</span></div><div class="line"><span class="keyword">int</span> nums[<span class="number">20</span>];</div><div class="line"><span class="comment">// 声明一个函数原型</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearArray</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearArray</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">int</span> len)</span></span>; <span class="comment">//等价</span></div><div class="line"></div><div class="line"><span class="comment">//调用函数, 数组名为数组第一个元素的地址, 所以此处为传址调用</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearArray</span><span class="params">(nums, <span class="number">20</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>数组和指针的区别:</p>
<ul>
<li>声明数组时, 编译器将根据声明所指定的元素数量为数组保留内存空间, 然后再创建数组名, 他的值是一个常量, 并指向这段空间的起始位置</li>
<li>声明指针时, 编译器只为指针本身保留内存空间</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 字符数组</span></div><div class="line"><span class="keyword">char</span> message[] = <span class="string">"Hello"</span>;</div><div class="line"><span class="comment">// 字符串常量</span></div><div class="line"><span class="keyword">char</span>* str = <span class="string">"Hello"</span>;  <span class="comment">//指针常量</span></div></pre></td></tr></table></figure>
<h3 id="指向数组的指针"><a href="#指向数组的指针" class="headerlink" title="指向数组的指针"></a>指向数组的指针</h3><ul>
<li>下标实际上是间接访问数组的一种伪装形式, 其等价于指针解引用访问</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 二维数组的下标和指针表示第二行第六个元素, 二者等价</div><div class="line">matrix[1][5];</div><div class="line">*(*(matrix + 1) + 5);</div><div class="line"></div><div class="line">// 指向数组的指针</div><div class="line">int vector[10], *pvector = vector;</div><div class="line">int matrix[3][10];</div><div class="line">int (*p)[10] = matrix;  // p是一个指向整型数组的指针, 定义 类型说明符  (*指针变量名)[长度]</div><div class="line">*(*(p + 1) +5); // 指针访问第二行第六个元素</div></pre></td></tr></table></figure>
<h3 id="二维数组传参"><a href="#二维数组传参" class="headerlink" title="二维数组传参"></a>二维数组传参</h3><p><strong>传递给函数的数组是一份拷贝(指向数组其实位置的指针的拷贝), 所以C语言中所有参数都是传值调用</strong></p>
<ul>
<li>动态分配内存需要检测内存是否分配成功</li>
<li>防止超过已分配内存边界</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 一维数组, 使用指向整型的指针</div><div class="line">int vector[10];</div><div class="line">void func(int* matrix); // 等价于void func(int matrix[]);</div><div class="line"></div><div class="line">//二维数组, 使用指向整型数组的指针(必须有第二维的长度)</div><div class="line">int matrix[3][10];</div><div class="line">void func(int (*mat)[10]); // 等价于void func(int mat[][10]);</div></pre></td></tr></table></figure>
<h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>不同于<strong>指向数组的指针</strong>, 指针数组是一个由指针组成的数组.(<code>下标操纵优先级高于解引用</code>)</p>
<h3 id="动态二维数组"><a href="#动态二维数组" class="headerlink" title="动态二维数组"></a>动态二维数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 动态二维数组</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> row, line;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; row &gt;&gt; line) &#123;</div><div class="line">        <span class="keyword">int</span>** matrix = <span class="keyword">new</span> <span class="keyword">int</span>*[row]; </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</div><div class="line">            matrix[i] = <span class="keyword">new</span> <span class="keyword">int</span>[line];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; line; j++) &#123;</div><div class="line">                <span class="built_in">cin</span> &gt;&gt; matrix[i][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</div><div class="line">            <span class="keyword">delete</span> [] matrix[i];</div><div class="line">        <span class="keyword">delete</span> [] matrix;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>C与指针</li>
<li><a href="http://hujiandong.com/2015/09/10/smartpointer/" target="_blank" rel="external">智能指针解析与实现</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2015/10/18/Session和Cookie/" class="prev">上一篇</a><a href="/2015/09/26/使用OwnCloud在VPS上搭建私有网盘/" class="next">下一篇</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>