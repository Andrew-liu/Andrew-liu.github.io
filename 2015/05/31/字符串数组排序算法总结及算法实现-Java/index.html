<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 字符串数组排序算法总结及算法实现(Java) · Snow Memory | Andrew Liu</title><meta name="description" content="字符串数组排序算法总结及算法实现(Java) - Andrew Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">字符串数组排序算法总结及算法实现(Java)</h1><div class="post-info">May 31, 2015</div><div class="post-content"><p>本博客采用创作共用版权协议, 要求署名、非商业用途和保持一致. 转载本博客文章必须也遵循<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">署名-非商业用途-保持一致</a>的创作共用协议.</p>
<blockquote>
<p>对于字符串数据排序问题的总结, 如有错误, 欢迎指出.</p>
</blockquote>
<a id="more"></a>
<p>#键索引计数法</p>
<blockquote>
<p>这种排序算法是以下两种排序算法的基础</p>
</blockquote>
<p><strong>假设有以下一组数据</strong></p>
<table>
<thead>
<tr>
<th>组号</th>
<th>姓名</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>Anderson</td>
</tr>
<tr>
<td>3</td>
<td>Brown</td>
</tr>
<tr>
<td>3</td>
<td>Davis</td>
</tr>
<tr>
<td>1</td>
<td>Harris</td>
</tr>
</tbody>
</table>
<p>算法步骤:</p>
<ul>
<li>首先进行组号出现的频率统计, 使用count数组记录每个组号出现的次数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for(i = 0; i &lt; N; i++) </div><div class="line">    count[a[i].key() + 1)]++; //a[i].key()返回组号, count的下标从2开始, 可以由下面找到答案</div></pre></td></tr></table></figure>
<ul>
<li>将频率转换为索引, 使用count来计算每个组号在排序结果中的起始索引位置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for(int r = 0; r &lt; R; r++)</div><div class="line">    count[r + 1] += count[r]  #1组数组下标应该从零开始, 没有第0组, 第2组下标应该从1开始(1组有一个成员), 3组下标从2开始(1组和2组共两个成员)</div></pre></td></tr></table></figure>
<ul>
<li>数据分类, 将count[]转换为索引表后, 将名字移动到对应的辅助数组中排序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for(int i = 0; i &lt; N; i++)</div><div class="line">    aux[count[a[i].key()]++] = a[i] //count[a[i].key()]表示某一组的下标, ++表示同组的下一个名字的下标</div></pre></td></tr></table></figure>
<ul>
<li>回写, 将aux数组的数据回写到原排序数组中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for(i = 0; i &lt; N; i++)</div><div class="line">    a[i] = aux[i];</div></pre></td></tr></table></figure>
<p>#低位优先的字符串排序</p>
<p><strong>低位优先排序算法</strong>是通过建索引计数法完成的, 从每个字符串的最右侧开始, 以每个位置的字符作为key键(相当于组号), 用<code>键索引计数法</code>对字符串排序W遍(假设所有字符串长度为W)</p>
<blockquote>
<p>由于键索引计数法的排序是稳定的, 则可以推出低位优先的字符串排序算法能够稳定的排序定长字符串</p>
</blockquote>
<p>算法缺点: </p>
<ul>
<li>只能用于处于等长字符串排序</li>
<li>需要额外的count[]和aux[]数组空间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LSD</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, <span class="keyword">int</span> W)</span> </span>&#123;</div><div class="line">        <span class="comment">//通过后W个字符将a[]排序, 从低位开始</span></div><div class="line">        <span class="keyword">int</span> N = a.length; <span class="comment">//字符串数组长度</span></div><div class="line">        <span class="keyword">int</span> R = <span class="number">256</span>;  <span class="comment">//radix; 最多表示256的字符extern-ASCII</span></div><div class="line">        String[] aux = <span class="keyword">new</span> String[N];  <span class="comment">//存储排序后的字符串数组</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = W - <span class="number">1</span>; d &gt;= <span class="number">0</span>; d--) &#123;  <span class="comment">//低位排序从这里体现</span></div><div class="line">            <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R + <span class="number">1</span>];</div><div class="line">            <span class="comment">//计算出现频率</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">                count[a[i].charAt(d) + <span class="number">1</span>]++;  <span class="comment">//count每一位统计对应的字符的出现次数</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//将频率转换成索引, 从0开始, 256个字符从第二个字符串开始, 所在的索引应该是第一个字符的频率, 第三个字符串索引应该是第一个字符加上第二个字符</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</div><div class="line">                count[r + <span class="number">1</span>] += count[r];  <span class="comment">//第一个字符换索引为0</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">                aux[count[a[i].charAt(d)]++] = a[i];  <span class="comment">//将字符串应对的d位的数, 放在当前索引下, 然后索引加1</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//写会a[], 重复W词, 因为按照W个字符排序</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">                a[i] = aux[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#高位优先的字符串排序</p>
<p><strong>高位优先排序算法</strong>用于更通用的情形(字符串不定长), 首先用<code>键索引计数法</code>对所有字符串首字母排序, 然后在<code>递归的</code>将每个首字母所对应的子数组排序(忽略首字母)</p>
<p>当指定位置超出字符串的末尾应该返回<code>-1</code>.<strong>越界则输出-1. 这种转换意味着字符串中的每个字符都可能产生R+1中不同的值，同时键索引计数法本来就需要一个额外的位置，所以使用代码int count[] = new int[R + 2];</strong></p>
<p>在高位优先排序中, 每次递归过程都会创建一个count数组并转换成索引, 当数据量过大, 会造成很大的<code>空间代价</code>, 所以当进行小数组排序时, 切换为使用<code>插入排序算法</code>, 避免重复检查已知相同字符带来的成本</p>
<p>算法缺点:</p>
<ol>
<li>高位优先的字符串排序使用了两个辅助数组（aux[]和count[]）</li>
<li>高位优先的字符串排序的最坏情况就是所有的键均相同</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MSD</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> R = <span class="number">256</span>; <span class="comment">//字符数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">15</span>;  <span class="comment">//小数组的切换阈值</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] aux;  <span class="comment">//辅助数组, 存储中间排序结果</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">charAt</span><span class="params">(String s, <span class="keyword">int</span> d)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (d &lt; s.length())</div><div class="line">            <span class="keyword">return</span> s.charAt(d);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a)</span> </span>&#123; <span class="comment">//排序的外部接口</span></div><div class="line">        <span class="keyword">int</span> N = a.length;</div><div class="line">        aux = <span class="keyword">new</span> String[N];</div><div class="line">        sort(a, <span class="number">0</span>, N - <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//排序的内部实现, 以第d个字符为键将a[lo]至a[hi]排序, 递归过程</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> d)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (hi &lt;= lo + M) &#123;</div><div class="line">            Insertion.sort(a, lo, hi, d);  <span class="comment">//大于阈值则使用插入排序</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span> [R + <span class="number">2</span>]; <span class="comment">//计算频率</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</div><div class="line">            count[charAt(a[i], d) + <span class="number">2</span>]++; <span class="comment">//由左到右同此每个字符的频率</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R + <span class="number">1</span>; r++) &#123;</div><div class="line">            count[r + <span class="number">1</span>] += count[r]; <span class="comment">//频率转换为索引</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//数据分类</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</div><div class="line">            aux[count[charAt(a[i], d) + <span class="number">1</span>]++] = a[i];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//回写</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</div><div class="line">            sort(a, lo + count[r], lo + count[r + <span class="number">1</span>] - <span class="number">1</span>, d + <span class="number">1</span>); <span class="comment">//对每一段相同字符的字符串数据再进行排序, 比如所有以a开头的字符串数据, 对他们第2未再排序</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> d)</span> </span>&#123;<span class="comment">//从第d个字符开始对a[lo]到a[hi]排序</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; lo &amp;&amp; less(a[j], a[j - <span class="number">1</span>], d); j--)</div><div class="line">                    exch(a, j, j - <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(String v, String w, <span class="keyword">int</span> d)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> v.substring(d).compareTo(w.substring(d)) &lt; <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(String[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">            String temp = a[i];</div><div class="line">            a[i] = a[j];;</div><div class="line">            a[j] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#三向字符串快速排序</p>
<blockquote>
<p>根据高位优先, 改进为快速排序策略, 这种方法是前两种方法的结合</p>
</blockquote>
<p>根据字符串数组的首字母进行三向切分, 然后<code>递归的</code>将得到的三个子数组排序, 一个含有所有首字母小于切分字符的字符串子数组, 一个含有所有首字母等于切分字符的子数组, 一个含有所有首字母大于气氛字符串的子数组</p>
<blockquote>
<p>三项字符串快速排序能够很好地处理等值键、有较长公共前缀的键、取值范围较小的键和小数组，且只需要递归所需的隐式栈的额外空间</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick3String</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">charAt</span><span class="params">(String s, <span class="keyword">int</span> d)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (d &lt; s.length())</div><div class="line">            <span class="keyword">return</span> s.charAt(d);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a)</span> </span>&#123;</div><div class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> d)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (hi &lt;= lo)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> lt = lo, gt = hi;</div><div class="line">        <span class="keyword">int</span> v = charAt(a[lo], d); <span class="comment">//povit</span></div><div class="line">        <span class="keyword">int</span> i = lo + <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt;= gt) &#123;</div><div class="line">            <span class="keyword">int</span> t = charAt(a[i], d);</div><div class="line">            <span class="keyword">if</span> (t &lt; v)</div><div class="line">                exch(a, lt++, i++);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; v)</div><div class="line">                exch(a, i, gt--);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                i++;</div><div class="line">        &#125;</div><div class="line">        sort(a, lo, lt - <span class="number">1</span>, d);</div><div class="line">        <span class="keyword">if</span> (v &gt;= <span class="number">0</span>)</div><div class="line">            sort(a, lt, gt, d + <span class="number">1</span>);</div><div class="line">        sort(a, gt + <span class="number">1</span> , hi, d);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(String[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        String temp = a[i];</div><div class="line">        a[i] = a[j];;</div><div class="line">        a[j] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#参考链接</p>
<ul>
<li><code>&lt;算法&gt;</code></li>
<li><code>普林斯顿-Algorithm II</code></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2015/06/07/深入理解计算机系统读书笔记/" class="prev">PREV</a><a href="/2015/05/24/MySQL-Small-Cookbook/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>