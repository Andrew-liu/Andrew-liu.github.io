<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 最大流, 最小割问题及算法实现 · Snow Memory | Andrew Liu</title><meta name="description" content="最大流, 最小割问题及算法实现 - Andrew Liu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://andrewliu.in/atom.xml" title="Snow Memory | Andrew Liu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/dinosaurliu" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/Andrew-liu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">最大流, 最小割问题及算法实现</h1><div class="post-info">May 10, 2015</div><div class="post-content"><p>本博客采用创作共用版权协议, 要求署名、非商业用途和保持一致. 转载本博客文章必须也遵循<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">署名-非商业用途-保持一致</a>的创作共用协议.</p>
<blockquote>
<p>对于最大流最小割问题的总结, 如有错误, 欢迎指出.</p>
</blockquote>
<p>#最大流(MaxFlow)问题</p>
<p>给定指定的一个有向图,其中有两个特殊的点源S(Sources)和汇T(Sinks),每条边有指定的容量(Capacity),求满足条件的从S到T的最大流(MaxFlow).</p>
<blockquote>
<p>想象一条多条不同水流量的水管组成的网络, s为供水广, t为水用户, 最大流问题就是找到能够在s到t流通的最大水流量</p>
</blockquote>
<a id="more"></a>
<p><strong>一个流是最大流当且仅当其残存网络不包含任何增广路径(里面的名称在后面有详细解释)</strong></p>
<p>#流(Flow)的基本性质</p>
<p>设$C<em>{uv}$代表边u到v最大允许流量(<code>Capacity</code>), $f</em>{uv}$代表u到v的当前流量, 那么有一下两个性质:</p>
<ul>
<li>$(u, v)$为有向图边, $ 0&lt;=f<em>{uv}&lt;=C</em>{uv} $, 即对于所有的边, 当前流量不允许超过其Capacity</li>
<li>除了$s, t$之外, 对所有节点有 $ \sum\limits<em>{(v, u)}f</em>{vu} = \sum\limits<em>{(u, v)}f</em>{uv} $, 即对于任何一点, 流入该点的流量等于留出该点的流量, 流量守恒原则(类似与能量守恒的概念).</li>
</ul>
<p>非负数值$f(u, v)$为从节点u到节点v的流.一个流$|f|$的定义:</p>
<p>$$ |f| = \sum\limits<em>{v \in V}f(s,v) - \sum\limits</em>{v \in V}f(v, s) $$</p>
<blockquote>
<p>最大流问题即要找到一个<code>最大的流f</code></p>
</blockquote>
<p>#Ford-Fulkerson方法</p>
<blockquote>
<p>之所以称之为方法, 而不是算法, 因为FF(Ford-Fulkerson简称)包含不同运行时间的几种实现, 是一种迭代的方法.</p>
</blockquote>
<p>该方法主要依赖于<code>残存网络, 增广路径和割</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//伪代码</div><div class="line">初始化:所有流f = 0</div><div class="line">while 在残存网络中存在增广路径p</div><div class="line">    增加流f的值</div><div class="line">return f</div></pre></td></tr></table></figure>
<p><strong>残存网络</strong></p>
<p>给定网络G和流量f, 残存网络$G_f$由那些仍有空间对流量进行调整的边构成.</p>
<blockquote>
<p>残留网络 = 容量网络capacity - 流量网络flow</p>
</blockquote>
<p><img src="http://picturebag.qiniudn.com/74.png" alt="残存网络"></p>
<p><strong>增广路径</strong></p>
<p>增广路径p是残存网络中一条从源节点s到汇点t的简单路径,在一条增广路径p上能够为每条边增加的流量的最大值为路径p的残存容量$c_f(p) = min \{c_f(u,v):(u,v) \in p \}$</p>
<blockquote>
<p>在一条增广路径p上, 要增加整条增广路径的水流量, 则必须看最小能承受水流量的管道, 不然水管会爆掉, 这最小承受水流量就是<code>残存容量</code></p>
</blockquote>
<p><strong>割</strong></p>
<p>在有向图网络G中, 割(S, T)将V划分为S和T = V - S, 使得s属于S集合, t属于T集合. 割(S, T)的容量是指从集合S到集合T所有边的容量之和.</p>
<p><img src="http://picturebag.qiniudn.com/73.png" alt="最大流"></p>
<p>#最大流最小割理论</p>
<p>设$f$为流网络G = (V, E)中的一个流, 该流网络的源节点为s, 汇点为t, 则下面的条件是等价的:</p>
<ul>
<li>f是G的一个最大流</li>
<li>残存网络$G_f$不包含任何增广路径</li>
<li>$|f| = c(S, T)$, 其中(S, T)是流网络G的某个割</li>
</ul>
<p>#Ford-Fulkerson算法Java实现</p>
<p><strong>伪代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">for each edge(u, v)属于G.E(图G的边)</div><div class="line">    (u, v).f = 0  //所有边的流为0</div><div class="line">//循环终止条件为残存我昂罗中不存在增广路径</div><div class="line">while s到t的残存网络中存在增广路径p:</div><div class="line">    c(p) = 最小残存容量</div><div class="line">    for 增广路径的每条边</div><div class="line">        if 这条边属于E集合</div><div class="line">            (u, v).f = (u, v).f + c(p)  //意思是在原有的流增加最小残存容量.</div><div class="line">        else</div><div class="line">            (u, v).f = (u, v).f - c(p)</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//边的定义</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowEdge</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> v, w;  <span class="comment">//边的起点和终点</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> capacity;  <span class="comment">//流量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> flow;   <span class="comment">//流</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlowEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">double</span> capacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.v = v;</div><div class="line">        <span class="keyword">this</span>.w = w;</div><div class="line">        <span class="keyword">this</span>.capacity = capacity;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">from</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> v;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">to</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> w;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> capacity;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">flow</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> flow;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">other</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (vertex == v) &#123;</div><div class="line">            <span class="keyword">return</span> w;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vertex == w) &#123;</div><div class="line">            <span class="keyword">return</span> v;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Inconsistent edge"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//v中残留流量</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">residualCapacityTo</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (vertex == v) &#123;  <span class="comment">//反向边</span></div><div class="line">            <span class="keyword">return</span> flow;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vertex == w) &#123;  <span class="comment">//正向边</span></div><div class="line">            <span class="keyword">return</span> capacity - flow;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//向v中增加delta</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResidualFlowTo</span><span class="params">(<span class="keyword">int</span> vertex, <span class="keyword">double</span> delta)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (vertex == v) &#123;</div><div class="line">            flow -= delta;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vertex == w) &#123;</div><div class="line">            flow += delta;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//流图的定义</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowNetwork</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V;  <span class="comment">//顶点个数</span></div><div class="line">    <span class="keyword">private</span> Bag&lt;FlowEdge&gt;[] adj;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlowNetwork</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.V = V;</div><div class="line">        adj = (Bag&lt;FlowEdge&gt;[]) <span class="keyword">new</span> Bag[V];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</div><div class="line">            adj[v] = <span class="keyword">new</span> Bag&lt;&gt;();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//想流图中增加边</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(FlowEdge e)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> v = e.from();</div><div class="line">        <span class="keyword">int</span> w = e.to();</div><div class="line">        adj[v].add(e);  <span class="comment">//正向边</span></div><div class="line">        adj[w].add(e);  <span class="comment">//反向边</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> V;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;FlowEdge&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;  <span class="comment">//返回邻接边</span></div><div class="line">        <span class="keyword">return</span> adj[v];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//FordFulkerson方法的实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FordFulkerson</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;  <span class="comment">//如果残留网络中有s-&gt;v路径, 则为true</span></div><div class="line">    <span class="keyword">private</span> FlowEdge[] edgeTo;  <span class="comment">//s-&gt;v路径的最后的边</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> value; <span class="comment">//流</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FordFulkerson</span><span class="params">(FlowNetwork G, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</div><div class="line">        value = <span class="number">0.0</span>;</div><div class="line">        <span class="comment">//当找不到增广路径时终止</span></div><div class="line">        <span class="keyword">while</span> (hasAugmentingPaht(G, s, t)) &#123;  <span class="comment">//判断是否还有增广路径</span></div><div class="line">            <span class="keyword">double</span> bottle = Double.POSITIVE_INFINITY;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = t; v != s; v = edgeTo[v].other(v)) &#123;  <span class="comment">//计算最大流量</span></div><div class="line">                bottle = Math.min(bottle, edgeTo[v].residualCapacityTo(v));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = t; v != s; v = edgeTo[v].other(v)) &#123;</div><div class="line">                edgeTo[v].addResidualFlowTo(v, bottle);</div><div class="line">            &#125;</div><div class="line">            value += bottle;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasAugmentingPaht</span><span class="params">(FlowNetwork G, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</div><div class="line">        edgeTo = <span class="keyword">new</span> FlowEdge[G.V()];</div><div class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</div><div class="line"></div><div class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> Queue&lt;&gt;();</div><div class="line">        q.enqueue(s);</div><div class="line">        marked[s] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</div><div class="line">            <span class="keyword">int</span> v = q.dequeue();</div><div class="line">            <span class="keyword">for</span> (FlowEdge e : G.adj(v)) &#123;</div><div class="line">                <span class="keyword">int</span> w = e.other(v);</div><div class="line">                <span class="keyword">if</span> (e.residualCapacityTo(w) &gt; <span class="number">0</span> &amp;&amp; !marked[w]) &#123;</div><div class="line">                    edgeTo[w] = e;</div><div class="line">                    marked[w] = <span class="keyword">true</span>;</div><div class="line">                    q.enqueue(w);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> marked[t];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">intCut</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">//在残留网络中v-&gt;s是否可达</span></div><div class="line">        <span class="keyword">return</span> marked[v];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#参考链接</p>
<ul>
<li><code>&lt;算法导论&gt;</code></li>
<li><code>&lt;算法&gt;(普林斯顿Algorithm II)</code></li>
<li><a href="http://blog.csdn.net/xzz_hust/article/details/22041173" target="_blank" rel="external">网络流：最大流，最小割 基本概念及算法</a></li>
<li><a href="http://www.acmerblog.com/ford-fulkerson-6135.html" target="_blank" rel="external">最大流问题-Ford-Fulkerson算法</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2015/05/15/Matplotlib入门指北/" class="prev">上一篇</a><a href="/2015/05/03/Hive和Java-API操作HBase实践/" class="next">下一篇</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://andrewliu.in">Andrew Liu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-58158116-2",'auto');ga('send','pageview');</script></body></html>